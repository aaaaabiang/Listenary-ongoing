This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebase/
  hosting.ZGlzdA.cache
asset/
  Episode-Cover.svg
  LOGO.svg
  Podcast.svg
  SingleLOGO.svg
functions/
  index.js
  package.json
listenary-backend/
  config/
    apiConfig.js
    firebaseConfig.js
  modules/
    transcription-example/
      controller.ts
      model.ts
      repository.ts
      service.ts
  .gitignore
  package.json
  server.ts
server/
  index.js
  package.json
src/
  api/
    dictionaryAPI.jsx
    TranslationAPI.jsx
  components/
    AudioPlayerComponent.jsx
    CollapseBox.jsx
    TopNav.jsx
  hooks/
    useAudioPlayback.js
    useRSSInput.js
    useTranscriptionManager
    useTranscriptionSync
    useTranslationHandler
    useWordLookup
  presenter/
    HomePagePresenter.jsx
    loginPagePresenter.jsx
    PodcastChannelPresenter.jsx
    PodcastPlayPresenter.jsx
    rssPresenter.jsx
    SavedPodcastsPresenter.jsx
    WordlistPresenter.jsx
  styles/
    AudioPlayer.css
    CollapseBox.css
    HomePage.css
    LoginPage.css
    PodcastChannel.css
    PodcastPlay.css
    theme.js
    TopNav.css
    Wordlist.css
  test/
    asrTest.jsx
    TestPresenter.jsx
  views/
    PodcastView/
      DictionaryCard.jsx
      PodcastInfoCard.jsx
      PodcastPlayView.jsx
      TranscriptList.jsx
    HomePageView.jsx
    loginPageView.jsx
    PodcastChannelView.jsx
    SavedPodcastsView.jsx
    suspenseView.jsx
    WordlistView.jsx
  firestoreModel.js
  index.jsx
  loginModel.js
  Model.js
  ReactRoot.jsx
  resolvePromise.js
  rssModel.js
  speechToText.js
.firebaserc
.gitignore
firebase.json
index.html
package.json
README.md
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".firebase/hosting.ZGlzdA.cache">
saved-icon.png,1744807418273,f1b651238a58fe290baec6c5e32f3bdb1943dd2bd582f02569231f7a757c7837
logo.png,1744807418273,f1b651238a58fe290baec6c5e32f3bdb1943dd2bd582f02569231f7a757c7837
index.html,1747682694766,bda2cd4056b9f0476b38b317696e636e0ed15a199a4f3bef9e1b0649d77a350b
assets/index-BxHg_pkS.css,1747682694767,e5a4976e17a1178a0e102b8547a678538be7d339552c1a0104323ad236494f9c
assets/SingleLOGO-S-Kjgs1i.svg,1747682694766,b6cee4df303cdbe1f887681e106b52bd3e34469e50446ecdf2d790beedd34d8b
assets/vendor-XyqgThqv.js,1747682694766,e2c8f9fd1555f8fd2901722fd5873064f361129ea1cdcab8b8407df54297a500
assets/vendor-XyqgThqv.js.map,1747682694766,07168351d1f4a888f16a01e44ddca65715bd003fb652b7ee9d4aedcbd87db6e0
assets/index-B1fHrxOB.js,1747682694767,9669a3708e2f279c4d7c59d4a14bdf2a1e7506d92e74c71966dad964fa4b4544
assets/index-B1fHrxOB.js.map,1747682694768,2feb6a1b45ca0d696f4e343f64a2bf11db439a33db551dcfc7d4c754543dc16b
</file>

<file path="asset/Episode-Cover.svg">
<svg width="160" height="160" viewBox="0 0 160 160" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="160" height="160" fill="#F5F9FF"/>
<g filter="url(#filter0_i_269_1730)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M78.2744 113.5C79.0461 113.5 79.5331 112.659 79.197 111.964C77.8 109.078 77 105.845 77 102.4C77 90.153 87.0128 80.2 99.3333 80.2C100.204 80.2 101.057 80.2701 101.905 80.374C102.512 80.4485 103.056 79.9827 103.056 79.3711V46.9C103.056 42.793 99.7056 39.5 95.6111 39.5H75.2778C74.7255 39.5 74.2778 39.9477 74.2778 40.5V64.7257C74.2778 65.4824 73.4699 65.9649 72.8036 65.6061L64.4464 61.1054C64.1504 60.9459 63.7941 60.9459 63.4981 61.1054L55.1408 65.6061C54.4746 65.9649 53.6667 65.4824 53.6667 64.7257V40.5C53.6667 39.9477 53.219 39.5 52.6667 39.5H50.9444C46.8128 39.5 43.5 42.83 43.5 46.9V106.1C43.5 110.207 46.8128 113.5 50.9444 113.5H78.2744Z" fill="#D8E3FF"/>
</g>
<g filter="url(#filter1_i_269_1730)">
<path d="M94.5034 93.242C93.1701 92.4687 91.5 93.4307 91.5 94.9721V117.028C91.5 118.569 93.1701 119.531 94.5034 118.758L113.517 107.73C114.846 106.959 114.846 105.041 113.517 104.27L94.5034 93.242Z" fill="#006BFE"/>
</g>
<g filter="url(#filter2_i_269_1730)">
<path d="M56.5 60.6667V41C56.5 40.1716 57.1716 39.5 58 39.5H70C70.8284 39.5 71.5 40.1716 71.5 41V60.6667C71.5 61.0441 71.0978 61.2855 70.7647 61.1078L64.4706 57.751C64.1765 57.5941 63.8235 57.5941 63.5294 57.751L57.2353 61.1078C56.9022 61.2855 56.5 61.0441 56.5 60.6667Z" fill="#465A8D"/>
</g>
<defs>
<filter id="filter0_i_269_1730" x="43.5" y="39.5" width="59.5557" height="74" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
<filter id="filter1_i_269_1730" x="91.5" y="92.969" width="23.0137" height="26.062" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.5 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
<filter id="filter2_i_269_1730" x="56.5" y="39.5" width="15" height="21.6672" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
</defs>
</svg>
</file>

<file path="asset/LOGO.svg">
<svg width="416" height="81" viewBox="0 0 416 81" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_244_1660)">
<path d="M40.4445 5C49.2198 5 56.3334 12.136 56.3334 20.9388V27.4592C56.3334 31.6943 54.6861 35.5428 52.0001 38.3973V20.2143C52.0001 13.8123 46.8265 8.62245 40.4445 8.62245H27.4446C21.0626 8.62245 15.889 13.8123 15.889 20.2143V38.3973C13.203 35.5428 11.5557 31.6943 11.5557 27.4592V20.9388C11.5557 12.136 18.6693 5 27.4446 5H40.4445Z" fill="#D8E3FF"/>
<path d="M41.8889 13.6938C44.681 13.6938 46.9444 15.8879 46.9444 18.5943V63.4476C46.9444 66.154 46.1254 66.8991 43.3333 66.8991H6.5C5.05556 66.8991 4.33333 68.0306 4.33333 69.0237V69.6994C4.33333 70.8593 5.30339 71.7995 6.5 71.7995H49.8333C51.03 71.7995 52 70.8593 52 69.6994V34.5331C55.9722 34.5331 52.8932 34.5331 56.3333 34.5331C56.3333 36.9834 56.3333 38.4003 56.3333 39.4336V71.0995C56.3333 73.8059 54.0699 76 51.2778 76H5.05556C2.26345 76 0 73.8059 0 71.0995V18.5943C0 18.516 0.00188737 18.438 0.00564236 18.3605C0.00771593 18.3178 0.0116124 18.2752 0.0148112 18.2327C0.0177014 18.1943 0.0201823 18.156 0.02398 18.1178C0.0273287 18.0842 0.0319233 18.0508 0.0359701 18.0173C0.0417566 17.9695 0.047112 17.9218 0.0543077 17.8744C0.0591405 17.8426 0.0650688 17.8111 0.0705295 17.7794C0.0782398 17.7348 0.0862687 17.6903 0.0952149 17.6461C0.101088 17.617 0.107153 17.5881 0.113553 17.5593C0.125659 17.5047 0.138379 17.4504 0.152344 17.3966C0.157503 17.3766 0.163156 17.3569 0.168565 17.3371C0.181777 17.2887 0.195492 17.2406 0.210178 17.1928C0.221022 17.1576 0.232395 17.1225 0.244032 17.0876C0.255402 17.0534 0.26718 17.0195 0.279297 16.9856C0.293668 16.9456 0.308323 16.9057 0.32373 16.866C0.335141 16.8367 0.347023 16.8076 0.358995 16.7785C0.375235 16.7391 0.391813 16.6998 0.409071 16.6609C0.427301 16.6198 0.446148 16.5791 0.465495 16.5386C0.478581 16.5112 0.491401 16.4836 0.504991 16.4565C0.523706 16.4192 0.543874 16.3826 0.563531 16.3458C0.632423 16.2167 0.707058 16.0911 0.787107 15.969C0.808123 15.9371 0.828837 15.9048 0.850583 15.8733C0.879248 15.8318 0.908823 15.791 0.938744 15.7503C0.951983 15.7323 0.964766 15.7141 0.978243 15.6963C1.00843 15.6564 1.03996 15.6176 1.07134 15.5787C1.08848 15.5575 1.10535 15.5361 1.12283 15.5151C1.15043 15.482 1.17899 15.4497 1.20747 15.4173C1.22943 15.3924 1.25129 15.3673 1.27376 15.3429C1.30835 15.305 1.3438 15.2681 1.37956 15.2314C1.39086 15.2198 1.40199 15.208 1.41341 15.1965C1.45123 15.1585 1.48931 15.1206 1.52837 15.0837C1.5497 15.0636 1.57157 15.044 1.59326 15.0242C1.6272 14.9933 1.66142 14.9626 1.69623 14.9327C1.71504 14.9164 1.73431 14.9007 1.75336 14.8848C1.85127 14.8028 1.95168 14.7235 2.05594 14.6489C2.06638 14.6415 2.07717 14.6345 2.08767 14.6271C2.43093 14.3854 2.80686 14.1849 3.20768 14.0323C3.22035 14.0274 3.23304 14.0226 3.24577 14.0179C3.30172 13.9971 3.35815 13.9773 3.41504 13.9584C3.42467 13.9552 3.4343 13.952 3.44395 13.9489L3.55187 13.914C3.58217 13.9048 3.613 13.8973 3.64355 13.8887C3.65691 13.885 3.67035 13.8814 3.68376 13.8777C3.74238 13.8618 3.80133 13.8466 3.86078 13.8327C3.87906 13.8283 3.89744 13.8244 3.9158 13.8203C3.97515 13.8071 4.03481 13.7946 4.09494 13.7834C4.10902 13.7808 4.12314 13.7784 4.13726 13.7759C4.43513 13.7229 4.74188 13.6938 5.05556 13.6938H41.8889Z" fill="#006BFE"/>
<path d="M29.9895 50.2806C29.9895 52.8814 27.8878 54.9898 25.295 54.9898H20.9273C18.3346 54.9898 16.2329 52.8814 16.2329 50.2806C16.2329 48.281 19.3144 46.6582 23.1112 46.6582C26.908 46.6582 29.9895 48.281 29.9895 50.2806ZM23.1112 31.8061C25.4827 31.8061 27.7571 32.7984 29.434 34.5647C31.1109 36.331 32.053 38.7266 32.053 41.2245C32.053 42.382 31.8564 43.4922 31.4953 44.5172C31.1854 45.3972 30.0863 45.5602 29.4064 44.9231C28.9363 44.4826 28.8272 43.7881 29.0144 43.1707C29.2012 42.5546 29.3016 41.8983 29.3016 41.2245C29.3016 37.602 26.5503 34.7041 23.1112 34.7041C19.672 34.7041 16.9207 37.602 16.9207 41.2245C16.9207 41.8983 17.0212 42.5546 17.208 43.1707C17.3952 43.7881 17.286 44.4826 16.8159 44.9231C16.136 45.5602 15.037 45.3972 14.7271 44.5172C14.366 43.4922 14.1694 42.382 14.1694 41.2245C14.1694 38.7266 15.1115 36.331 16.7884 34.5647C18.4653 32.7984 20.7397 31.8061 23.1112 31.8061ZM23.1112 26.0102C26.9421 26.0102 30.6161 27.6131 33.3249 30.4664C36.0338 33.3196 37.5556 37.1894 37.5556 41.2245C37.5556 43.9222 36.886 46.4556 35.7191 48.6512C35.3087 49.4232 34.2848 49.5331 33.651 48.9323C33.1552 48.4623 33.0717 47.7084 33.3855 47.1008C34.289 45.352 34.8043 43.3485 34.8043 41.2245C34.8043 37.958 33.5724 34.8253 31.3795 32.5155C29.1866 30.2058 26.2124 28.9082 23.1112 28.9082C20.01 28.9082 17.0358 30.2058 14.8429 32.5155C12.65 34.8253 11.4181 37.958 11.4181 41.2245C11.4181 43.3485 11.9334 45.352 12.8369 47.1008C13.1507 47.7084 13.0672 48.4623 12.5714 48.9323C11.9375 49.5331 10.9137 49.4232 10.5033 48.6512C9.33639 46.4556 8.66675 43.9222 8.66675 41.2245C8.66675 37.1894 10.1885 33.3196 12.8975 30.4664C15.6063 27.6131 19.2803 26.0102 23.1112 26.0102ZM23.1112 37.602C24.0233 37.602 24.898 37.9837 25.5431 38.663C26.188 39.3423 26.5503 40.2637 26.5503 41.2245C26.5503 42.1852 26.188 43.1066 25.5431 43.7859C24.898 44.4653 24.0233 44.8469 23.1112 44.8469C22.1991 44.8469 21.3243 44.4653 20.6793 43.7859C20.0344 43.1066 19.672 42.1852 19.672 41.2245C19.672 40.2637 20.0344 39.3423 20.6793 38.663C21.3243 37.9837 22.1991 37.602 23.1112 37.602Z" fill="#D8E3FF"/>
<path d="M52 29.9949C52 28.1943 53.4551 26.7347 55.25 26.7347C60.6347 26.7347 65 31.1136 65 36.5153V45.2092C65 50.6108 60.6347 54.9898 55.25 54.9898C53.4551 54.9898 52 53.5302 52 51.7296V29.9949Z" fill="#D8E3FF"/>
<path d="M52 29.9949C52 28.1943 53.4551 26.7347 55.25 26.7347C60.6347 26.7347 65 31.1136 65 36.5153V45.2092C65 50.6108 60.6347 54.9898 55.25 54.9898C53.4551 54.9898 52 53.5302 52 51.7296V29.9949Z" fill="#D8E3FF"/>
</g>
<rect x="123.541" y="18.5457" width="13.3056" height="9.31393" rx="4.65696" fill="#006BFE"/>
<path d="M88 19C88 18.4477 88.4477 18 89 18H100.971C101.523 18 101.971 18.4477 101.971 19V52.1143C101.971 52.6666 102.419 53.1143 102.971 53.1143H115.94C116.492 53.1143 116.94 53.5621 116.94 54.1143V61.0956C116.94 61.6479 116.492 62.0956 115.94 62.0956H89C88.4477 62.0956 88 61.6479 88 61.0956V19Z" fill="#006BFE"/>
<path d="M123.613 32.1081C123.613 31.5558 124.061 31.1081 124.613 31.1081H136.085C136.638 31.1081 137.085 31.5558 137.085 32.1081V61.0956C137.085 61.6479 136.638 62.0956 136.085 62.0956H124.613C124.061 62.0956 123.613 61.6479 123.613 61.0956V32.1081Z" fill="#006BFE"/>
<path d="M173.46 37.0452C173.424 37.7516 172.685 38.199 172.033 37.9262C170.421 37.2524 168.834 36.7122 167.272 36.3056C165.297 35.7651 163.561 35.4948 162.064 35.4948C160.484 35.4948 159.362 35.6507 158.696 35.9626C158.031 36.2536 157.699 36.7734 157.699 37.5218C157.699 38.1871 158.187 38.7173 159.164 39.1123C160.141 39.4865 161.576 39.9231 163.468 40.422C165.36 40.921 167.054 41.4719 168.551 42.0748C170.048 42.6778 171.316 43.4262 172.356 44.3202C173.416 45.2141 174.216 46.2848 174.757 47.5322C175.318 48.7796 175.599 50.3077 175.599 52.1164C175.599 53.738 175.287 55.2245 174.663 56.5759C174.04 57.9064 173.094 59.0499 171.825 60.0062C170.557 60.9626 168.956 61.7006 167.023 62.2204C165.089 62.7401 162.813 63 160.193 63C157.865 63 155.526 62.8233 153.177 62.4699C151.043 62.1678 148.893 61.6429 146.726 60.8952C146.329 60.7582 146.067 60.3817 146.067 59.9617V52.5531C146.067 51.8322 146.807 51.347 147.477 51.6134C149.152 52.2798 150.834 52.832 152.522 53.2703C154.684 53.8316 156.742 54.1123 158.696 54.1123C162.21 54.1123 163.967 53.3846 163.967 51.9293C163.967 51.6798 163.884 51.4511 163.717 51.2432C163.551 51.0353 163.239 50.8378 162.782 50.6507C162.345 50.4428 161.721 50.2349 160.911 50.027C160.121 49.7983 159.102 49.5281 157.854 49.2162C156.129 48.8004 154.497 48.2703 152.958 47.6258C151.441 46.9605 150.11 46.1601 148.967 45.2245C147.844 44.2682 146.95 43.1559 146.285 41.8877C145.64 40.6195 145.318 39.1746 145.318 37.553C145.318 36.0977 145.62 34.7568 146.222 33.5301C146.846 32.3035 147.771 31.2536 148.998 30.3805C150.245 29.5073 151.784 28.8316 153.613 28.3534C155.464 27.8545 157.605 27.605 160.037 27.605C161.451 27.605 162.802 27.6674 164.091 27.7921C165.401 27.9168 166.638 28.0728 167.802 28.2599C168.967 28.4262 170.048 28.6133 171.046 28.8212C171.736 28.9479 172.387 29.0698 173.001 29.187C173.49 29.2804 173.834 29.7206 173.808 30.2177L173.46 37.0452Z" fill="#006BFE"/>
<path d="M199.985 63C198.052 63 196.202 62.7609 194.435 62.2827C192.667 61.8254 191.108 61.0457 189.757 59.9439C188.426 58.8212 187.356 57.3451 186.545 55.5156C185.755 53.6653 185.36 51.368 185.36 48.6237V37.1809C185.36 36.6286 184.912 36.1809 184.36 36.1809H180.154C179.602 36.1809 179.154 35.7332 179.154 35.1809V30.3528C179.154 29.8335 179.549 29.3982 180.064 29.326C181.813 29.0806 185.629 28.3596 187.407 26.5811C189.169 24.8197 189.662 20.9812 189.799 19.1702C189.84 18.6255 190.289 18.1871 190.835 18.1871H197.832C198.384 18.1871 198.832 18.6348 198.832 19.1871V27.447C198.832 27.9993 199.279 28.447 199.832 28.447H207.591C208.222 28.447 208.695 29.0243 208.578 29.6444C208.417 30.4983 208.266 31.3569 208.125 32.2204C207.983 33.1825 207.889 34.1745 207.842 35.1964C207.818 35.7422 207.374 36.1809 206.828 36.1809H199.832C199.279 36.1809 198.832 36.6286 198.832 37.1809V48.499C198.832 49.2474 198.884 49.9751 198.988 50.6819C199.112 51.368 199.351 51.9813 199.705 52.5218C200.058 53.0416 200.568 53.4678 201.233 53.8004C201.898 54.1123 202.782 54.2682 203.884 54.2682C204.59 54.2682 205.37 54.2058 206.222 54.0811C206.742 53.9924 207.303 53.8614 207.907 53.6879C208.531 53.5088 209.18 53.9252 209.24 54.5713L209.8 60.611C209.842 61.0632 209.575 61.4892 209.142 61.6283C208.011 61.9924 206.746 62.2937 205.349 62.5322C203.665 62.8441 201.877 63 199.985 63Z" fill="#006BFE"/>
<path d="M247.293 60.0315C247.293 60.4631 247.017 60.8471 246.604 60.9751C244.846 61.521 242.965 61.9777 240.963 62.3451C238.696 62.7817 236.337 63 233.884 63C231.202 63 228.644 62.6466 226.212 61.9397C223.78 61.2328 221.638 60.131 219.788 58.6341C217.938 57.1372 216.462 55.2453 215.36 52.9584C214.279 50.6507 213.738 47.9064 213.738 44.7256C213.738 42.9168 214.019 41.2432 214.58 39.7048C215.141 38.1455 215.9 36.7318 216.857 35.4636C217.834 34.1954 218.967 33.0728 220.256 32.0956C221.565 31.1185 222.958 30.2973 224.435 29.632C225.931 28.9667 227.47 28.4678 229.05 28.1351C230.63 27.7817 232.179 27.605 233.696 27.605C236.087 27.605 238.198 27.8753 240.027 28.4158C241.857 28.9356 243.374 29.6424 244.58 30.5364C245.807 31.4304 246.732 32.4699 247.356 33.6549C247.979 34.8399 248.291 36.0977 248.291 37.4283C248.291 39.0499 248.01 40.4324 247.449 41.5759C246.909 42.7193 246.17 43.6861 245.235 44.4761C244.32 45.2453 243.249 45.8586 242.023 46.316C240.817 46.7526 239.538 47.0956 238.187 47.3451C236.836 47.5738 235.453 47.7193 234.04 47.7817C232.647 47.8441 231.316 47.8753 230.048 47.8753C229.611 47.8753 229.185 47.8753 228.769 47.8753C228.757 47.8746 228.746 47.874 228.734 47.8734C228.127 47.8424 227.654 48.3839 227.804 48.9725C227.984 49.677 228.233 50.2988 228.551 50.8378C229.05 51.6486 229.663 52.3139 230.391 52.8337C231.139 53.3326 231.992 53.6965 232.948 53.9252C233.925 54.1331 234.965 54.237 236.067 54.237C236.898 54.237 237.782 54.1746 238.717 54.0499C239.674 53.9252 240.63 53.7588 241.586 53.5509C242.563 53.3222 243.53 53.0728 244.486 52.8025C244.988 52.6531 245.479 52.5009 245.958 52.346C246.614 52.1345 247.293 52.6177 247.293 53.3061V60.0315ZM227.384 41.96C227.319 42.5406 227.803 43.0204 228.387 42.991C228.64 42.9781 228.913 42.9638 229.206 42.948C229.996 42.9064 230.827 42.8337 231.701 42.7297C232.574 42.6258 233.447 42.4802 234.32 42.2931C235.193 42.106 235.983 41.8669 236.69 41.5759C237.397 41.2848 237.969 40.921 238.405 40.4844C238.842 40.0478 239.06 39.5177 239.06 38.894C239.06 37.8337 238.634 36.9917 237.782 36.368C236.95 35.7235 235.786 35.4012 234.289 35.4012C233.603 35.4012 232.865 35.5052 232.075 35.7131C231.285 35.9002 230.547 36.2744 229.861 36.8358C229.175 37.3971 228.593 38.1767 228.114 39.1746C227.75 39.9344 227.507 40.8629 227.384 41.96Z" fill="#006BFE"/>
<path d="M256.586 29.447C256.586 28.8947 257.034 28.447 257.586 28.447H268.866C269.488 28.447 269.961 29.0087 269.876 29.6247C269.812 30.092 269.748 30.6141 269.684 31.1913C269.679 31.2358 269.674 31.2803 269.669 31.3249C269.563 32.3086 270.931 32.8036 271.674 32.1506C271.828 32.0155 271.986 31.8828 272.148 31.7526C273.229 30.8794 274.414 30.1414 275.703 29.5385C276.992 28.9148 278.353 28.4366 279.788 28.1039C281.243 27.7713 282.709 27.605 284.185 27.605C285.807 27.605 287.345 27.8545 288.8 28.3534C290.256 28.8316 291.534 29.6008 292.636 30.6611C293.738 31.7214 294.611 33.1039 295.256 34.8087C295.9 36.4927 296.222 38.5405 296.222 40.9522V61.0956C296.222 61.6479 295.775 62.0956 295.222 62.0956H283.751C283.198 62.0956 282.751 61.6479 282.751 61.0956V42.9168C282.751 41.6279 282.615 40.5572 282.345 39.7048C282.075 38.8524 281.701 38.1767 281.222 37.6778C280.744 37.1788 280.173 36.8254 279.507 36.6175C278.863 36.4096 278.156 36.3056 277.387 36.3056C276.555 36.3056 275.734 36.4511 274.923 36.7422C274.112 37.0125 273.374 37.3867 272.709 37.8649C272.044 38.343 271.472 38.9044 270.994 39.5489C270.537 40.1647 270.232 40.8184 270.079 41.5102C270.064 41.5745 270.058 41.6402 270.058 41.7061V61.0956C270.058 61.6479 269.611 62.0956 269.058 62.0956H257.586C257.034 62.0956 256.586 61.6479 256.586 61.0956V29.447Z" fill="#006BFE"/>
<path d="M313.717 63C312.387 63 311.108 62.8129 309.882 62.4387C308.676 62.0644 307.605 61.4927 306.669 60.7235C305.734 59.9543 304.985 58.9875 304.424 57.8233C303.884 56.6383 303.613 55.2453 303.613 53.6445C303.613 52.106 303.863 50.7755 304.362 49.6528C304.861 48.5094 305.526 47.5322 306.358 46.7214C307.21 45.9106 308.198 45.2453 309.32 44.7256C310.464 44.185 311.669 43.7692 312.938 43.4782C314.206 43.1663 315.505 42.9584 316.836 42.8545C318.187 42.7297 319.497 42.6674 320.765 42.6674C321.638 42.6674 322.48 42.6881 323.291 42.7297C323.688 42.7501 324.072 42.7729 324.443 42.7982C325.042 42.8389 325.558 42.3562 325.473 41.7625C325.357 40.9443 325.139 40.2376 324.819 39.6424C324.362 38.7692 323.759 38.0832 323.01 37.5842C322.262 37.0644 321.389 36.7006 320.391 36.4927C319.393 36.2848 318.343 36.1809 317.241 36.1809C316.222 36.1809 315.173 36.2536 314.091 36.3992C313.031 36.5239 311.992 36.6902 310.973 36.8981C309.954 37.0852 308.977 37.2931 308.042 37.5218C307.629 37.6251 307.237 37.724 306.866 37.8188C306.231 37.9814 305.609 37.5027 305.609 36.8464V30.2141C305.609 29.7462 305.933 29.3402 306.391 29.2432C307.181 29.0759 308.012 28.9145 308.884 28.7588C310.069 28.5301 311.295 28.3326 312.563 28.1663C313.832 28 315.121 27.8649 316.43 27.7609C317.761 27.657 319.071 27.605 320.36 27.605C321.961 27.605 323.53 27.7089 325.069 27.9168C326.628 28.1039 328.094 28.4262 329.466 28.8836C330.859 29.341 332.137 29.9543 333.301 30.7235C334.486 31.4927 335.495 32.4491 336.326 33.5925C337.179 34.7152 337.844 36.0457 338.322 37.5842C338.8 39.1227 339.04 40.9002 339.04 42.9168V61.0956C339.04 61.6479 338.592 62.0956 338.04 62.0956H327.191C326.639 62.0956 326.191 61.6479 326.191 61.0956V59.9836C326.191 59.1314 324.733 58.6853 324.102 59.2578V59.2578C323.208 60.0478 322.2 60.7235 321.077 61.2848C319.954 61.8462 318.759 62.2723 317.491 62.5634C316.222 62.8545 314.965 63 313.717 63ZM318.988 55.6715C319.57 55.6715 320.235 55.5156 320.983 55.2037C321.753 54.8711 322.47 54.3721 323.135 53.7069C323.821 53.0416 324.393 52.1996 324.85 51.1809C325.212 50.4105 325.437 49.5273 325.525 48.5311C325.574 47.9809 325.12 47.5322 324.568 47.5322H324.538C323.541 47.5322 322.511 47.6362 321.451 47.8441C320.412 48.052 319.455 48.3638 318.582 48.7796C317.709 49.1954 316.992 49.7048 316.43 50.3077C315.869 50.9106 315.588 51.6071 315.588 52.3971C315.588 53.0208 315.692 53.5405 315.9 53.9563C316.108 54.3721 316.368 54.7152 316.68 54.9854C317.012 55.2349 317.376 55.4116 317.771 55.5156C318.187 55.6195 318.593 55.6715 318.988 55.6715Z" fill="#006BFE"/>
<path d="M348.083 29.447C348.083 28.8947 348.531 28.447 349.083 28.447H359.82C360.403 28.447 360.862 28.9429 360.835 29.5248C360.824 29.7595 360.815 30.0031 360.807 30.2557C360.786 30.9002 360.775 31.5863 360.775 32.3139C360.775 33.0208 360.775 33.738 360.775 34.4657V34.4657C360.775 34.9155 361.459 35.0653 361.674 34.6701C361.896 34.2621 362.137 33.8509 362.397 33.4366C363.062 32.3555 363.842 31.3888 364.736 30.5364C365.651 29.684 366.68 28.9875 367.823 28.447C368.988 27.8857 370.287 27.605 371.721 27.605C371.992 27.605 372.283 27.6258 372.595 27.6674C372.927 27.6881 373.249 27.7297 373.561 27.7921C373.873 27.8545 374.164 27.9376 374.435 28.0416C374.499 28.0599 374.561 28.0793 374.62 28.0997C374.964 28.2184 375.133 28.5791 375.102 28.9423L374.172 39.8832C374.116 40.5445 373.442 40.9686 372.803 40.7916C372.251 40.6388 371.683 40.5156 371.098 40.422C370.058 40.2349 369.154 40.1414 368.385 40.1414C367.324 40.1414 366.389 40.2765 365.578 40.5468C364.788 40.7963 364.112 41.1289 363.551 41.5447C362.99 41.9605 362.543 42.4179 362.21 42.9168C361.925 43.3729 361.718 43.8203 361.589 44.2589C361.565 44.3407 361.555 44.4256 361.555 44.5108V61.0956C361.555 61.6479 361.107 62.0956 360.555 62.0956H349.083C348.531 62.0956 348.083 61.6479 348.083 61.0956V29.447Z" fill="#006BFE"/>
<path d="M402.408 28.6258C402.408 28.0735 402.855 27.6258 403.408 27.6258H414.879C415.432 27.6258 415.879 28.0735 415.879 28.6258V42C415.879 44.3493 415.478 48.1289 415 50C414.522 51.8711 414.019 53.1247 413.166 54.58C412.314 56.0561 411.295 57.3139 410.11 58.3534C408.946 59.4137 407.657 60.2765 406.243 60.9418C404.83 61.6279 403.322 62.1268 401.721 62.4387C400.121 62.7713 398.478 62.9376 396.794 62.9376C394.528 62.9376 392.23 62.9833 389.965 62.5946C386.771 62.0466 384.413 61.3586 382.483 60.1253C382.179 59.9313 382.023 59.5774 382.061 59.2192L382.781 52.407C382.855 51.704 383.615 51.2993 384.245 51.6192C386.074 52.5473 387.364 53.091 389 53.5C390.29 53.8226 392.5 54 394.5 54C397.5 54 399.507 53.4029 401.285 51.7754C402.715 50.466 402.994 49.1434 403.049 45.8662C403.061 45.1307 401.858 44.7319 401.285 45.1933V45.1933C400.536 45.7963 399.705 46.3056 398.79 46.7214C397.875 47.1372 396.909 47.4491 395.89 47.657C394.892 47.8649 393.915 47.9688 392.958 47.9688C391.295 47.9688 389.715 47.7193 388.218 47.2204C386.721 46.7006 385.391 45.9002 384.227 44.8191C383.083 43.7173 382.168 42.3139 381.482 40.6091C380.817 38.9044 380.484 36.8669 380.484 34.4969V28.6258C380.484 28.0735 380.932 27.6258 381.484 27.6258H391.459C392.012 27.6258 392.459 28.0735 392.459 28.6258V34.1227C392.459 35.1622 392.605 36.0665 392.896 36.8358C393.208 37.5842 393.603 38.2079 394.081 38.7069C394.58 39.185 395.141 39.5489 395.765 39.7983C396.389 40.027 397.023 40.1414 397.667 40.1414C398.27 40.1414 398.852 40.0478 399.414 39.8607C399.996 39.6528 400.505 39.3617 400.942 38.9875C401.378 38.5925 401.732 38.1143 402.002 37.553C402.272 36.9917 402.408 36.3472 402.408 35.6195V28.6258Z" fill="#006BFE"/>
<defs>
<clipPath id="clip0_244_1660">
<rect width="65" height="71" fill="white" transform="translate(0 5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="asset/Podcast.svg">
<svg width="145" height="135" viewBox="0 0 145 135" fill="none" xmlns="http://www.w3.org/2000/svg">
<g filter="url(#filter0_i_266_1702)">
<path d="M41 66V61.5C41 44.103 55.103 30 72.5 30V30C89.897 30 104 44.103 104 61.5V64.0274" stroke="#D8E3FF" stroke-width="8"/>
<path d="M36.5 61.5H42C43.3807 61.5 44.5 62.6193 44.5 64V91C44.5 92.3807 43.3807 93.5 42 93.5H36.5C27.6634 93.5 20.5 86.3366 20.5 77.5C20.5 68.6634 27.6634 61.5 36.5 61.5Z" fill="#D8E3FF" stroke="#D8E3FF"/>
<path d="M108.5 93.5L103 93.5C101.619 93.5 100.5 92.3807 100.5 91L100.5 64C100.5 62.6193 101.619 61.5 103 61.5L108.5 61.5C117.337 61.5 124.5 68.6634 124.5 77.5C124.5 86.3366 117.337 93.5 108.5 93.5Z" fill="#D8E3FF" stroke="#D8E3FF"/>
<g filter="url(#filter1_i_266_1702)">
<path d="M57 63.5L57 92.5" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter2_i_266_1702)">
<path d="M65 51L65 105" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter3_i_266_1702)">
<path d="M73 60L73 96" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter4_i_266_1702)">
<path d="M81 69.5L81 86.5" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter5_i_266_1702)">
<path d="M89 72L89 84" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
</g>
<defs>
<filter id="filter0_i_266_1702" x="20" y="26" width="105" height="83.5" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="2"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.0793038 0 0 0 0 0.101942 0 0 0 0 0.350962 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter1_i_266_1702" x="54.5" y="61" width="5" height="38" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter2_i_266_1702" x="62.5" y="48.5" width="5" height="63" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter3_i_266_1702" x="70.5" y="57.5" width="5" height="45" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter4_i_266_1702" x="78.5" y="67" width="5" height="26" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter5_i_266_1702" x="86.5" y="69.5" width="5" height="21" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
</defs>
</svg>
</file>

<file path="asset/SingleLOGO.svg">
<svg width="71" height="78" viewBox="0 0 71 78" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_276_1691)">
<path d="M44.1776 0C53.7629 5.12777e-07 61.5332 7.83959 61.5332 17.5102V24.6735C61.5332 29.3261 59.7338 33.5541 56.7998 36.69V16.7143C56.7998 9.68107 51.1487 3.97959 44.1776 3.97959H29.9776C23.0065 3.97959 17.3554 9.68107 17.3554 16.7143V36.69C14.4214 33.5541 12.6221 29.3261 12.6221 24.6735V17.5102C12.6221 7.83959 20.3924 0 29.9776 0H44.1776Z" fill="#D8E3FF"/>
<path d="M45.7556 9.55103C48.8054 9.55103 51.2778 11.9614 51.2778 14.9346V64.2101C51.2778 67.1833 50.3832 68.0018 47.3333 68.0018H7.1C5.52222 68.0018 4.73333 69.2449 4.73333 70.3359V71.0782C4.73333 72.3525 5.79293 73.3854 7.1 73.3854H54.4333C55.7404 73.3854 56.8 72.3525 56.8 71.0782V32.4448C61.1389 32.4448 57.7757 32.4448 61.5333 32.4448C61.5333 35.1367 61.5333 36.6934 61.5333 37.8285V72.6164C61.5333 75.5896 59.0609 78 56.0111 78H5.52222C2.47239 78 0 75.5896 0 72.6164V14.9346C0 14.8486 0.00206159 14.7629 0.00616319 14.6778C0.00842817 14.6308 0.0126843 14.584 0.0161784 14.5374C0.0193354 14.4952 0.0220453 14.4531 0.0261936 14.4111C0.0298514 14.3742 0.0348701 14.3375 0.0392904 14.3007C0.045611 14.2482 0.0514608 14.1958 0.0593207 14.1438C0.0645997 14.1089 0.0710752 14.0742 0.0770399 14.0394C0.0854619 13.9903 0.094232 13.9415 0.104004 13.8929C0.110419 13.861 0.117044 13.8292 0.124035 13.7976C0.137259 13.7376 0.151153 13.6779 0.166407 13.6188C0.172042 13.5969 0.178216 13.5752 0.184125 13.5535C0.198556 13.5003 0.213537 13.4474 0.229579 13.395C0.241424 13.3562 0.253847 13.3177 0.266558 13.2793C0.278977 13.2418 0.291843 13.2045 0.305078 13.1674C0.320776 13.1233 0.336784 13.0795 0.353613 13.036C0.366078 13.0037 0.379056 12.9717 0.392133 12.9398C0.409872 12.8965 0.42798 12.8534 0.446831 12.8106C0.466744 12.7655 0.487331 12.7207 0.508463 12.6762C0.522757 12.6461 0.536762 12.6159 0.551606 12.5861C0.572048 12.545 0.594077 12.5048 0.615549 12.4644C0.6908 12.3227 0.772325 12.1846 0.859763 12.0505C0.882719 12.0154 0.905345 11.98 0.929098 11.9454C0.960409 11.8998 0.992714 11.8549 1.0254 11.8102C1.03986 11.7905 1.05382 11.7704 1.06854 11.7509C1.10152 11.7071 1.13595 11.6644 1.17024 11.6217C1.18895 11.5984 1.20738 11.5749 1.22648 11.5519C1.25663 11.5155 1.28782 11.48 1.31893 11.4444C1.34292 11.4171 1.3668 11.3895 1.39134 11.3626C1.42912 11.3211 1.46785 11.2805 1.5069 11.2402C1.51925 11.2274 1.53141 11.2145 1.54388 11.2018C1.58519 11.1601 1.62678 11.1184 1.66945 11.0779C1.69275 11.0558 1.71664 11.0343 1.74033 11.0126C1.77741 10.9786 1.81478 10.9449 1.85281 10.912C1.87335 10.8941 1.8944 10.8769 1.91521 10.8594C2.02216 10.7693 2.13184 10.6822 2.24571 10.6003C2.25712 10.5921 2.26891 10.5844 2.28038 10.5762C2.65532 10.3107 3.06595 10.0905 3.50378 9.9228C3.51762 9.91747 3.53148 9.91221 3.54538 9.90704C3.60649 9.8842 3.66814 9.86247 3.73028 9.84169C3.74079 9.83819 3.75131 9.83461 3.76186 9.83119L3.87973 9.7929C3.91283 9.7828 3.94651 9.77452 3.97988 9.76505C3.99448 9.76099 4.00915 9.75709 4.0238 9.75303C4.08782 9.73552 4.15222 9.7188 4.21716 9.70352C4.23713 9.69875 4.25721 9.69445 4.27726 9.68999C4.34209 9.67543 4.40725 9.66174 4.47294 9.6494C4.48831 9.64654 4.50374 9.64391 4.51917 9.64112C4.84453 9.58294 5.17959 9.55103 5.52222 9.55103H45.7556Z" fill="#006BFE"/>
<path d="M32.7578 49.7449C32.7578 52.6022 30.4621 54.9184 27.63 54.9184H22.8591C20.0271 54.9184 17.7314 52.6022 17.7314 49.7449C17.7314 47.5482 21.0973 45.7653 25.2446 45.7653C29.3918 45.7653 32.7578 47.5482 32.7578 49.7449ZM25.2446 29.449C27.835 29.449 30.3193 30.5391 32.1511 32.4795C33.9827 34.42 35.0118 37.0518 35.0118 39.7959C35.0118 41.0676 34.797 42.2873 34.4026 43.4133C34.0641 44.3801 32.8636 44.5591 32.1209 43.8592C31.6074 43.3753 31.4882 42.6123 31.6927 41.934C31.8967 41.2572 32.0065 40.5362 32.0065 39.7959C32.0065 35.8164 29.0012 32.6327 25.2446 32.6327C21.488 32.6327 18.4827 35.8164 18.4827 39.7959C18.4827 40.5362 18.5924 41.2572 18.7964 41.934C19.0009 42.6123 18.8817 43.3753 18.3682 43.8592C17.6256 44.5591 16.425 44.3801 16.0865 43.4133C15.6922 42.2873 15.4773 41.0676 15.4773 39.7959C15.4773 37.0518 16.5064 34.42 18.3381 32.4795C20.1698 30.5391 22.6542 29.449 25.2446 29.449ZM25.2446 23.0817C29.4291 23.0817 33.4422 24.8426 36.4011 27.9772C39.3601 31.1117 41.0224 35.3631 41.0224 39.7959C41.0224 42.7596 40.2909 45.5428 39.0163 47.9549C38.568 48.803 37.4496 48.9238 36.7573 48.2636C36.2157 47.7473 36.1245 46.9191 36.4673 46.2516C37.4541 44.3304 38.0171 42.1294 38.0171 39.7959C38.0171 36.2074 36.6714 32.7658 34.2761 30.2284C31.8808 27.6909 28.6321 26.2653 25.2446 26.2653C21.8571 26.2653 18.6084 27.6909 16.2131 30.2284C13.8178 32.7658 12.4721 36.2074 12.4721 39.7959C12.4721 42.1294 13.035 44.3304 14.0218 46.2516C14.3647 46.9191 14.2734 47.7473 13.7318 48.2636C13.0395 48.9238 11.9211 48.803 11.4729 47.9549C10.1983 45.5428 9.4668 42.7596 9.4668 39.7959C9.4668 35.3631 11.1291 31.1117 14.088 27.9772C17.0469 24.8426 21.0601 23.0817 25.2446 23.0817ZM25.2446 35.8164C26.2409 35.8164 27.1964 36.2356 27.9009 36.982C28.6054 37.7282 29.0012 38.7405 29.0012 39.7959C29.0012 40.8514 28.6054 41.8637 27.9009 42.6099C27.1964 43.3563 26.2409 43.7755 25.2446 43.7755C24.2483 43.7755 23.2928 43.3563 22.5882 42.6099C21.8838 41.8637 21.488 40.8514 21.488 39.7959C21.488 38.7405 21.8838 37.7282 22.5882 36.982C23.2928 36.2356 24.2483 35.8164 25.2446 35.8164Z" fill="#D8E3FF"/>
<path d="M56.7998 27.4592C56.7998 25.4811 58.3892 23.8776 60.3498 23.8776C66.2316 23.8776 70.9998 28.6883 70.9998 34.6225V44.1735C70.9998 50.1077 66.2316 54.9184 60.3498 54.9184C58.3892 54.9184 56.7998 53.3148 56.7998 51.3368V27.4592Z" fill="#D8E3FF"/>
<path d="M56.7998 27.4592C56.7998 25.4811 58.3892 23.8776 60.3498 23.8776C66.2316 23.8776 70.9998 28.6883 70.9998 34.6225V44.1735C70.9998 50.1077 66.2316 54.9184 60.3498 54.9184C58.3892 54.9184 56.7998 53.3148 56.7998 51.3368V27.4592Z" fill="#D8E3FF"/>
</g>
<defs>
<clipPath id="clip0_276_1691">
<rect width="71" height="78" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="functions/index.js">
// const functions = require("firebase-functions");
const { onRequest } = require("firebase-functions/v2/https");
const admin = require("firebase-admin");
// const cors = require("cors")({ origin: true });
const axios = require("axios");
const Parser = require("rss-parser"); // 引入 rss-parser
const AZURE_API_KEY = import.meta.env.VITE_AZURE_API_KEY;
const DEEPL_API_KEY = import.meta.env.VITE_DEEPL_API_KEY;

admin.initializeApp();

//proxy
exports.proxy = onRequest({ cors: true }, async function (req, res) {
  // cors(req, res, async () => {
  //   setCorsHeaders(res);
  //   if (req.method === "OPTIONS") {
  //     return res.status(204).send("");
  //   }

  const targetUrl = req.query.url;

  if (!targetUrl) {
    return res.status(400).send("Missing 'url' query parameter");
  }
  try {
    const axiosOptions = {
      method: req.method,
      url: targetUrl,
      headers: {
        "Content-Type": req.headers["content-type"],
        "Ocp-Apim-Subscription-Key": AZURE_API_KEY,
      },
      data: req.rawBody,
    };
    const response = await axios(axiosOptions);
    res.status(response.status).send(response.data);
  } catch (error) {
    console.error("Proxy error:", {
      message: error.message,
      code: error.code,
      config: error.config,
      responseData: error.response?.data,
      responseStatus: error.response?.status,
    });
    res.status(500).send("Failed to fetch target URL");
  }
  // });
  console.log("Incoming headers:", req.headers);
});

// Translation API Cloud Function
exports.translate = onRequest({ cors: true }, async function (req, res) {
  // Enable CORS
  // cors(req, res, async () => {
  //   // Only allow POST requests
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  try {
    // 直接使用硬编码的API密钥，与前端使用的相同
    console.log("Using API key:", DEEPL_API_KEY.substr(0, 10) + "...");

    const response = await axios.post(
      "https://api-free.deepl.com/v2/translate",
      req.body,
      {
        headers: {
          Authorization: `DeepL-Auth-Key ${DEEPL_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    //     // Return translation results
    res.json(response.data);
  } catch (error) {
    console.error("Translation error:", {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
    });

    res.status(error.response?.status || 500).json({
      error: "Translation failed",
      details: error.response?.data || error.message,
    });
  }
  // });
});

// RSS Parser
exports.parseRssFeed = onRequest({ cors: true }, async function (req, res) {
  // setCorsHeaders(res);
  // if (req.method === "OPTIONS") {
  //   return res.status(204).send("");
  // }

  const rssUrl = req.query.url;

  if (!rssUrl) {
    return res.status(400).send("Missing 'url' query parameter");
  }

  // axios
  //   .get(rssUrl, { responseType: "text" })
  //   .then(async (response) => {
  try {
    // // 使用 axios 获取 RSS 数据
    const response = await axios.get(rssUrl, {
      responseType: "text", // 确保返回的是文本数据（如 RSS XML）
    });

    // 使用 rss-parser 解析 RSS 数据
    const parser = new Parser({
      customFields: {
        feed: ["image", "language", "copyright"],
        item: [
          "itunes:duration",
          "itunes:image",
          "itunes:episode",
          "itunes:season",
          "itunes:summary",
          "enclosure",
        ],
      },
    });
    const feed = await parser.parseString(response.data);

    // 返回解析后的数据
    // res.status(200).json(
    const result = {
      feed: {
        title: feed.title,
        description: feed.description,
        image: feed.image?.url,
        link: feed.link,
      },
      items: feed.items.map(function (item) {
        return {
          title: item.title,
          description: item.contentSnippet || item.description,
          pubDate: item.pubDate || item.isoDate,
          // duration: item.itunes?.duration,//时长无法显示
          duration: formatDuration(item.itunes?.duration),
          episode: item.itunes?.episode,
          season: item.itunes?.season,
          image: item.itunes?.image || feed.image?.url,
          guid: item.guid,
          link: item.link,
          enclosure: item.enclosure,
        };
      }),
    };
    res.status(200).json(result);
  } catch (error) {
    console.error("Error parsing RSS feed:", error.message);
    // setCorsHeaders(res);
    res.status(500).send("Failed to parse RSS feed");
  }
});

function formatDuration(duration) {
  if (!duration) return "Unknown";

  if (typeof duration === "number") {
    const m = Math.floor(duration / 60);
    const s = duration % 60;
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  if (typeof duration === "string") {
    if (/^\d+$/.test(duration)) {
      // 纯数字秒数
      return formatDuration(Number(duration));
    }
    if (
      /^\d{1,2}:\d{2}$/.test(duration) ||
      /^\d{1,2}:\d{2}:\d{2}$/.test(duration)
    ) {
      // 已是标准格式
      return duration;
    }
  }

  return "Unknown";
}

// downloadAudio
exports.downloadAudio = onRequest({ cors: true }, async function (req, res) {
  const audioUrl = req.query.url;
  if (!audioUrl) return res.status(400).send("Missing audio URL");

  try {
    const response = await axios.get(audioUrl, {
      responseType: "arraybuffer",
    });

    res.set("Content-Type", response.headers["content-type"]);
    res.status(200).send(response.data);
  } catch (err) {
    console.error("Download audio failed:", err.message);
    res.status(500).send("Failed to download audio");
  }
});
</file>

<file path="functions/package.json">
{
  "dependencies": {
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "firebase-admin": "^13.3.0",
    "firebase-functions": "^6.3.2",
    "rss-parser": "^3.13.0"
  }
}
</file>

<file path="listenary-backend/config/apiConfig.js">
// Backend proxy
export const PROXY_URL = "https://proxy-7ajldlnu2q-uc.a.run.app/proxy"; // Proxy
export const PARSE_RSS_FEED_URL =
  "https://parserssfeed-7ajldlnu2q-uc.a.run.app"; // RSS Parser
// Azure Speech to Text API
export const AZURE_API_URL = "https://northeurope.api.cognitive.microsoft.com";
export const AZURE_API_KEY = import.meta.env.VITE_AZURE_API_KEY; // Azure Speech to Text API Key from .env
export const AUDIO_DOWNLOAD_URL =
  "https://downloadaudio-7ajldlnu2q-uc.a.run.app"; // Audio Download
</file>

<file path="listenary-backend/config/firebaseConfig.js">
// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
export const firebaseConfig = {
  apiKey: "AIzaSyAa84m37fzjOZzhNDMHzNlPmOGplU78kTI",
  authDomain: "dh2642-29c50.firebaseapp.com",
  projectId: "dh2642-29c50",
  storageBucket: "dh2642-29c50.firebasestorage.app",
  messagingSenderId: "389069809164",
  appId: "1:389069809164:web:eb9eb7fba4aab24fb33029",
  measurementId: "G-JMBEQCV08T",
};
</file>

<file path="listenary-backend/modules/transcription-example/controller.ts">
//  •	接收请求，解析参数。
// •	调用 Service。
// •	返回 HTTP 响应。
// •	不写业务逻辑。

// 示例代码：
// const express = require("express");
// const router = express.Router();
// const userService = require("./user.service");

// router.get("/:id", async (req, res) => {
//   try {
//     const user = await userService.getUserById(req.params.id);
//     res.json(user);
//   } catch (err) {
//     res.status(400).json({ error: err.message });
//   }
// });

// module.exports = router;
</file>

<file path="listenary-backend/modules/transcription-example/model.ts">
//•	定义数据结构。

// 示例代码
// const mongoose = require('mongoose');

// const userSchema = new mongoose.Schema({
//   name: String,
//   email: { type: String, required: true, unique: true },
//   password: String,
// });

// module.exports = mongoose.model('User', userSchema);
</file>

<file path="listenary-backend/modules/transcription-example/repository.ts">
// 数据库操作封装（CRUD）。

// user.repository.js
// const User = require('./user.model');

// exports.findById = (id) => User.findById(id);
// exports.create = (data) => User.create(data);
</file>

<file path="listenary-backend/modules/transcription-example/service.ts">
// 	•	编写业务逻辑。
//	•	调用 Repository（数据库）或其他 Service。

// 示例代码：
// const userRepository = require('./user.repository');

// exports.getUserById = async (id) => {
//   const user = await userRepository.findById(id);
//   if (!user) throw new Error('User not found');
//   return user;
// };
</file>

<file path="listenary-backend/.gitignore">
node_modules/
*.local
</file>

<file path="listenary-backend/package.json">
{
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "22"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^12.7.0",
    "firebase-functions": "^6.3.2"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}
</file>

<file path="listenary-backend/server.ts">
//add dependencies
const express = require("express");
const cors = require("cors");

//import routes/controllers
</file>

<file path="server/index.js">
// server/index.js

const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');

// 在所有代码的最顶部，加载 .env 文件中的环境变量
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3000;

// --- 中间件 ---
app.use(cors());
app.use(express.json());

// --- 从环境变量中安全地获取数据库连接字符串 ---
const MONGO_URI = process.env.MONGO_URI;
if (!MONGO_URI) {
  throw new Error('错误：.env 文件中未定义 MONGO_URI');
}

// --- 异步连接到数据库 ---
const connectDB = async () => {
  try {
    await mongoose.connect(MONGO_URI);
    console.log('成功连接到 MongoDB!');
    
    // 只有当数据库连接成功后，才启动 Express 服务器
    app.listen(port, () => {
      console.log(`后端服务器正在 http://localhost:${port} 上运行`);
    });

  } catch (error) {
    console.error('数据库连接失败:', error.message);
    process.exit(1); // 如果连接失败，则退出进程
  }
};

// --- API 路由 ---
app.get('/api', (req, res) => {
  res.json({ message: '你好！后端已连接到数据库！' });
});

// --- 调用函数来连接数据库并启动服务器 ---
connectDB();
</file>

<file path="server/package.json">
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.1.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}
</file>

<file path="src/api/dictionaryAPI.jsx">
export const DictionaryAPI = {
    async getWord(word) {
        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
        const data = await response.json();
        return data;
    }
}
</file>

<file path="src/api/TranslationAPI.jsx">
import { useState } from "react";

export default function TranslationAPI({ textToTranslate, targetLang, onTranslationComplete }){
    const apiKey = '8dd9ce8e-032f-42ed-af73-c2de472febbf:fx';
    const API_URL = '/deepl/v2/translate';
    // Check if in production environment
    const isProduction = window.location.hostname !== 'localhost';

    const translate = async function() {
        if (!textToTranslate || !targetLang) return '';
        
        try {
            // In production, requests are rewritten by Firebase to cloud functions, so no API key needed
            const headers = isProduction 
                ? { 'Content-Type': 'application/json' }
                : {
                    'Authorization': `DeepL-Auth-Key ${apiKey}`,
                    'Content-Type': 'application/json'
                };
                
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    text: [textToTranslate], //* text must be an array of strings
                    target_lang: targetLang
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Translation request failed:', {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                    isProduction: isProduction
                });
                throw new Error(`Translation failed with status: ${response.status}`);
            }

            const data = await response.json();
            const translatedText = data.translations[0].text; //*according to the example response, the translation is in the translations[0].text
            
            if (onTranslationComplete) {
                onTranslationComplete(translatedText);
            }
            
            return translatedText;
        } catch (error) {
            console.error('Translation error:', error);
            // Add retry logic
            if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                console.log('Retrying translation...');
                // Wait 1 second before retry
                await new Promise(function(resolve) {
                    setTimeout(resolve, 1000);
                });
                return translate();
            }
            return '';
        }
    };

    return { translate };
}
</file>

<file path="src/components/AudioPlayerComponent.jsx">
import {
  Box,
  Slider,
  IconButton,
  Typography,
  Stack,
  Popper,
  ClickAwayListener,
  Button,
} from "@mui/material";
import {
  PlayArrow,
  Pause,
  VolumeUp,
  VolumeOff,
  Forward10,
  Replay10,
} from "@mui/icons-material";
import {
  forwardRef,
  useRef,
  useState,
  useEffect,
  useImperativeHandle,
} from "react";
import { useTheme } from "@mui/material/styles";
import WaveSurfer from "wavesurfer.js";

const formatTime = (time) => {
  const minutes = Math.floor(time / 60)
    .toString()
    .padStart(2, "0");
  const seconds = Math.floor(time % 60)
    .toString()
    .padStart(2, "0");
  return `${minutes}:${seconds}`;
};

const AudioPlayerComponent = forwardRef(({ audioSrc, onTimeUpdate }, ref) => {
  const theme = useTheme();
  const audioRef = useRef(null);
  const waveformRef = useRef(null);
  const wavesurfer = useRef(null);

  const [playing, setPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [volumeAnchorEl, setVolumeAnchorEl] = useState(null);
  const [speedAnchorEl, setSpeedAnchorEl] = useState(null);
  const [waveformLoading, setWaveformLoading] = useState(true);
  const [showSpeedMenu, setShowSpeedMenu] = useState(false);

  // 初始化 wavesurfer
  useEffect(() => {
    if (!waveformRef.current) return;
    if (wavesurfer.current) {
      wavesurfer.current.destroy();
    }
    setWaveformLoading(true);
    wavesurfer.current = WaveSurfer.create({
      container: waveformRef.current,
      waveColor: "#b3c7f9",
      progressColor: "#1976d2",
      height: 50,
      responsive: true,
      barWidth: 2,
      barRadius: 2,
      cursorColor: "#1976d2",
    });
    wavesurfer.current.load(audioSrc);

    wavesurfer.current.on("ready", () => {
      setDuration(wavesurfer.current.getDuration());
      setWaveformLoading(false);
    });

    wavesurfer.current.on("audioprocess", () => {
      const t = wavesurfer.current.getCurrentTime();
      setCurrentTime(t);
      if (onTimeUpdate) {
        onTimeUpdate(t * 1000);
      }
    });

    wavesurfer.current.on("seek", () => {
      const t = wavesurfer.current.getCurrentTime();
      setCurrentTime(t);
      if (onTimeUpdate) {
        onTimeUpdate(t * 1000);
      }
    });

    wavesurfer.current.on("play", () => setPlaying(true));
    wavesurfer.current.on("pause", () => setPlaying(false));

    // 保持音量和倍速同步
    wavesurfer.current.setVolume(volume);
    wavesurfer.current.setPlaybackRate(playbackRate);

    return () => {
      wavesurfer.current && wavesurfer.current.destroy();
    };
    // eslint-disable-next-line
  }, [audioSrc]);

  // 音量和倍速变化时同步到 wavesurfer
  useEffect(() => {
    if (wavesurfer.current) {
      wavesurfer.current.setVolume(volume);
    }
  }, [volume]);
  useEffect(() => {
    if (wavesurfer.current) {
      wavesurfer.current.setPlaybackRate(playbackRate);
    }
  }, [playbackRate]);

  useImperativeHandle(ref, () => ({
    pause: () => {
      wavesurfer.current && wavesurfer.current.pause();
      setPlaying(false);
    },
  }));

  // 控制
  const togglePlay = () => {
    if (wavesurfer.current) {
      wavesurfer.current.playPause();
    }
  };

  const handleSliderChange = (_, value) => {
    if (wavesurfer.current) {
      wavesurfer.current.seekTo(value / duration);
      setCurrentTime(value);
    }
  };

  const handleVolumeChange = (_, value) => {
    setVolume(value);
  };

  const handleSpeedChange = (rate) => {
    setPlaybackRate(rate);
    setSpeedAnchorEl(null);
  };

  const handleForward = () => {
    if (wavesurfer.current) {
      const t = Math.min(currentTime + 10, duration);
      wavesurfer.current.seekTo(t / duration);
      setCurrentTime(t);
    }
  };
  const handleReplay = () => {
    if (wavesurfer.current) {
      const t = Math.max(currentTime - 10, 0);
      wavesurfer.current.seekTo(t / duration);
      setCurrentTime(t);
    }
  };

  return (
    <Box
      sx={{
        borderRadius: 10,
        px: 6,
        py: 2,
        bgcolor: "#fff",
        boxShadow: 1,
        width: "100%",
        gap: 2,
      }}
    >
      {/* 时间 + 波形图 */}
      <Box sx={{ display: "flex", alignItems: "center", width: "100%", mb: 1 }}>
        <Typography variant="caption" sx={{ minWidth: 40 }}>
          {formatTime(0)}
        </Typography>
        <Box sx={{ flexGrow: 1, position: "relative" }}>
          <div ref={waveformRef} style={{ width: "100%" }} />
          {waveformLoading && (
            <Box
              sx={{
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                bgcolor: "rgba(255,255,255,0.7)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 1,
              }}
            >
              <Typography variant="caption" color="text.secondary">
                Loading...
              </Typography>
            </Box>
          )}
        </Box>
        <Typography variant="caption" sx={{ minWidth: 40, textAlign: "right" }}>
          {formatTime(duration)}
        </Typography>
      </Box>

      {/* 控制条 */}
      <Stack
        direction="row"
        spacing={2}
        alignItems="center"
        justifyContent="center"
      >
        <IconButton onClick={handleReplay} sx={{ color: "#485D92" }}>
          <Replay10 />
        </IconButton>

        <IconButton onClick={togglePlay} color="primary">
          {playing ? <Pause /> : <PlayArrow />}
        </IconButton>

        <IconButton onClick={handleForward} sx={{ color: "#485D92" }}>
          <Forward10 />
        </IconButton>

        <Box
          sx={{
            position: "relative",
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <Button
            variant="text"
            size="small"
            onClick={function() {
              setShowSpeedMenu(!showSpeedMenu);
            }}
            sx={{
              minWidth: "auto",
              px: 1,
              color: "text.secondary",
              "&:hover": {
                backgroundColor: "action.hover",
              },
            }}
          >
            {playbackRate}x
          </Button>
          {showSpeedMenu && (
            <Box
              sx={{
                position: "absolute",
                bottom: "100%",
                left: "50%",
                transform: "translateX(-50%)",
                backgroundColor: "background.paper",
                borderRadius: 1,
                boxShadow: 3,
                p: 1,
                zIndex: 1400,
                mb: 1,
                minWidth: 100,
              }}
            >
              {[0.5, 0.75, 1, 1.25, 1.5, 2].map(function(speed) {
                return (
                  <Button
                    key={speed}
                    fullWidth
                    size="small"
                    onClick={function() {
                      handleSpeedChange(speed);
                      setShowSpeedMenu(false);
                    }}
                    sx={{
                      justifyContent: "flex-start",
                      color: speed === playbackRate ? "primary.main" : "text.primary",
                      "&:hover": {
                        backgroundColor: "action.hover",
                      },
                    }}
                  >
                    {speed}x
                  </Button>
                );
              })}
            </Box>
          )}
        </Box>

        <Box
          sx={{
            position: "relative",
            display: "flex",
            alignItems: "center",
          }}
        >
          <IconButton
            onClick={function(e) {
              setVolumeAnchorEl(volumeAnchorEl ? null : e.currentTarget);
            }}
            sx={{ color: "#485D92" }}
          >
            {volume > 0 ? <VolumeUp /> : <VolumeOff />}
          </IconButton>
          {Boolean(volumeAnchorEl) && (
            <Box
              sx={{
                position: "absolute",
                bottom: "100%",
                left: "50%",
                transform: "translateX(-50%)",
                backgroundColor: "background.paper",
                borderRadius: 1,
                boxShadow: 3,
                p: 2,
                zIndex: 1400,
                mb: 1,
                minWidth: 120,
              }}
            >
              <Slider
                value={volume}
                onChange={handleVolumeChange}
                min={0}
                max={1}
                step={0.01}
                orientation="vertical"
                sx={{
                  height: 100,
                  '& .MuiSlider-thumb': {
                    width: 12,
                    height: 12,
                  },
                  '& .MuiSlider-track': {
                    width: 4,
                  },
                  '& .MuiSlider-rail': {
                    width: 4,
                  }
                }}
              />
            </Box>
          )}
        </Box>
      </Stack>
    </Box>
  );
});

export default AudioPlayerComponent;
</file>

<file path="src/components/CollapseBox.jsx">
import React from "react";
import "../styles/CollapseBox.css";

class CollapseBox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { open: false };
    this.toggleBox = this.toggleBox.bind(this);
  }

  toggleBox() {
    this.setState(function (prevState) {
      return { open: !prevState.open };
    });
  }

  render() {
    return (
      <div className="collapse-box">
        <button className="collapse-toggle-btn" onClick={this.toggleBox}>
          <span className={"collapse-arrow" + (this.state.open ? " open" : "")}></span>
          {this.props.title}
        </button>
        <div
          className="collapse-content"
          style={{ display: this.state.open ? "block" : "none" }}
        >
          {this.props.children}
        </div>
      </div>
    );
  }
}

export { CollapseBox };
</file>

<file path="src/components/TopNav.jsx">
import '../styles/TopNav.css';
import { observer } from "mobx-react-lite";
import loginModel from "../loginModel";
import { useNavigate } from "react-router-dom";
import { useState } from "react";

// TopNav component - View layer in MVP architecture
export const TopNav = observer(function TopNav({ hideLogo }) {
  const user = loginModel.user;
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  function handleLoginMenuClick(e) {
    e.preventDefault();
    navigate("/login");
  }

  return (
    <nav className="top-nav">
      <div className="nav-container">
        {!hideLogo ? (
          <a href="/#/" className="brand-link">Listenary</a>
        ) : (
          <span className="slogan-text">Learn English with Podcasts</span>
        )}

        <div className="nav-links">
          <a href="/#/wordlist" className="nav-link">Wordlist</a>
          {user ? (
            <span className="nav-link" onClick={handleLoginMenuClick} style={{ cursor: 'pointer' }}>
              {user.displayName || user.email}
            </span>
          ) : (
            <span className="nav-link" onClick={handleLoginMenuClick} style={{ cursor: 'pointer' }}>
              {isLoading ? 'Logging in...' : 'Login'}
            </span>
          )}
        </div>
      </div>
    </nav>
  );
});
</file>

<file path="src/hooks/useAudioPlayback.js">
import { useEffect, useState } from "react";

/**
 * 监听 audio 元素播放时间变化，返回当前播放时间（以毫秒为单位）
 * @param {React.RefObject<HTMLAudioElement>} audioRef - 指向 AudioPlayer 组件的 ref
 * @returns {number} currentTime 当前播放时间（ms）
 */
export function useAudioPlayback(audioRef) {
  const [currentTime, setCurrentTime] = useState(0);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const updateTime = () => setCurrentTime(audio.currentTime * 1000);

    audio.addEventListener("timeupdate", updateTime);

    return () => {
      audio.removeEventListener("timeupdate", updateTime);
    };
  }, [audioRef]);

  return currentTime;
}

  // // Monitor audio playback time for text highlighting
  // useEffect(function setupAudioTimeListener() {
  //   const audio = audioRef.current;
  //   if (!audio) return;

  //   function updateTime() {
  //     setCurrentTime(audio.currentTime * 1000);
  //   }
  //   audio.addEventListener("timeupdate", updateTime);
  //   return function cleanup() {
  //     audio.removeEventListener("timeupdate", updateTime);
  //   };
  // }, []);

  // useEffect(() => {}, [currentTime]);
  // function handleTimeUpdate(time) {
  //   setCurrentTime(time);
  // }
</file>

<file path="src/hooks/useRSSInput.js">
import { useNavigate } from "react-router-dom";

export function useRSSInput() {
  const navigate = useNavigate();

  const handleRSSSubmit = (rssUrl) => {
    // Later we'll add RSS parsing logic here
    // For now, just navigate to podcast channel page
    navigate('/podcast-channel');
  };

  return handleRSSSubmit;
}
</file>

<file path="src/hooks/useTranscriptionManager">
import { useCallback } from "react";
import { AUDIO_DOWNLOAD_URL } from "../../listenary-backend/config/apiConfig.js";
import { speechToText } from "../speechToText.js"; // API HERE
import { resolvePromise } from "../resolvePromise";
// import { PROXY_URL, AUDIO_DOWNLOAD_URL } from "../apiConfig"; // Proxy URL
export function useTranscriptionManager({
  model,
  episode,
  setIsTranscribing,
  setIsLoading,
}) {
  //     //download audio file from url
  //   function downloadAndStoreAudioFile(audioUrl) {
  //     const proxyUrl = `${AUDIO_DOWNLOAD_URL}?url=${encodeURIComponent(
  //       audioUrl
  //     )}`;
  //     console.log("Proxy URL:", proxyUrl);
  //     return fetch(proxyUrl)
  //       .then(function (response) {
  //         if (response.status !== 200) throw new Error(response.status);
  //         return response.blob();
  //       })
  //       .then(function (blob) {
  //         console.log("Blob type:", blob.type);
  //         console.log("Blob size:", blob.size);

  //         const audioFile = new File([blob], "audio.wav", {
  //           type: blob.type || "audio/wav",
  //         });

  //         console.log("Downloaded audio file:", audioFile);
  //         return audioFile;
  //       });
  //   }
  const downloadAndStoreAudioFile = useCallback(async (audioUrl) => {
    const proxyUrl = `${AUDIO_DOWNLOAD_URL}?url=${encodeURIComponent(
      audioUrl
    )}`;
    const response = await fetch(proxyUrl);
    if (response.status !== 200)
      throw new Error(`HTTP error: ${response.status}`);

    const blob = await response.blob();
    return new File([blob], "audio.wav", {
      type: blob.type || "audio/wav",
    });
  }, []);

  // //request transcription api
  // function transcribeAudio(audioFile) {
  //   console.log("Transcribing audio file:", audioFile);
  //   console.log("audio file type:", audioFile.type);
  //   if (!audioFile) {
  //     console.error("No audio file provided to transcribeAudio");
  //     alert("Invalid audio file, please try another!");
  //     setIsTranscribing(false);
  //     return;
  //   }

  //   const params = {
  //     audio: audioFile,
  //     definition: JSON.stringify({ locales: ["en-US"] }),
  //   };

  //   console.log("Calling speechToText with params:", params);

  //   props.model.transcripResultsPromiseState.error = null;
  //   props.model.transcripResultsPromiseState.data = null;

  //   const prms = speechToText(params)
  //     .then((data) => {
  //       // add guid
  //       return { ...data, guid: props.model.currentEpisode.guid };
  //     })
  //     .catch((error) => {
  //       setIsTranscribing(false);
  //       setIsLoading(false);
  //       throw error;
  //     });

  //   resolvePromise(prms, props.model.transcripResultsPromiseState);
  // }

  const transcribeAudio = useCallback(
    (audioFile) => {
      const params = {
        audio: audioFile,
        definition: JSON.stringify({ locales: ["en-US"] }),
      };

      model.transcripResultsPromiseState.error = null;
      model.transcripResultsPromiseState.data = null;

      const prms = speechToText(params)
        .then((data) => ({ ...data, guid: model.currentEpisode.guid }))
        .catch((error) => {
          setIsTranscribing(false);
          setIsLoading(false);
          throw error;
        });

      resolvePromise(prms, model.transcripResultsPromiseState);
    },
    [model, setIsTranscribing, setIsLoading]
  );

  // function handleTranscribe() {
  // console.log("Transcribe button clicked");
  // if (!episode || !props.model.audioUrl) {
  //   alert("Invalid episode data");
  //   return;
  // }

  // if (isTranscribing) {
  //   console.log("Transcription is already in progress.");
  //   return;
  // }

  // setIsTranscribing(true);
  // setIsLoading(true);

  // if (
  //   props.model.transcripResults &&
  //   props.model.transcripResults.length > 0
  // ) {
  //   console.log("Transcription already exists, skipping API request.");
  //   alert("This episode has already been transcribed.");
  //   setIsTranscribing(false);
  //   return;
  // }

  //   // 提取转录文本
  //   function getSentence(phrase) {
  //     return phrase.text || "No text available";
  //   }

  //     const audio = new Audio(props.model.audioUrl);
  //     audio.addEventListener("loadedmetadata", function () {
  //       const duration = audio.duration;
  //       if (duration > 1800) {
  //         alert(
  //           "please select a shorter espisode less than 30 minutes to save usage for us :)"
  //         );
  //         setIsLoading(false);
  //         setIsTranscribing(false);
  //         return;
  //       }

  //       props.model.setAudioDuration(duration);

  //       if (props.model.audioFile) {
  //         console.log("Using existing audio file:", props.model.audioFile);
  //         transcribeAudio(props.model.audioFile);
  //       } else {
  //         console.log("Downloading audio file...");
  //         console.log("Audio URL:", props.model.audioUrl);

  //         downloadAndStoreAudioFile(props.model.audioUrl)
  //           .then(function (audioFile) {
  //             props.model.setAudioFile(audioFile);
  //             transcribeAudio(audioFile);
  //           })
  //           .catch(function (error) {
  //             console.error("Failed to download audio file:", error.message);
  //             alert("Audio download failed, please try again later!");
  //             setIsTranscribing(false);
  //           })
  //           .finally(function () {
  //             setIsLoading(false);
  //           });
  //       }
  //     });
  //   },
  //   // Remove the old saveTranscripDataACB function since we're handling it in the useEffect
  //   function saveTranscripDataACB(data) {
  //     if (data) {
  //       const newResults = data.phrases;
  //       const updatedResults = props.model.transcripResults.concat(newResults);
  //       props.model.setResults(updatedResults);
  //     } else {
  //       console.log("API returned empty data");
  //     }
  //     setIsTranscribing(false);
  //   }
  const handleTranscribe = useCallback(() => {
    if (!episode || !model.audioUrl) {
      alert("Invalid episode data");
      return;
    }

    if (setIsTranscribing) setIsTranscribing(true);
    if (setIsLoading) setIsLoading(true);

    if (model.transcripResults?.length > 0) {
      alert("This episode has already been transcribed.");
      if (setIsTranscribing) setIsTranscribing(false);
      return;
    }

    const audio = new Audio(model.audioUrl);
    audio.addEventListener("loadedmetadata", () => {
      const duration = audio.duration;
      if (duration > 1800) {
        alert("Please select a shorter episode (less than 30 minutes).");
        if (setIsLoading) setIsLoading(false);
        if (setIsTranscribing) setIsTranscribing(false);
        return;
      }

      model.setAudioDuration(duration);

      if (model.audioFile) {
        transcribeAudio(model.audioFile);
      } else {
        downloadAndStoreAudioFile(model.audioUrl)
          .then((audioFile) => {
            model.setAudioFile(audioFile);
            transcribeAudio(audioFile);
          })
          .catch((error) => {
            console.error("Failed to download audio file:", error.message);
            alert("Audio download failed, please try again later!");
            if (setIsTranscribing) setIsTranscribing(false);
          })
          .finally(() => {
            if (setIsLoading) setIsLoading(false);
          });
      }
    });
  }, [
    episode,
    model,
    transcribeAudio,
    downloadAndStoreAudioFile,
    setIsTranscribing,
    setIsLoading,
  ]);

  return { handleTranscribe };
}
</file>

<file path="src/hooks/useTranscriptionSync">
import { useEffect } from "react";
import { saveTranscriptionData } from "../firestoreModel";
import loginModel from "../loginModel";

/**
 * Hook to handle transcription state change and sync with Firestore
 */
export function useTranscriptionSync({
  model,
  episode,
  data,
  error,
  setIsTranscribing,
  setIsLoading,
}) {
  useEffect(() => {
    if (data && data.guid === episode?.guid) {
      console.log("Setting transcription results:", data.phrases);
      model.setResults(data.phrases);
      setIsTranscribing(false);
      setIsLoading(false);

      const user = loginModel.getUser();
      if (user && episode?.guid) {
        saveTranscriptionData(
          user.uid,
          episode.guid,
          episode.title,
          data.phrases
        ).then(() => {
          const event = new CustomEvent("transcriptionComplete", {
            detail: { guid: episode.guid },
          });
          window.dispatchEvent(event);
        });
      }
    }
  }, [data, error, episode]);
}

//   //address race condition
//   const guid = episode?.guid;
//   const data = props.model.transcripResultsPromiseState.data;
//   const error = props.model.transcripResultsPromiseState.error;

//   useEffect(() => {
//     console.log("useEffect triggered", { data, guid, episode });
//     if (data && data.guid === guid) {
//       console.log("Setting results:", data.phrases);
//       props.model.setResults(data.phrases);
//       setIsTranscribing(false);
//       setIsLoading(false);

//       // Save transcription data and dispatch event
//       const user = loginModel.getUser();
//       if (user && episode?.guid) {
//         saveTranscriptionData(
//           user.uid,
//           episode.guid,
//           episode.title,
//           data.phrases
//         ).then(function () {
//           console.log("Transcription saved, dispatching event...");
//           const event = new CustomEvent("transcriptionComplete", {
//             detail: { guid: episode.guid },
//           });
//           window.dispatchEvent(event);
//         });
//       }
//     }
//   }, [data, error, guid]);
</file>

<file path="src/hooks/useTranslationHandler">
import TranslationAPI from "../api/TranslationAPI.jsx";
export function useTranslationHandler({
  transcriptionData,
  setTargetLanguage,
  setTranslations,
  setTranslatingItems
}) {
  const handleLanguageChange = async (event) => {
    const newTargetLang = event.target.value;
    setTargetLanguage(newTargetLang);
    if (!newTargetLang) {
      setTranslations({});
      setTranslatingItems(new Set());
      return;
    }

    let wordCount = 0;
    const MAX_WORDS = 100;
    const newTranslations = {};
    const translatingSet = new Set();

    for (const item of transcriptionData) {
      const words = item.text.split(/\s+/).length;
      if (wordCount + words > MAX_WORDS) {
        newTranslations[item.text] =
          "Due to API usage limits, only part of the text is translated for reference.";
        continue;
      }
      wordCount += words;
      translatingSet.add(item.text);
    }

    setTranslations(newTranslations);
    setTranslatingItems(translatingSet);

    for (const item of transcriptionData) {
      if (!translatingSet.has(item.text)) continue;
      const translator = TranslationAPI({
        textToTranslate: item.text,
        targetLang: newTargetLang,
        onTranslationComplete: (translatedText) => {
          setTranslations((prev) => ({ ...prev, [item.text]: translatedText }));
          setTranslatingItems((prev) => {
            const newSet = new Set(prev);
            newSet.delete(item.text);
            return newSet;
          });
        },
      });
      translator.translate();
    }
  };

  return { handleLanguageChange };
}
</file>

<file path="src/hooks/useWordLookup">
import { useState } from "react";
import { saveWordToUserWordlist } from "../firestoreModel";
import loginModel from "../loginModel";

export function useWordLookup(model) {
  const [wordCard, setWordCard] = useState({
    word: "",
    phonetics: { uk: null, us: null },
    definition: null,
    examples: null,
    relatedTerms: null,
  });

  function handleWordSelect(word) {
    const cleanWord = word.replace(/[^\w'-]/g, "");
    console.log("Looking up word:", cleanWord);

    model
      .lookupWord(cleanWord)
      .then((result) => {
        console.log("Dictionary API result:", result);
        if (result && result[0]) {
          setWordCard(result[0]);
        } else {
        setWordCard({
        word: cleanWord,
        phonetics: { uk: null, us: null },
        definition: null,
        examples: null,
        relatedTerms: null,
        });
        }
      })
      .catch((error) => {
        console.error("Error looking up word:", error);
        setWordCard({
        word: cleanWord,
        phonetics: { uk: null, us: null },
        definition: null,
        examples: null,
        relatedTerms: null,
        });
      });
  }

  async function handleAddToWordlist(wordData) {
    const user = loginModel.getUser();
    if (!user) {
      return { success: false, message: "Please Login First", type: "warning" };
    }

    try {
      await saveWordToUserWordlist(user.uid, wordData);
      return {
        success: true,
        message: "Added to the default wordlist",
        type: "success",
      };
    } catch (error) {
      console.error("Error saving word to wordlist:", error);
      return { success: false, message: "Failed to save word", type: "error" };
    }
  }

  return { wordCard, handleWordSelect, handleAddToWordlist };
}

//   const [wordCard, setWordCard] = useState({
//     word: "",
//     phonetics: { uk: null, us: null },
//     definition: null,
//     examples: null,
//     relatedTerms: null,
//   });

//   /**
//    * Handle word selection and lookup
//    * @param {string} word - The selected word to look up
//    */
//   function handleWordSelect(word) {
//     const cleanWord = word.replace(/[^\w'-]/g, "");
//     console.log("Looking up word:", cleanWord);
//     props.model
//       .lookupWord(cleanWord)

//       .then((result) => {
//         console.log("Dictionary API result:", result);
//         if (result && result[0]) {
//           setWordCard(result[0]);
//         } else {
//           console.log("No dictionary data found for word:", cleanWord);
//           setWordCard({
//             word: cleanWord,
//             phonetic: null,
//             phonetics: [],
//             meanings: [],
//           });
//         }
//       })
//       .catch((error) => {
//         console.error("Error looking up word:", error);
//         setWordCard({
//           word: cleanWord,
//           phonetic: null,
//           phonetics: [],
//           meanings: [],
//         });
//       });
//   }

//   /**
//    * Handle adding word to user's wordlist
//    * First checks if user is logged in, then saves the word to Firestore
//    * @param {Object} wordData - The word data to save
//    * @returns {Object} - Result with success status and message
//    */
//   async function handleAddToWordlist(wordData) {
//     // Check if user is logged in
//     const user = loginModel.getUser();

//     if (!user) {
//       // User is not logged in, show message
//       return { success: false, message: "Please Login First", type: "warning" };
//     }

//     try {
//       // Save word to Firestore
//       await saveWordToUserWordlist(user.uid, wordData);
//       return {
//         success: true,
//         message: "Added to the default wordlist",
//         type: "success",
//       };
//     } catch (error) {
//       console.error("Error saving word to wordlist:", error);
//       return { success: false, message: "Failed to save word", type: "error" };
//     }
//   }
</file>

<file path="src/presenter/HomePagePresenter.jsx">
import { HomePageView } from "../views/HomePageView";
import { observer } from "mobx-react-lite";
import { useNavigate } from "react-router-dom";
import { useState } from "react";

// HomePagePresenter: Handles all business logic for the home page
// - Manages navigation
// - Handles RSS URL input and parsing
// - Manages saved podcasts display
const HomePagePresenter = observer(function HomePagePresenter(props) {
  const navigate = useNavigate();
  const savedPodcasts = props.model.savedPodcasts;
  const [errorMsg, setErrorMsg] = useState("");
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  // Verify RSS link format
  function isValidRssUrl(url) {
    try {
      new URL(url);
    } catch (e) {
      return false;
    }

    // verification of RSS links
    const rssPatterns = [
      /\.xml$/i, // .xml end
      /\/feed/i, // include /feed
      /\/rss/i, // include /rss
      /\/podcast/i, // include /podcast
      /\/itunes/i, // include /itunes
      /\/feedburner/i, // include /feedburner
    ];

    return rssPatterns.some(function (pattern) {
      return pattern.test(url);
    });
  }

  // Handle RSS URL input changes
  function inputHandlerACB(event) {
    props.model.setRssUrl(event.target.value);
    setErrorMsg("");
  }

  // Handle RSS feed parsing
  function handleParseClick() {
    const url = props.model.rssUrl;

    if (!url || url.trim() === "") {
      setErrorMsg("Please enter the rss link!");
      return;
    }

    if (!isValidRssUrl(url)) {
      setErrorMsg("Please enter a valid RSS link!");
      return;
    }

    setErrorMsg("");
    props.model
      .loadRssData()
      .then(function () {
        navigate("/podcast-channel");
      })
      .catch(function (error) {
        navigate("/");
        setErrorMsg("Parsing failed, please check the RSS link!");
        setSnackbarOpen(true);
        console.error("Error in handleParseClick:", error);
      });
  }

  // Handle saved podcast click - navigate to podcast channel
  function handleSavedPodcastClick(podcast) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.rssUrl } });
  }

  console.log("HomePagePresenter render", props.model.savedPodcasts.length);

  return (
    <HomePageView
      url={props.model.rssUrl}
      onInputChange={inputHandlerACB}
      onParseClick={handleParseClick}
      savedPodcasts={savedPodcasts}
      onSavedPodcastClick={handleSavedPodcastClick}
      errorMsg={errorMsg}
      snackbarOpen={snackbarOpen}
      onSnackbarClose={() => setSnackbarOpen(false)}
    />
  );
});

export { HomePagePresenter };
</file>

<file path="src/presenter/loginPagePresenter.jsx">
import { useState, useEffect } from "react"
import loginModel from "../loginModel.js"
import LoginView from "../views/loginPageView.jsx"
import { loadUserData } from "../firestoreModel"
import { model } from "../Model"
import { useNavigate } from "react-router-dom";

function LoginPresenter() {
  // Local state to manage view updates
  const [modelState, setModelState] = useState({
    isLoading: loginModel.getIsLoading(),
    user: loginModel.getUser()
  })

  const navigate = useNavigate();

  // Set up auth state listener without automatically triggering login popup
  useEffect(function effectCallback() {
    // Only responsible for synchronizing user status
    function onAuthChange() {
      updateViewState();
    }
    const unsubscribe = loginModel.setupAuthStateListener(onAuthChange);
    return function cleanup() {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Helper function to update view state from model
  function updateViewState() {
    setModelState({
      isLoading: loginModel.getIsLoading(),
      user: loginModel.getUser()
    });
  }

  function handleGoogleLogin(e) {
    e.preventDefault();
    setModelState(function(prev) { return {...prev, isLoading: true}; });

    loginModel.googleLogin()
      .then(function(result) {
        const user = result.user;
        // Load user data from Firestore
        return loadUserData(user.uid).then(function(userData) {
          if (userData && userData.savedPodcasts) {
            model.savedPodcasts = userData.savedPodcasts;
          }
          // Navigate after successful login
          navigate("/");
        });
      })
      .catch(function(error) {
        alert("Login failed: " + error.message);
      })
      .finally(function() {
        setModelState(function(prev) {
          return {...prev, isLoading: false};
        });
      });
  }

  function handleLogout() {
    loginModel.logout()
      .then(function() {
        console.log("Logout successful");
        updateViewState();
        // Stay on the current page after logout
      })
      .catch(function(error) {
        console.error("Logout failed:", error.message);
        alert("Logout failed: " + error.message);
      });
  }

  // Pass data and event handlers to the view
  return (
    <LoginView
      isLoading={modelState.isLoading}
      user={modelState.user}
      onGoogleLogin={handleGoogleLogin}
      onLogout={handleLogout}
    />
  )
}
export default LoginPresenter
</file>

<file path="src/presenter/PodcastChannelPresenter.jsx">
import { observer } from "mobx-react-lite";
import { PodcastChannelView } from "../views/PodcastChannelView";
import { useState, useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { getDocs, collection } from "firebase/firestore";
import { db } from "../firestoreModel";
import loginModel from "../loginModel"; // Import login model to check user status

// Presenter component for podcast channel page
// Handles all business logic and state management
const PodcastChannelPresenter = observer(function PodcastChannelPresenter(props) {
  const navigate = useNavigate();
  const location = useLocation();
  const rssUrl = location.state?.rssUrl || props.model.rssUrl;
  const model = props.model;
  const channelInfo = props.model.podcastChannelInfo;
  const episodes = props.model.podcastEpisodes;

  // State management
  const [user, setUser] = useState(null);
  const [isSaved, setIsSaved] = useState(false);
  const [transcribedGuids, setTranscribedGuids] = useState([]);
  const [savedEpisodes, setSavedEpisodes] = useState([]);
  const [filterType, setFilterType] = useState("all");
  const [visibleCount, setVisibleCount] = useState(10);
  const [snackbarState, setSnackbarState] = useState({
    open: false,
    message: "",
    severity: "success"
  });

  // Initialize user state
  useEffect(function initUser() {
    const currentUser = loginModel.getUser();
    setUser(currentUser);
  }, []);

  // Add auth state listener
  useEffect(function setupAuthListener() {
    const unsubscribe = loginModel.setupAuthStateListener(function(user) {
      setUser(user);
    });
    return function cleanup() {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Load RSS data and transcription data
  useEffect(function loadData() {
    if (rssUrl) {
      model.setRssUrl(rssUrl);
      model.loadRssData();
    }

    loadTranscriptionData();
  }, [rssUrl, user]);

  // Function to load transcription data
  function loadTranscriptionData() {
    if (user) {
      const transRef = collection(db, "users", user.uid, "transcriptions");
      getDocs(transRef).then(function handleTranscriptions(snapshot) {
        const guids = snapshot.docs.map(function getDocId(doc) {
          return doc.id.trim();
        });
        setTranscribedGuids(guids);
      }).catch(function(error) {
        console.error("Error loading transcription data:", error);
      });
    }
  }

  // Check if podcast is saved
  useEffect(function checkSavedStatus() {
    if (channelInfo) {
      function isPodcastSaved(podcast) {
        return podcast.title === channelInfo.title;
      }
      const saved = model.savedPodcasts.find(isPodcastSaved);
      setIsSaved(!!saved);
    }
  }, [model.savedPodcasts, channelInfo]);

  // Mark transcribed episodes
  useEffect(function markTranscribedEpisodes() {
    if (episodes.length > 0) {
      function markIfTranscribed(episode) {
        const hasTranscript = transcribedGuids.includes(episode.guid.trim());
        return { ...episode, isTranscribed: hasTranscript };
      }
      const markedEpisodes = episodes.map(markIfTranscribed);
      setSavedEpisodes(markedEpisodes);
    }
  }, [episodes, transcribedGuids]);

  // Handle scroll loading
  useEffect(function handleScrollLoading() {
    function handleScroll() {
      if (
        window.innerHeight + window.scrollY >= document.body.offsetHeight - 100 &&
        visibleCount < episodes.length
      ) {
        setVisibleCount(function incrementCount(prev) {
          return prev + 5;
        });
      }
    }
    window.addEventListener("scroll", handleScroll);
    return function cleanup() {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [visibleCount, episodes.length]);

  // Show snackbar notification
  function showSnackbar(message, severity = "success") {
    setSnackbarState({
      open: true,
      message: message,
      severity: severity
    });
  }

  // Handle snackbar close
  function handleSnackbarClose(event, reason) {
    if (reason === "clickaway") return;
    setSnackbarState(function updateState(prev) {
      return { ...prev, open: false };
    });
  }

  // Handle episode play
  function handlePlay(episode) {
    if (!episode) {
      alert("Episode not found");
      return;
    }

    if (episode.enclosure.url) {
      model.setAudioUrl(episode.enclosure.url);
    } else {
      console.error("Episode does not have a valid audio URL:", episode);
    }

    model.setCurrentEpisode(episode);
    model.setAudioUrl(episode.enclosure.url);
    navigate("/podcast-play");
  }

  // Add event listener for transcription completion
  useEffect(function setupTranscriptionListener() {
    function handleTranscriptionComplete(event) {
      loadTranscriptionData();
    }
    
    window.addEventListener("transcriptionComplete", handleTranscriptionComplete);
    
    return function cleanup() {
      window.removeEventListener("transcriptionComplete", handleTranscriptionComplete);
    };
  }, [user]);

  // Handle podcast save
  function savePodcastHandler(podcast) {
    const currentUser = loginModel.getUser();
    if (!currentUser) {
      return { success: false, message: "Please Login First", type: "warning" };
    }
    if (!podcast.rssUrl) {
      podcast.rssUrl = rssUrl;
    }
    model.addToSaved(podcast);
    setIsSaved(true);
    return { success: true, message: "Podcast saved successfully", type: "success" };
  }

  // Handle podcast remove
  function removePodcastHandler(podcast) {
    const currentUser = loginModel.getUser();
    if (!currentUser) {
      return { success: false, message: "Please Login First", type: "warning" };
    }
    model.removeFromSaved(podcast);
    setIsSaved(false);
    return { success: true, message: "Podcast removed from saved list", type: "success" };
  }

  // Handle filter change
  function handleFilterChange(event, newFilter) {
    if (newFilter !== null) {
      setFilterType(newFilter);
    }
  }

  // Filter episodes based on type
  function filterEpisodes(ep) {
    if (filterType === "transcribed") return ep.isTranscribed;
    if (filterType === "untranscribed") return !ep.isTranscribed;
    return true;
  }

  const filteredEpisodes = savedEpisodes.filter(filterEpisodes);

  if (!channelInfo || episodes.length === 0) {
    return <div style={{ padding: "2rem" }}>Loading podcast...</div>;
  }

  return (
    <PodcastChannelView
      channelInfo={channelInfo}
      episodes={filteredEpisodes.slice(0, visibleCount)}
      isSaved={isSaved}
      onSavePodcast={savePodcastHandler}
      onRemovePodcast={removePodcastHandler}
      onPlay={handlePlay}
      filterType={filterType}
      onFilterChange={handleFilterChange}
      snackbarState={snackbarState}
      onSnackbarClose={handleSnackbarClose}
    />
  );
});

export default PodcastChannelPresenter;
</file>

<file path="src/presenter/PodcastPlayPresenter.jsx">
import { observer } from "mobx-react-lite";
import { PodcastPlayView } from "../views/PodcastView/PodcastPlayView";
import AudioPlayer from "../components/AudioPlayerComponent";
import { useAudioPlayback } from "../hooks/useAudioPlayback";
import { useTranscriptionSync } from "../hooks/useTranscriptionSync";
import { useWordLookup } from "../hooks/useWordLookup";
import { useLocation, useNavigate } from "react-router-dom";
import { useEffect, useState, useRef } from "react";
import {getTranscriptionData} from "../firestoreModel"; // Import the Firestore function
import loginModel from "../loginModel"; // Import login model to check user status
import { useTranscriptionManager } from "../hooks/useTranscriptionManager";

const PodcastPlayPresenter = observer(function PodcastPlayPresenter(props) {
  const location = useLocation();
  const navigate = useNavigate();
  const episode =
    props.model.currentEpisode ||
    JSON.parse(localStorage.getItem("currentEpisode"));
  const [isLoading, setIsLoading] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const audioRef = useRef(null);
  const currentTime = useAudioPlayback(audioRef);
  const { handleTranscribe } = useTranscriptionManager({
    model: props.model,
    episode,
    setIsTranscribing,
    setIsLoading,
  });
  const processedTranscriptionData = processTranscriptionData();
  const data = props.model.transcripResultsPromiseState.data;
  const error = props.model.transcripResultsPromiseState.error;
  const { wordCard, handleWordSelect, handleAddToWordlist } = useWordLookup(props.model);

  // set current episode from localStorage
  useEffect(() => {
    if (!props.model.currentEpisode) {
      const localEpisode = JSON.parse(localStorage.getItem("currentEpisode"));
      if (localEpisode) {
        props.model.setCurrentEpisode(localEpisode);
      }
    }
  }, []);


  // Save current episode to localStorage
  useEffect(
    function saveCurrentEpisode() {
      if (episode) {
        localStorage.setItem("currentEpisode", JSON.stringify(episode));
      }
    },
    [episode]
  );

  useEffect(() => {
    // clear transcription results
    props.model.transcripResultsPromiseState.error = null;
    props.model.transcripResultsPromiseState.data = null;

    if (!episode) return;
    console.log("Episode changed to:", episode.title);
    props.model.setResults([]);
    props.model.setAudioDuration(0);
    props.model.setAudioFile(null);

    async function fetchTranscriptFromFirestore() {
      const user = loginModel.getUser();
      if (user && episode?.guid) {
        const phrases = await getTranscriptionData(user.uid, episode.guid);
        if (phrases.length > 0) {
          props.model.setResults(phrases);
        }
      }
    }
    fetchTranscriptFromFirestore();
  }, [props.model.currentEpisode]);

  function getTimestamp(phrase) {
    const totalMilliseconds = phrase.offsetMilliseconds || 0;
    const totalSeconds = Math.floor(totalMilliseconds / 1000);
    const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
    const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(
      2,
      "0"
    );
    const seconds = String(totalSeconds % 60).padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  }

  // Extract the transcribed text
  function getSentence(phrase) {
    return phrase.text || "No text available";
  }

  function processTranscriptionData() {
    const results = [];
    for (let i = 0; i < props.model.transcripResults.length; i++) {
      const phrase = props.model.transcripResults[i];
      results.push({
        timestamp: getTimestamp(phrase),
        text: getSentence(phrase),
        offsetMilliseconds: phrase.offsetMilliseconds || 0,
      });
    }
    return results;
  }

  useTranscriptionSync({
    model: props.model,
    episode,
    data,
    error,
    setIsTranscribing,
    setIsLoading,
  });

  //back to channel page
  function handleBack() {
    navigate("/podcast-channel");
  }
  if (!episode) {
    return (
      <div style={{ padding: "2rem" }}>
        {" "}
        <p>No episode data</p> <button onClick={handleBack}>← Back</button>{" "}
      </div>
    );
  }

  function getPodcastData() {
    return {
      title: episode.title,
      description: episode.description,
      audioUrl: props.model.audioUrl,
      duration: episode.duration,
      source: props.model?.podcastChannelInfo?.title || "Podcast",
      coverImage: episode.image,
    };
  }

  return (
    <PodcastPlayView
      podcastData={getPodcastData()}
      audioDuration={props.model.audioDuration}
      transcriptionData={processedTranscriptionData}
      wordCard={wordCard}
      AudioPlayerComponent={AudioPlayer}
      audioSrc={props.model.audioUrl}
      audioRef={audioRef}
      onWordSelect={handleWordSelect}
      onTranscribe={handleTranscribe}
      isLoading={isLoading}
      isTranscribing={isTranscribing}
      currentTime={currentTime}
      // onTimeUpdate={handleTimeUpdate}
      onAddToWordlist={handleAddToWordlist} // Pass wordlist handler to View
    />
  );
});

export default PodcastPlayPresenter;
</file>

<file path="src/presenter/rssPresenter.jsx">
import { useEffect } from 'react';
import { RssModel } from '../rssModel';

//测试组件
export const RssPresenter = () => {
  useEffect(() => {
    function extractRssData() {
      const rssModel = new RssModel();
      
      rssModel.loadFeed('https://feeds.bbci.co.uk/news/rss.xml', (error, data) => {
        if (error) {
          console.error('RSS data extraction failed:', error);
          return;
        }
        
        // URLs仅在后台使用
        console.log('Backend URLs:', data.urls);
        
        // 文章信息将用于前端展示
        console.log('Frontend Articles Data:', data.articles);
        
        // 这里可以存储articles数据，供后续页面展示使用
      });
    }
    
    extractRssData();
  }, []);

  // 暂时返回空组件，稍后添加展示逻辑
  return <div>RSS Data Extractor</div>;
}
</file>

<file path="src/presenter/SavedPodcastsPresenter.jsx">
import { observer } from "mobx-react-lite";
import { SavedPodcastsView } from "../views/SavedPodcastsView";

var SavedPodcastsPresenter = observer(function SavedPodcastsPresenter(props) {
  return (
    <SavedPodcastsView savedPodcasts={props.model.savedPodcasts} />
  );
});

export default SavedPodcastsPresenter;
</file>

<file path="src/presenter/WordlistPresenter.jsx">
import { observer } from "mobx-react-lite";
import { WordlistView } from "../views/WordlistView";
import { useState, useEffect } from "react";
import { getUserWordlist } from "../firestoreModel";
import loginModel from "../loginModel";

/**
 * Wordlist Presenter Component - Part of the Presenter layer in MVP
 * Manages the retrieval and display of user's saved words
 */
export const WordlistPresenter = observer(function WordlistPresenter(props) {
  // State for handling wordlist display and selection
  const [userWords, setUserWords] = useState([]);
  const [selectedWordIndex, setSelectedWordIndex] = useState(-1);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Fetch user words when component mounts or login state changes
  useEffect(() => {
    async function fetchUserWords() {
      setIsLoading(true);
      setError(null);
      
      const user = loginModel.getUser();
      if (user) {
        try {
          const words = await getUserWordlist(user.uid);
          setUserWords(words);
          // Select first word if available
          if (words.length > 0) {
            setSelectedWordIndex(0);
          }
        } catch (err) {
          console.error("Error fetching wordlist:", err);
          setError("Failed to load wordlist. Please try again later.");
        }
      } else {
        setUserWords([]);
        setSelectedWordIndex(-1);
      }
      
      setIsLoading(false);
    }
    
    fetchUserWords();
  }, [loginModel.user]); // Re-fetch when user login state changes
  
  /**
   * Handle selection of a word from the wordlist
   * @param {number} index - The index of the selected word
   */
  const handleWordSelect = (index) => {
    setSelectedWordIndex(index);
  };
  
  // Get the currently selected word for display in the details panel
  const selectedWord = selectedWordIndex >= 0 && selectedWordIndex < userWords.length 
    ? userWords[selectedWordIndex] 
    : null;

  return (
    <WordlistView 
      words={userWords}
      selectedWordIndex={selectedWordIndex}
      selectedWord={selectedWord}
      onWordSelect={handleWordSelect}
      isLoading={isLoading}
      error={error}
      isLoggedIn={!!loginModel.user}
    />
  );
});
</file>

<file path="src/styles/AudioPlayer.css">
.audio-player-container {
  width: 100%;
  padding: 10px;
}

.audio-player {
  width: 100%;
}
</file>

<file path="src/styles/CollapseBox.css">
.collapse-box {
  background: transparent;
  border: none;
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.collapse-toggle-btn {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background: transparent;
  border: none;
  color: #4285f4;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 500;
  cursor: pointer;
  padding: 0 0 0 0;
  outline: none;
  transition: color 0.2s;
}
.collapse-toggle-btn:hover {
  color: #2a65c4;
}
.collapse-arrow {
  display: inline-block;
  margin-right: 8px;
  border: solid #4285f4;
  border-width: 0 2px 2px 0;
  padding: 4px;
  transform: rotate(45deg);
  transition: transform 0.2s;
}
.collapse-arrow.open {
  transform: rotate(225deg);
}
.collapse-content {
  background: transparent;
  border: none;
  padding: 16px 0 0 0;
  width: 100%;
}
.rss-guide-list {
  text-align: left;
  font-size: 16px;
  line-height: 1.7;
  margin: 0 0 0 18px;
  padding: 0;
}
.rss-guide-list li {
  margin-bottom: 8px;
}
.rss-guide-bottom {
  font-size: 14px;
  color: #666;
  margin-top: 10px;
  text-align: left;
}
@media (max-width: 700px) {
  .collapse-box {
    max-width: 98vw;
  }
}
</file>

<file path="src/styles/HomePage.css">
.homepage-container {
  display: flex;
  flex-direction: column;
  padding: 20px 20px 40px;
  min-height: 100vh;
  align-items: center;
  background-color: #fff;
  position: relative;
}

.center-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 100px 20px 40px;
  justify-content: center; 
}

.logo-container {
  margin: 0 auto;
}

.top-nav {
  position: absolute;
  top: 10px;
  right: 20px;
  z-index: 100;
  background: none;
  border: none;
}

.nav-links {
  display: flex;
  gap: 20px;
}

.nav-link {
  color: #333;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.nav-link:hover {
  background-color: #f5f5f5;
  color: #4285f4;
}

.logo-container {
  margin-top: 40px;
  margin-bottom: 40px;
}

.logo {
  height: 50px;
}

.search-container {
  width: 100%;
  max-width: 600px;
  margin-bottom: 30px;
  position: relative;
  display: flex;
  gap: 8px;
  margin: 0 auto;
  max-width: 600px;
}

/* .search-input {
  flex: 1;
  padding: 15px 20px;
  border-radius: 25px;
  border: 1px solid #e0e0e0;
  background-color: #f5f5f5;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  outline: none;
  transition: all 0.3s ease;
} */

.search-input:focus {
  border-color: #4285f4;
  box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.1);
}

.search-button {
  background: #4285f4;
  border: none;
  border-radius: 25px;
  padding: 0 28px;
  height: 48px;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 2px rgba(60, 60, 60, 0.03);
  transition: all 0.2s;
  margin-left: 8px;
}

.search-button:hover {
  background: #2a65c4;
  color: #fff;
  transform: scale(1.05);
  border: none;
}

/* .search-icon {
  font-size: 20px;
  color: #D8E3FF;
} */

.help-link {
  color: #4285f4;
  text-decoration: none;
  margin-bottom: 40px;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

.example-rss-link {
  color: #006BFE;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

.help-link-wrapper {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  padding: 0;
  height: auto;
  margin-top: 20px;
}

.collapse-box {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.collapse-toggle-btn {
  justify-content: center;
}

.collapse-content {
  width: 100%;
}

.rss-guide-list,
.rss-guide-bottom {
  text-align: left;
}

.saved-section {
  width: 100%;
  max-width: 1200px;
}

.saved-header {
  display: flex;
  align-items: center;
  margin-bottom: 24px;
  margin-top: 24px;
}

.saved-title {
  font-family: 'Candal', sans-serif;
  font-weight: 400;
  font-size: 20px;
  line-height: 32px;
  letter-spacing: 0px;
  text-align: center;
  color: #106EFF;
}

.saved-icon {
  color: #106EFF;
  margin-right: 10px;
  vertical-align: middle;
}

.saved-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  width: 100%;
}

.saved-item {
  background-color: #f5f5f5;
  border-radius: 40px;
  padding: 20px;
  min-height: 150px;
  display: flex;
  flex-direction: column;
  justify-content: left;
  align-items: center;
  position: relative;
}

.saved-item-image-wrapper {
  width: 100%;
  aspect-ratio: 8/5;
  background: #eee;
  border-radius: 20px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 15px;
  margin-top: 2px;
}

.saved-item-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  border-radius: 20px;
}

.saved-item-title {
  font-size: 20px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  margin: 0.5rem 0;
}

.saved-item-description {
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #6b7280;
  margin-bottom: 0.5rem;
  max-height: 2.8em;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
}

.no-saved-container {
  grid-column: 1 / -1;
  background-color: #f7f7f749;
  border-radius: 12px;
  border: 2px solid #e0e0e0;
  padding: 24px;
  width: 100%;
  box-sizing: border-box;
  text-align: center;
}

.no-saved-podcasts {
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #4472ce;
  text-align: center;
  width: 100%;
  margin-bottom: 20px;
}

.no-saved-image {
  width: 160px;
  height: 150px;
  margin-bottom: 0px;
}

.item-number {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.1);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #666;
}

.show-more {
  color: #4285f4;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  margin-top: 20px;
  text-align: right;
  display: block;
  padding: 0px 30px;
}

.show-more:hover {
  text-decoration: underline;
}

.top-nav .logo {
  display: none;
}
</file>

<file path="src/styles/LoginPage.css">
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Inter", sans-serif;
  background-color: #ffffff;
  min-height: 100vh;
}

.login-wrapper {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #ffffff;
}

.login-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 400px;
  padding: 20px;
  text-align: center;
}

.login-title {
  color: #0066ff;
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 48px;
}

.google-sign-in-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: #ffffff;
  border: 1px solid #dadce0;
  border-radius: 4px;
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.25px;
  height: 40px;
  transition: all 0.2s ease;
  padding: 0;
  margin: 0 auto;
  color: #3c4043;
  min-width: 220px;
}

.google-sign-in-button:hover {
  background-color: #f8f9fa;
  border-color: #dadce0;
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.google-sign-in-button:active {
  background-color: #f1f3f4;
  border-color: #dadce0;
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
}

.google-sign-in-content {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 0 24px;
  height: 100%;
}

.google-icon {
  width: 18px;
  height: 18px;
}

.terms-text {
  margin-top: 24px;
  font-size: 12px;
  color: #5f6368;
}

.terms-link {
  color: #0066ff;
  text-decoration: none;
}

.terms-link:hover {
  text-decoration: underline;
}

.welcome-container {
  background-color: #f1f3f4;
  padding: 24px;
  border-radius: 8px;
  width: 100%;
  border: 1px solid #dadce0;
}

.welcome-text {
  color: #202124;
  margin-bottom: 16px;
  font-size: 14px;
}

.min-h-screen {
  min-height: 100vh;
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.bg-white {
  background-color: #ffffff;
}

.p-4 {
  padding: 1rem;
}

.mb-8 {
  margin-bottom: 2rem;
}

.w-10 {
  width: 2.5rem;
}

.h-10 {
  height: 2.5rem;
}

.bg-\[\#0066ff\] {
  background-color: #0066ff;
}

.mr-3 {
  margin-right: 0.75rem;
}

.text-4xl {
  font-size: 2.25rem;
}

.font-bold {
  font-weight: 700;
}

.text-\[\#0066ff\] {
  color: #0066ff;
}

.w-full {
  width: 100%;
}

.max-w-md {
  max-width: 28rem;
}

.space-y-4 > * + * {
  margin-top: 1rem;
}

.space-y-1 > * + * {
  margin-top: 0.25rem;
}

.text-sm {
  font-size: 0.875rem;
}

.text-gray-600 {
  color: #4b5563;
}

.relative {
  position: relative;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}

.border {
  border: 1px solid #e5e7eb;
}

.rounded-md {
  border-radius: 0.375rem;
}

.focus\:outline-none:focus {
  outline: none;
}

.focus\:ring-2:focus {
  box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);
}

.focus\:ring-\[\#0066ff\]:focus {
  box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);
}

.absolute {
  position: absolute;
}

.right-3 {
  right: 0.75rem;
}

.top-1\/2 {
  top: 50%;
}

.-translate-y-1\/2 {
  transform: translateY(-50%);
}

.text-gray-400 {
  color: #9ca3af;
}

.hover\:text-gray-600:hover {
  color: #4b5563;
}

.bg-\[\#4d8bff\] {
  background-color: #4d8bff;
}

.text-white {
  color: #ffffff;
}

.rounded-full {
  border-radius: 9999px;
}

.font-medium {
  font-weight: 500;
}

.hover\:bg-\[\#0055dd\]:hover {
  background-color: #0055dd;
}

.transition-colors {
  transition-property: color, background-color, border-color;
  transition-duration: 150ms;
}

.hover\:bg-\[\#3d7bff\]:hover {
  background-color: #3d7bff;
}

.space-y-3 > * + * {
  margin-top: 0.75rem;
}

.pt-2 {
  padding-top: 0.5rem;
}

.bg-\[\#f1f3f4\] {
  background-color: #f1f3f4;
}

.text-black {
  color: #000000;
}

.hover\:bg-\[\#e8eaed\]:hover {
  background-color: #e8eaed;
}

.mr-2 {
  margin-right: 0.5rem;
}

.login-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background-color: #fff;
}

.login-logo {
  margin-bottom: 4rem;
}

.login-logo-text {
  font-size: 2.5rem;
  font-weight: 700;
  color: #0066ff;
}

.login-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  background-color: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  transition: all 0.2s ease;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.login-button:hover {
  background-color: #f9fafb;
}

.login-button-icon {
  width: 1.25rem;
  height: 1.25rem;
  margin-right: 0.75rem;
}

.login-button-text {
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}

.login-terms {
  margin-top: 2rem;
  font-size: 0.75rem;
  color: #9ca3af;
  text-align: center;
  max-width: 16rem;
}

.login-terms-link {
  color: #6b7280;
  text-decoration: none;
}

.login-terms-link:hover {
  text-decoration: underline;
}
</file>

<file path="src/styles/PodcastChannel.css">
.podcast-channel-page {
  min-height: 100vh;
  background-color: #fff;
}

/* Navigation Bar */
/* .top-nav {
  width: 100%;
  padding: 1rem 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #fff;
  position: sticky;
  top: 0;
  z-index: 100;
} */

/* .nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1400px;
  margin: 0 auto;
}

.brand-link {
  font-size: 1.5rem;
  font-weight: 700;
  color: #111827;
  text-decoration: none;
  transition: color 0.2s ease;
} */

/* .brand-link:hover {
  color: #1a56db;
} */

/* .nav-links {
  display: flex;
  justify-content: flex-end;
  gap: 1.5rem;
}

.nav-link {
  color: #4b5563;
  text-decoration: none;
  font-size: 0.875rem;
  font-weight: 500;
  transition: color 0.2s ease;
} */

/* .nav-link:hover {
  color: #1a56db;
} */

/* Main Content */
.podcast-channel {
  max-width: 1200px;
  margin: 2rem auto 0;
  padding: 0 2rem;
}

/* Channel Header */
.channel-header {
  display: flex;
  gap: 2rem;
  margin-bottom: 3rem;
}

.channel-cover {
  flex-shrink: 0;
  width: 200px;
  height: 200px;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.channel-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.channel-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
}

.channel-title {
  font-size: 2rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
}

.channel-description {
  font-size: 1rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
}

.save-button {
  align-self: flex-start;
  padding: 0.5rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  color: #fff;
  background-color: #0066ff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.save-button:hover {
  background-color: #0052cc;
}

.save-button.saved {
  background-color: #059669;
}

.save-button.saved:hover {
  background-color: #047857;
}

/* Episodes Section */
.episodes-container {
  margin-top: 2rem;
}

.episodes-title {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 2rem;
}

.episodes-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.episode-card {
  display: flex;
  gap: 1.5rem;
  padding: 1.5rem;
  background-color: #fff;
  transition: background-color 0.2s ease;
}

.episode-card:hover {
  background-color: #f9fafb;
}

.episode-cover {
  flex-shrink: 0;
  width: 100px;
  height: 100px;
  border-radius: 20px;
  overflow: hidden;
}

.episode-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.episode-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.episode-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1rem;
}

.episode-title {
  font-size: 1rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.play-button {
  flex-shrink: 0;
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  color: #fff;
  background-color: #0066ff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.play-button:hover {
  background-color: #0052cc;
}

.play-button.saved {
  background-color: #059669;
}

.play-button.saved:hover {
  background-color: #047857;
}

.episode-description {
  font-size: 0.95rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
}

.episode-meta {
  display: flex;
  gap: 1rem;
  font-size: 0.875rem;
  color: #6b7280;
}

.episode-duration::before {
  content: "🎧";
  margin-right: 0.25rem;
}

.episode-date::before {
  content: "📅";
  margin-right: 0.25rem;
}
</file>

<file path="src/styles/PodcastPlay.css">
.podcast-play-page {
  min-height: 100vh;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

/* PodcastPlay.css */
.typography-scrollable::-webkit-scrollbar {
  width: 6px;
}
.typography-scrollable::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}
.typography-scrollable {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
}



/* Podcast Info Header */
/* .podcast-info-header {
  padding: 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #f9fafb;
  display: flex;
  align-items: flex-start;
  gap: 2rem;
} */

/* .episode-cover-image {
  width: 160px;
  height: 160px;
  border-radius: 8px;
  object-fit: cover;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
} */

/* .episode-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1rem;
} */

/* .channel-info {
  margin-bottom: 0.5rem;
} */

/* .channel-title {
  font-size: 1rem;
  color: #6b7280;
  font-weight: 500;
} */

/* .episode-title {
  font-size: 2.5rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 1rem;
  line-height: 1.2;
} */

/* .episode-description {
  font-size: 1rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
} */
/* 
.episode-meta {
  display: flex;
  gap: 1rem;
  color: #6b7280;
  font-size: 0.875rem;
} */

/* Main Content */
/* .podcast-play-content {
  padding: 2rem;
  flex: 1;
  transition: opacity 0.2s ease;
  position: relative;
} */

/* .podcast-play-content.dimmed {
  opacity: 0.7;
  pointer-events: none;
} */

/* Transcript Container */
/* .transcript-container {
  background-color: #fff;
  border-radius: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  width: 60%;
} */

/* Transcript Header */
/* .transcript-header {
  display: flex;
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 16px;
} */

/* .transcript-header {
  display: flex;
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 16px;
} */


/* .language-select-container {
  display: flex;
  align-items: center;
} */

/* .language-select {
  padding: 10px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: white;
  font-size: 16px;
  color: #333;
  cursor: pointer;
  outline: none;
  min-width: 120px;
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 8px center;
  background-size: 16px;
} */

/* .language-select:hover {
  border-color: #666;
} */

/* .language-select:focus {
  border-color: #1976d2;
  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
} */

/* Transcript Content */
.transcript-content {
  /* max-height: 1000px; */
  height: 100%;
  width: 100%;
  padding: 0rem 0.5rem;
  overflow-y: auto;
  scroll-behavior: smooth;
  position: relative; 
}

.transcript-row {
  display: flex;
  align-items: flex-start;
  margin-bottom: 8px;
  grid-template-columns: 0.8fr 2fr 1.2fr;
  gap: 1rem;
  padding: 0.5rem 0rem;
  border-bottom: 1px solid #f3f4f6;
  transition: background-color 0.2s ease;
}

.transcript-row:hover {
  background-color: #f9fafb;
}

.transcript-row:last-child {
  border-bottom: none;
}

.timestamp-column {
  width: 80px;
  font-size: 0.8rem;
  color: #888;
  flex-shrink: 0;
}

.transcription-cell {
  word-break: break-word; 
  overflow-wrap: break-word;
  white-space: pre-wrap; 
}

.translation-cell {
  line-height: 1.5;
  display: flex;
  align-items: center;
}

.timestamp-cell {
  color: #6b7280;
}

.timestamp-inline {
  font-size: 0.8rem;
  color: #888;
  /* margin-right: 8px; */
}

.translation-cell {
  color: #111827;
}

.translation-text {
  font-size: 0.95rem;
  color: #555;
  margin-top: 4px;
}

/* Dictionary Overlay */
.dictionary-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  z-index: 150;
  display: flex;
  justify-content: center;
  align-items: flex-start;
}

/* Dictionary Mask */
.dictionary-mask {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.1);
  z-index: 1000;
}

/* Dictionary Card */
.dictionary-card {
  position: fixed;
  width: 400px;
  min-width: 400px;
  max-width: 400px;
  height: auto;
  max-height: 400px;
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1001;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  bottom: 32px;
}

/* 词典卡片内容区域，滚动 */
.dictionary-card-content {
  flex: 1 1 auto;
  overflow-y: auto;
  margin-bottom: 1rem;
}

/* 固定底部按钮 */
.add-to-wordlist-btn {
  width: 100%;
  padding: 0.75rem;
  margin-top: 1.5rem;
  background-color: #2563eb;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: absolute;
  left: 0;
  bottom: 0;
  border-radius: 0 0 8px 8px;
  margin: 0;
}

.add-to-wordlist-btn:hover {
  background-color: #1d4ed8;
}

.add-to-wordlist-btn:active {
  background-color: #1e40af;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.word-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #e5e7eb;
}

.word-text {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.word-level {
  padding: 0.25rem 0.5rem;
  background-color: #e0f2fe;
  color: #0369a1;
  font-weight: 500;
  border-radius: 9999px;
  font-size: 0.75rem;
}

.word-phonetics {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.phonetic {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.phonetic-label {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  min-width: 30px;
}

.phonetic-text {
  color: #111827;
  font-family: monospace;
}

.phonetic-audio {
  height: 24px;
  margin-left: auto;
}

.meaning-section {
  margin-bottom: 1.5rem;
}

.part-of-speech {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
  font-style: italic;
}

.definition-item {
  margin-bottom: 1rem;
}

.definition-text {
  color: #374151;
  font-size: 0.875rem;
  line-height: 1.5;
  margin-bottom: 0.5rem;
}

.example-text {
  color: #4b5563;
  font-size: 0.875rem;
  line-height: 1.5;
  font-style: italic;
  padding-left: 1rem;
  border-left: 2px solid #e5e7eb;
}

.word-synonyms,
.word-antonyms {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #e5e7eb;
}

.word-synonyms h4,
.word-antonyms h4 {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
}

.synonyms-list,
.antonyms-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.synonym-tag,
.antonym-tag {
  padding: 0.25rem 0.75rem;
  background-color: #f3f4f6;
  color: #4b5563;
  border-radius: 9999px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.synonym-tag:hover,
.antonym-tag:hover {
  background-color: #e5e7eb;
}

/* Transcribe Button */
.transcribe-button {
  padding: 0.5rem 1.5rem;
  background-color: #006BFE;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.transcribe-button:hover {
  background-color: #4338CA;
  transform: translateY(-1px);
}

.transcribe-button:active {
  background-color: #3730A3;
  transform: translateY(0);
}

.transcript-row.active-row {
  background-color: #f1f5ff00;
  transition: background-color 0.3s ease;
}

.word-hover {
  cursor: pointer;
  padding: 0 0.2px; 
  transition: background-color 0.2s ease, color 0.2s ease;
}

.word-hover:hover {
  background-color: rgba(0, 26, 255, 0.753); 
  /* box-shadow: 0 0 0 4px rgba(0, 47, 255, 0.822); */
  color: white;
  padding: 2 0px; 
  /* border-radius: 6px;  */
}

.active-word {
  background-color: transparent; 
  color: #0400ff; 
  /* font-weight: bold;  */
}

.podcast-main-layout {
  display: flex;
  margin: 0 auto;
  gap: 2rem;
  padding-bottom: 90px; /* Adjust if player height changes */
}

.left-panel {
  flex: 0 0 45%; 
  display: flex;
  flex-direction: column;
}

.right-panel {
  width: 60%;
}

/* Notification Toast */
.notification-toast {
  position: fixed;
  bottom: 110px; /* 90px for player + 20px margin */
  left: 50%;
  transform: translateX(-50%);
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  color: white;
  z-index: 2000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  animation: fadeInUp 0.3s ease, fadeOutDown 0.3s ease 2.7s;
}

.notification-toast.info {
  background-color: #3498db;
}

.notification-toast.success {
  background-color: #2ecc71;
}

.notification-toast.warning {
  background-color: #f39c12;
}

.notification-toast.error {
  background-color: #e74c3c;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

@keyframes fadeOutDown {
  from {
    opacity: 1;
    transform: translate(-50%, 0);
  }
  to {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
}

/* Fixed bottom audio player */
.bottom-audio-player {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100vw;
  background: #fff;
  z-index: 2001;
  box-shadow: 0 -2px 8px rgba(0,0,0,0.08);
  padding: 0.5rem 0;
}
</file>

<file path="src/styles/theme.js">
// theme.js
import { createTheme } from "@mui/material/styles";

// Material Design 3 示例主色调：蓝色
const theme = createTheme({
  palette: {
    mode: "light", // 可切换为 "dark" 实现暗色模式
    primary: {
      main: "#0066ff",       // 主按钮、链接、操作颜色
      contrastText: "#ffffff",
    },
    secondary: {
      main: "#e0e0e0",       // 用于中性背景、分隔线等
    },
    background: {
      default: "#f9f9f9",    // 页面背景
      paper: "#ffffff",      // 卡片背景（Surface）
    },
    text: {
      primary: "#111827",    // 主文本
      secondary: "#4b5563",  // 副文本
    },
  },
  shape: {
    borderRadius: 12,        // 更圆的外观，符合 M3
  },
  typography: {
    fontFamily: "Roboto, sans-serif",
    button: {
      textTransform: "none", // 按钮不全大写，M3 推荐
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      defaultProps: {
        disableElevation: true, // M3 风格通常不使用阴影
      },
      styleOverrides: {
        root: {
          borderRadius: "999px", // Pill-style 按钮，视觉上圆润
          padding: "8px 20px",
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          boxShadow: "0px 2px 4px rgba(0, 0, 0, 0.08)",
        },
      },
    },
    MuiTypography: {
      styleOverrides: {
        h1: { fontSize: "2.5rem", fontWeight: 700 },
        h2: { fontSize: "2rem", fontWeight: 700 },
        h3: { fontSize: "1.75rem", fontWeight: 600 },
        body1: { fontSize: "1rem" },
        body2: { fontSize: "0.95rem" },
      },
    },
  },
});


export default theme;
</file>

<file path="src/styles/TopNav.css">
.top-nav {
  width: 100%;
  padding: 1rem 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #fff;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1400px;
  margin: 0 auto;
}

.brand-link {
  font-size: 1.5rem;
  font-family: 'Candal', sans-serif;
  font-weight: 700;
  color: #2f71ff !important;
  text-decoration: none;
  transition: color 0.2s ease;
}

.brand-link:hover {
  color: #0e42b1 !important;
}

.nav-links {
  display: flex;
  justify-content: flex-end;
  gap: 1.5rem;
  margin-left: auto; 
}

.nav-link {
  color: #4b5563;
  text-decoration: none;
  font-size: 0.875rem;
  font-weight: 500;
  transition: color 0.2s ease;
}

.nav-link:hover {
  color: #1a56db;
} 

.slogan-text {
  font-size: 18px;
  font-weight: 700;
  color: #106EFF;
  margin-left: 12px;
}
</file>

<file path="src/styles/Wordlist.css">
.page-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: #f9fafb;
}

.wordlist-container {
  flex: 1;
  display: flex;
  padding: 2rem;
  gap: 2rem;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

/* Sidebar Navigation */
.wordlist-sidebar {
  width: 300px;
  background-color: #fff;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  height: fit-content;
  max-height: 80vh;
  overflow-y: auto;
}

.sidebar-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
}

.wordlist-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  max-height: 60vh;
  overflow-y: auto;
}

.wordlist-item {
  padding: 0.75rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f9fafb;
}

.wordlist-item:hover {
  background-color: #f3f4f6;
}

.wordlist-item.selected {
  background-color: #eff6ff;
  border-left: 3px solid #3b82f6;
  color: #1d4ed8;
}

.wordlist-name {
  font-size: 0.95rem;
  font-weight: 500;
}

.wordlist-count {
  font-size: 0.75rem;
  color: #6b7280;
  background-color: #f3f4f6;
  padding: 0.25rem 0.5rem;
  border-radius: 999px;
  font-style: italic;
}

/* Main Content Area */
.wordlist-content {
  flex: 1;
  background-color: #fff;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  max-height: 80vh;
  overflow-y: auto;
}

.content-title {
  font-size: 2rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
}

/* Status Messages */
.login-prompt, 
.loading-state, 
.error-state, 
.empty-state,
.no-selection {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f9fafb;
  text-align: center;
  color: #4b5563;
  margin-top: 1rem;
}

.login-prompt {
  background-color: #eff6ff;
  border: 1px dashed #93c5fd;
}

.error-state {
  background-color: #fee2e2;
  border: 1px dashed #fca5a5;
  color: #b91c1c;
}

.loading-state {
  background-color: #f3f4f6;
  border: 1px dashed #d1d5db;
}

.empty-state {
  background-color: #f3f4f6;
  border: 1px dashed #d1d5db;
}

.no-selection {
  background-color: #f3f4f6;
  font-style: italic;
  padding: 3rem;
  text-align: center;
}

/* Word Details Styling */
.word-details {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.phonetics-section {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.phonetic-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.5rem;
  background-color: #f9fafb;
  border-radius: 6px;
}

.phonetic-text {
  font-family: monospace;
  font-size: 0.95rem;
  color: #4b5563;
}

.phonetic-audio-btn {
  background-color: #e0f2fe;
  border: none;
  color: #0369a1;
  padding: 0.35rem 0.75rem;
  border-radius: 4px;
  font-size: 0.875rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  transition: all 0.2s ease;
}

.phonetic-audio-btn:hover {
  background-color: #bae6fd;
}

.meaning-section {
  margin-bottom: 2rem;
  padding: 1rem;
  background-color: #f9fafb;
  border-radius: 8px;
  border-left: 4px solid #e5e7eb;
}

.part-of-speech {
  font-size: 1.1rem;
  font-weight: 500;
  color: #4b5563;
  font-style: italic;
  margin-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 0.5rem;
}

.definition-item {
  margin-bottom: 1.25rem;
  padding-left: 0.5rem;
  border-left: 2px solid #e5e7eb;
}

.definition-text {
  font-size: 1rem;
  line-height: 1.6;
  color: #111827;
  margin-bottom: 0.5rem;
}

.example-text {
  font-size: 0.95rem;
  line-height: 1.5;
  color: #6b7280;
  font-style: italic;
  padding-left: 1rem;
  margin-top: 0.5rem;
}

/* Synonyms and Antonyms */
.word-synonyms, .word-antonyms {
  margin-top: 1rem;
  padding-top: 0.75rem;
  border-top: 1px dashed #e5e7eb;
}

.word-synonyms h4, .word-antonyms h4 {
  font-size: 0.95rem;
  color: #4b5563;
  margin-bottom: 0.75rem;
}

.synonyms-list, .antonyms-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.synonym-tag, .antonym-tag {
  background-color: #f3f4f6;
  color: #4b5563;
  font-size: 0.875rem;
  padding: 0.35rem 0.75rem;
  border-radius: 999px;
  transition: all 0.2s ease;
}

.synonym-tag:hover, .antonym-tag:hover {
  background-color: #e5e7eb;
}

.word-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1rem;
}

.word-item {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f9fafb;
  border: 1px solid #e5e7eb;
  transition: all 0.2s ease;
}

.word-item:hover {
  background-color: #fff;
  border-color: #bfdbfe;
}

.word-text {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 0.75rem;
}

.word-phonetics {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid #e5e7eb;
}

.phonetic {
  font-size: 0.875rem;
  color: #6b7280;
  font-family: monospace;
  background-color: #fff;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  border: 1px solid #e5e7eb;
}
</file>

<file path="src/test/asrTest.jsx">
import { useEffect } from "react";
import { speechToText } from "../speechToText.js";
import { PROXY_URL } from "../../listenary-backend/config/apiConfig.js";

/**
 * ASR Test Component
 * Used for testing speech-to-text functionality
 */
export function AsrTest() {
  useEffect(function testAsrFunction() {
    console.log("AsrTest Component Mounted");
    const audioUrl = "https://crbn.us/whatstheweatherlike.wav";
    const proxyUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(audioUrl)}`;

    // Download audio and transcribe
    fetch(proxyUrl)
      .then(function handleResponse(response) {
        if (response.status !== 200) throw new Error(response.status);
        return response.blob();
      })
      .then(function processAudio(blob) {
        var audioFile = new File([blob], "audio.wav", { type: blob.type });
        var params = {
          audio: audioFile,
          definition: JSON.stringify({ locales: ["en-US"] }),
        };
        // Request speech-to-text API
        speechToText(params);
      })
      .catch(function handleError(error) {
        console.error("Fail", error.message);
      });
  }, []);

  return <div>ASR Test Running...</div>;
}
</file>

<file path="src/test/TestPresenter.jsx">
import { useState } from "react";
import { DictionaryAPI } from "../api/dictionaryAPI";

function TestPresenter() {
    const [word, setWord] = useState(""); 

    function testDictionaryAPI() {
        DictionaryAPI.getWord('Test')
            .then(data => {
                setWord(data);
            })
            .catch(error => {
                console.error('Query Failed:', error);
            });
    }

    testDictionaryAPI();

    return (
        <div>
            <h1>{JSON.stringify(word)}</h1>
        </div>
    )
}

export default TestPresenter;
</file>

<file path="src/views/PodcastView/DictionaryCard.jsx">
import { useRef } from "react";

export function DictionaryCard({ wordCard, onClose, onAddToWordlist }) {
  const phoneticAudioRef = useRef(null);

  const playPhoneticAudio = (url) => {
    if (!url) return;
    if (phoneticAudioRef.current) {
      phoneticAudioRef.current.src = url;
      phoneticAudioRef.current.play();
    }
  };

  return (
    <>
      <div className="dictionary-mask" onClick={onClose} />
      <div
        className="dictionary-card"
        style={{
          top: `${wordCard.position?.top || 0}px`,
          left: `${wordCard.position?.left || 0}px`,
          zIndex: 1300,
        }}
      >
        <div className="dictionary-card-content">
          <div className="word-header">
            <h3 className="word-text">{wordCard?.word || "..."}</h3>
            <span className="word-level">
              {wordCard?.meanings?.[0]?.partOfSpeech || "N/A"}
            </span>
          </div>
          <div className="word-phonetics">
            <div className="phonetic">
              <span className="phonetic-label">Phonetic</span>
              <span className="phonetic-text">
                {wordCard?.phonetic || "N/A"}
              </span>
              {wordCard?.phonetics?.[0]?.audio && (
                <>
                  <button
                    className="phonetic-audio-btn"
                    onClick={() =>
                      playPhoneticAudio(wordCard.phonetics[0].audio)
                    }
                    title="Play pronunciation"
                  >
                    🔊
                  </button>
                  <audio ref={phoneticAudioRef} style={{ display: "none" }} />
                </>
              )}
            </div>
          </div>
          <div className="word-definition">
            {wordCard?.meanings?.map((meaning, index) => (
              <div key={index} className="meaning-section">
                <p className="part-of-speech">{meaning.partOfSpeech}</p>
                {meaning.definitions?.map((def, defIndex) => (
                  <div key={defIndex} className="definition-item">
                    <p className="definition-text">{def.definition}</p>
                    {def.example && (
                      <p className="example-text">"{def.example}"</p>
                    )}
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>
        <button className="add-to-wordlist-btn" onClick={onAddToWordlist}>
          Add to Wordlist
        </button>
      </div>
    </>
  );
}
</file>

<file path="src/views/PodcastView/PodcastInfoCard.jsx">
import {
  Box,
  Card,
  CardContent,
  CardMedia,
  Typography,
  Button,
  Tooltip,
} from "@mui/material";
import GraphicEqIcon from "@mui/icons-material/GraphicEq";

export function PodcastInfoCard({ podcastData, isTranscribing, onTranscribe }) {
  return (
    <Box
      className="left-panel"
      sx={{
        flexShrink: 0,
        width: { xs: "100%", md: 400 },
        height: "95%",
        display: "flex",
        flexDirection: "column"
      }}
    >
      <Card
        elevation={1}
        sx={{
          width: "100%",
          borderRadius: 6,
          display: "flex",
          flexDirection: "column",
          height: "100%"
        }}
      >
        <CardContent
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            flexShrink: 0,
            px: 3,
            py: 1.5
          }}
        >
          <Tooltip title={podcastData.source || "Name of Podcast"} arrow>
            <Typography
              variant="subtitle1"
              fontWeight={600}
              fontSize={20}
              lineHeight={1.3}
              sx={{
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
                maxWidth: "100%",
                cursor: "default"
              }}
            >
              {podcastData.source || "Name of Podcast"}
            </Typography>
          </Tooltip>
          <Box sx={{ flexGrow: 1 }}></Box>
        </CardContent>

        <CardMedia
          component="img"
          sx={{
            width: "100%",
            height: "auto",
            objectFit: "cover",
            maxHeight: { xs: 120, sm: 140, md: 160, lg: 220 },
            flexShrink: 1,
          }}
          image={podcastData.coverImage}
          alt="Podcast Cover"
        />

        <CardContent 
          sx={{ 
            display: "flex",
            flexDirection: "column",
            justifyContent: "space-between",  // 保证内容和按钮分开
            flexGrow: 1,
            minHeight: 0, // 避免无限撑高
            overflow: "hidden",
            p: 2
          }}
        >
          <Tooltip title={podcastData.title || "Episode Name"} arrow>
            <Typography
              variant="subtitle1"
              fontWeight={600}
              fontSize={22}
              gutterBottom
              noWrap
              sx={{
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
                cursor: "default",
                flexShrink: 0,
                maxWidth: "100%",
              }}
            >
              {podcastData.title || "Episode Name"}
            </Typography>
          </Tooltip>

          <Typography
            variant="body2"
            color="text.secondary"
            mt={1}
            className="typography-scrollable"
            sx={{
              lineHeight: 1.5,
              overflowY: "auto",
              pr: 1,
              flex: "1 1 auto",
              maxHeight: "none"
            }}
          >
            {podcastData.description || "Description..."}
          </Typography>
          <Box mt={2}>
            <Tooltip title="Only English podcasts are supported for now" arrow>
              <Button
                variant="contained"
                startIcon={<GraphicEqIcon />}
                size="small"
                onClick={onTranscribe}
                disabled={isTranscribing}
                sx={{
                  borderRadius: "100px",
                  textTransform: "none",
                  fontWeight: 600,
                  px: 2,
                  py: 0.5,
                  backgroundColor: "#006BFE",
                  color: "#fff",
                  boxShadow: 1,
                  width: "100%", // 宽度适配小屏
                  "&:hover": {
                    backgroundColor: "primary.dark",
                    boxShadow: 4
                  },
                  "&:disabled": {
                    backgroundColor: "grey.400",
                    color: "white"
                  }
                }}
              >
                {isTranscribing ? "Transcribing..." : "Transcribe"}
              </Button>
            </Tooltip>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
}
</file>

<file path="src/views/PodcastView/PodcastPlayView.jsx">
// import "../styles/PodcastPlay.css";
import { useNavigate } from "react-router-dom";
import { useState, useCallback, useRef, useEffect } from "react";
import { AUDIO_DOWNLOAD_URL } from "../../../listenary-backend/config/apiConfig.js";
import { TopNav } from "../../components/TopNav.jsx";
import AudioPlayerComponent from "../../components/AudioPlayerComponent.jsx";
import { useTranslationHandler } from "../../hooks/useTranslationHandler";
import { Box, ThemeProvider, createTheme, Typography } from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import GraphicEqIcon from "@mui/icons-material/GraphicEq";
import { PodcastInfoCard } from "./PodcastInfoCard.jsx";
import { TranscriptList } from "./TranscriptList";
import { DictionaryCard } from "./DictionaryCard";

const theme = createTheme();

export function PodcastPlayView({
  podcastData,
  onTimeUpdate,
  transcriptionData = [],
  onWordSelect,
  onTranscribe,
  isTranscribing,
  currentTime,
  wordCard,
  onAddToWordlist,
}) {
  const [showDictionary, setShowDictionary] = useState(false);
  const [dictionaryPosition, setDictionaryPosition] = useState(null);
  const [targetLanguage, setTargetLanguage] = useState("");
  const [translations, setTranslations] = useState({});
  const [translatingItems, setTranslatingItems] = useState(new Set());
  const [notification, setNotification] = useState({
    show: false,
    message: "",
    type: "info",
  });

  const rowRefs = useRef([]);
  const phoneticAudioRef = useRef(null);
  const internalAudioRef = useRef();

  useEffect(() => {
    return () => {
      if (internalAudioRef.current && internalAudioRef.current.pause) {
        internalAudioRef.current.pause();
        internalAudioRef.current.currentTime = 0;
      }
    };
  }, []);

  useEffect(
    function setupAutoScroll() {
      if (!transcriptionData.length) return;

      function findCurrentIndex() {
        return transcriptionData
          .map(function (item, i) {
            return { ...item, i };
          })
          .filter(function (item) {
            return item.offsetMilliseconds <= currentTime;
          })
          .pop()?.i;
      }

      const index = findCurrentIndex();
      if (index !== undefined && rowRefs.current[index]) {
        rowRefs.current[index].scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest",
        });
      }
    },
    [currentTime, transcriptionData]
  );

  const languages = [
    { code: "", name: "Translation Language" },
    { code: "ZH-HANS", name: "中文" },
    { code: "DE", name: "Deutsch" },
    { code: "SV", name: "Svenska" },
    { code: "FR", name: "Français" },
    { code: "NL", name: "Nederlands" },
  ];

  const { handleLanguageChange } = useTranslationHandler({
    transcriptionData,
    setTargetLanguage,
    setTranslations,
    setTranslatingItems,
  });

  const handleWordClick = (word, event) => {
    const CARD_WIDTH = 400;
    const CARD_HEIGHT = 320;
    const CARD_MARGIN = 10;
    const PLAYER_HEIGHT = 90;
    const CARD_BOTTOM_SAFE = PLAYER_HEIGHT + 48;
    const rect = event.target.getBoundingClientRect();
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let left = rect.right + CARD_MARGIN;
    if (left + CARD_WIDTH > windowWidth) {
      left = rect.left - CARD_WIDTH - CARD_MARGIN;
      if (left < 10) left = 10;
    }

    let top;
    const spaceBelow = windowHeight - rect.bottom - CARD_BOTTOM_SAFE;
    if (spaceBelow >= CARD_HEIGHT) {
      top = rect.bottom + CARD_MARGIN;
    } else {
      top = rect.top - CARD_HEIGHT - CARD_MARGIN;
      if (top < 10) top = 10;
    }

    setDictionaryPosition({ top, left });
    setShowDictionary(true);
    onWordSelect(word);
  };

  const handleAddToWordlist = useCallback(async () => {
    const result = await onAddToWordlist(wordCard);
    // Show specific notification based on login and save status
    if (result.type === "warning") {
      showNotification("Please login first to save your wordlist", "warning");
    } else if (result.type === "success") {
      showNotification("saved to the default wordlist", "success");
    } else {
      showNotification(result.message, result.type || "info");
    }
    setShowDictionary(false);
  }, [wordCard, onAddToWordlist]);

  const showNotification = (message, type = "info") => {
    setNotification({ show: true, message, type });
    setTimeout(
      () => setNotification({ show: false, message: "", type: "info" }),
      3000
    );
  };

  const playPhoneticAudio = (url) => {
    if (!url) return;
    if (phoneticAudioRef.current) {
      phoneticAudioRef.current.src = url;
      phoneticAudioRef.current.play();
    }
  };

  return (
    <ThemeProvider theme={theme}>
      <div
        className="podcast-page"
        style={{ display: "flex", flexDirection: "column", height: "100vh" }}
      >
        <TopNav />
        <Box
          sx={{
            flex: "1 1 auto",
            display: "flex",
            flexDirection: { xs: "column", md: "row" },
            maxWidth: 1400,
            mx: "auto",
            px: 1,
            pt: 0,
            pb: 0,
            gap: 2.5,
            width: "85%",
            overflow: "hidden",
            // height: "calc(100vh - 64px - 75px)",
            mt: "24px",
            mb: "90px",
          }}
        >
          {/* Left panel with podcast info */}
          <PodcastInfoCard
            podcastData={podcastData}
            isTranscribing={isTranscribing}
            onTranscribe={onTranscribe}
          />

          {/* Right panel with transcription */}
          <Box
            className="right-panel"
            sx={{
              flexGrow: 1,
              minWidth: 0,
              height: "95%",
              width: "100%",
              display: "flex",
              flexDirection: "column",
            }}
          >
            {/* Fixed header */}
            <Box
              sx={{
                display: "flex",
                width: "100%",
                justifyContent: "space-between",
                alignItems: "center",
                minWidth: "500px",
                position: "sticky",
                top: 0,
                zIndex: 1,
                px: 1,
                py: 1,
              }}
            >
              <Typography variant="h6" fontWeight="bold">
                Transcription
              </Typography>

              {/* Translation language selector, only shown when transcription exists */}
              {transcriptionData.length > 0 && (
                <Box sx={{ minWidth: 200 }}>
                  <select
                    value={targetLanguage}
                    onChange={handleLanguageChange}
                    style={{
                      width: "100%",
                      padding: "8px 12px",
                      borderRadius: "8px",
                      border: "1px solid #ccc",
                      fontSize: "14px",
                      backgroundColor: "#fff",
                      cursor: "pointer",
                      outline: "none",
                      transition: "border-color 0.2s",
                    }}
                  >
                    {languages.map(function (lang) {
                      return (
                        <option key={lang.code} value={lang.code}>
                          {lang.name}
                        </option>
                      );
                    })}
                  </select>
                </Box>
              )}
            </Box>

            {/* Scrollable transcript content */}
            <TranscriptList
              transcriptionData={transcriptionData}
              currentTime={currentTime}
              targetLanguage={targetLanguage}
              translations={translations}
              translatingItems={translatingItems}
              onWordClick={handleWordClick}
            />
            {/* Fixed bottom player area */}
            <Box
              sx={{
                position: "fixed",
                left: 0,
                bottom: 0,
                width: "100%",
                height: "aoto",
                zIndex: 1200,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <Box
                sx={{
                  width: "100%",
                  maxWidth: 1400,
                  px: 2,
                }}
              >
                <AudioPlayerComponent
                  ref={internalAudioRef}
                  audioSrc={`${AUDIO_DOWNLOAD_URL}?url=${encodeURIComponent(
                    podcastData.audioUrl
                  )}`}
                  onTimeUpdate={onTimeUpdate}
                />
              </Box>
            </Box>

            {/* Dictionary card */}
            {showDictionary && (
              <DictionaryCard
                wordCard={{ ...wordCard, position: dictionaryPosition }}
                onClose={() => setShowDictionary(false)}
                onAddToWordlist={handleAddToWordlist}
              />
            )}

            {notification.show && (
              <div className={`notification-toast ${notification.type}`}>
                {notification.message}
              </div>
            )}
          </Box>
        </Box>
      </div>
    </ThemeProvider>
  );
}
</file>

<file path="src/views/PodcastView/TranscriptList.jsx">
import { useEffect, useRef } from "react";
import { Box, Typography } from "@mui/material";
import "../../styles/PodcastPlay.css";


export function TranscriptList({
  transcriptionData,
  currentTime,
  targetLanguage,
  translations,
  translatingItems,
  onWordClick
}) {
  const rowRefs = useRef([]);

  // 自动滚动到当前时间点对应的行
  useEffect(() => {
    if (!transcriptionData.length) return;

    const index = transcriptionData
      .map((item, i) => ({ ...item, i }))
      .filter(item => item.offsetMilliseconds <= currentTime)
      .pop()?.i;

    if (index !== undefined && rowRefs.current[index]) {
      rowRefs.current[index].scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest"
      });
    }
  }, [currentTime, transcriptionData]);

  if (!transcriptionData.length) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Click "Transcribe" to get the transcription of this podcast
      </Typography>
    );
  }

  return (
    <Box className="transcript-content" sx={{ flex: "1 1 auto", overflowY: "auto", pr: 1 }}>
      <div className="transcription-container">
        {transcriptionData.map((item, index) => {
          const start = item.offsetMilliseconds;
          const end =
            index + 1 < transcriptionData.length
              ? transcriptionData[index + 1].offsetMilliseconds
              : Infinity;
          const isActive = currentTime >= start && currentTime < end;

          return (
            <div
              key={"row-" + index}
              ref={el => rowRefs.current[index] = el}
              className={"transcript-row " + (isActive ? "active-row" : "")}
            >
              <div className="timestamp-column">{item.timestamp}</div>
              <div className="content-column">
                <div className="transcription-text">
                  {item.text.split(/(\s+)/).map((part, wordIndex) => {
                    if (/\s+/.test(part)) return part;
                    return (
                      <span
                        key={"word-" + wordIndex}
                        className={"word-hover " + (isActive ? "active-word" : "")}
                        onClick={e => onWordClick(part, e)}
                      >
                        {part}
                      </span>
                    );
                  })}
                </div>
                {targetLanguage && (
                  <div className="translation-text">
                    {translatingItems.has(item.text)
                      ? "Loading..."
                      : translations[item.text]}
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </Box>
  );
}
</file>

<file path="src/views/HomePageView.jsx">
import "../styles/HomePage.css";
// import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { TopNav } from "../components/TopNav";
import TextField from "@mui/material/TextField";
import FavoriteIcon from "@mui/icons-material/Favorite";
import InputAdornment from "@mui/material/InputAdornment";
import PodcastsIcon from "@mui/icons-material/Podcasts";
import { CollapseBox } from "../components/CollapseBox";
import Snackbar from "@mui/material/Snackbar";
import {
  Grid,
  Box,
  Card,
  CardMedia,
  CardContent,
  Typography,
} from "@mui/material";

export function HomePageView({
  podcast,
  url,
  onInputChange,
  onParseClick,
  savedPodcasts,
  onSavedPodcastClick,
  errorMsg,
  snackbarOpen,
  onSnackbarClose,
}) {
  const navigate = useNavigate();

  function handleRssLinkClick(e, rssUrl) {
    e.preventDefault();
    onInputChange({ target: { value: rssUrl } });
  }

  return (
    <div className="homepage-container">
      <TopNav hideLogo />

      <div className="center-content">
        <div className="logo-container">
          <img
            src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/LOGO.svg?alt=media&token=a57cbd8b-9976-4ad4-8416-e42c08bf628f"
            alt="Listenary"
            className="logo"
          />
        </div>

        <div
          className="search-container"
          style={{ width: "600px", display: "flex" }}
        >
          <TextField
            variant="outlined"
            placeholder="Input RSS link to get podcast transcription"
            value={url}
            onChange={onInputChange}
            sx={{
              width: "486px",
              minWidth: "486px",
              maxWidth: "486px",
              "& .MuiOutlinedInput-root": {
                borderRadius: "30px",
                backgroundColor: "F5F9FF",
                paddingLeft: "16px",
              },
              "& .MuiOutlinedInput-notchedOutline": {
                borderColor: "#E0E0E0",
              },
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#C0C0C0",
              },
              "& .MuiOutlinedInput-input": {
                paddingLeft: "4px",
                fontSize: "0.9rem",
              },
              "& .MuiInputAdornment-root": {
                marginRight: "8px",
              },
              "& .MuiOutlinedInput-input::placeholder": {
                opacity: 1,
                color: "#757575",
              },
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <PodcastsIcon color="action" />
                </InputAdornment>
              ),
            }}
          />
          <button
            type="button"
            className="search-button"
            style={{
              width: "90px",
              minWidth: "90px",
              maxWidth: "90px",
              height: "52px",
              marginLeft: "8px",
            }}
            onClick={onParseClick}
          >
            Parse
          </button>
        </div>
        {errorMsg && (
          <div
            style={{
              color: "red",
              marginTop: "0px",
              marginLeft: "8px",
              fontSize: "14px",
              textAlign: "left",
              width: "100%",
              maxWidth: "600px",
            }}
          >
            {errorMsg}
          </div>
        )}

        <div className="help-link-wrapper">
          <CollapseBox title="How to use Listenary">
            <ol className="rss-guide-list">
              <li>
                Use <a
                  href="https://castos.com/tools/find-podcast-rss-feed/"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Castos RSS Finder 
                </a> to search for a podcast, copy the RSS link, and paste it into
                the Parse box.
              </li>
              <li>Click Parse, then select the episode you want. </li>
              <li>
                Or try this link now! <a href="#"
                  className="example-rss-link"
                  onClick={function(event) {
                    handleRssLinkClick(
                      event,
                      "https://feeds.captivate.fm/one-minute-podcast-tips/"
                    );
                  }}
                >
                  One Minute Podcast Tips.
                </a> Enjoy it!
              </li>
            </ol>
          </CollapseBox>
        </div>
      </div>

      <div className="saved-section">
        <div className="saved-header">
          <h2 className="saved-title">
            <FavoriteIcon className="saved-icon" />
            Saved Podcasts
          </h2>
        </div>

        {savedPodcasts && savedPodcasts.length > 0 ? (
          <Box
            display="flex"
            flexWrap="nowrap"
            gap={1}
            justifyContent="flex-start"
            sx={{
              maxWidth: "1200px",
              margin: "0 auto",
            }}
          >
            {savedPodcasts.slice(0, 4).map((podcast, index) => (
              <Card
                key={index}
                onClick={() => onSavedPodcastClick(podcast)}
                sx={{
                  width: "290px",
                  flexShrink: 0,
                  borderRadius: 3,
                  boxShadow: 1,
                  cursor: "pointer",
                  transition: "all 0.2s ease-in-out",
                  "&:hover": {
                    boxShadow: 4,
                  },
                }}
              >
                <CardMedia
                  component="img"
                  height="140"
                  image={podcast.coverImage}
                  alt={podcast.title}
                  sx={{ objectFit: "cover" }}
                />
                <CardContent>
                  <Typography variant="subtitle1" fontWeight={600} noWrap>
                    {podcast.title}
                  </Typography>
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      display: "-webkit-box",
                      WebkitLineClamp: 2,
                      WebkitBoxOrient: "vertical",
                      lineHeight: 1.4,
                      minHeight: "2.8em",
                    }}
                  >
                    {podcast.description}
                  </Typography>
                </CardContent>
              </Card>
            ))}
          </Box>
        ) : (
          <Box
            display="flex"
            flexDirection="column"
            alignItems="center"
            justifyContent="center"
            sx={{ mt: 4 }}
          >
            <img
              src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea"
              alt="No saved podcasts"
              style={{ width: "160px", marginBottom: "16px" }}
            />
            <Typography variant="body1" color="text.secondary">
              No saved podcasts yet.
            </Typography>
          </Box>
        )}

        {savedPodcasts && savedPodcasts.length > 4 && (
          <a
            href="#"
            className="show-more"
            onClick={function (e) {
              e.preventDefault();
              navigate("/saved-podcasts");
            }}
          >
            Show more
          </a>
        )}

        <Snackbar
          open={snackbarOpen}
          autoHideDuration={4000}
          onClose={onSnackbarClose}
          message={errorMsg}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/views/loginPageView.jsx">
import '../styles/LoginPage.css';
import { TopNav } from '../components/TopNav';

function LoginView({
    isLoading,
    user,
    onGoogleLogin,
    onLogout
}) {
    return (
        <div className="page-container">
            <TopNav />
            <div className="login-wrapper">
                <div className="login-content">
                <div className="logo-container">
          <img
            src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/LOGO.svg?alt=media&token=a57cbd8b-9976-4ad4-8416-e42c08bf628f"
            alt="Listenary"
            className="logo"
          />
        </div>

                    {!user ? (
                        // Login form for unauthenticated users
                        <>
                            <button 
                                id="authButton"
                                   onClick={onGoogleLogin} 
                                disabled={isLoading}
                                className="google-sign-in-button"
                            >
                                <div className="google-sign-in-content">
                                    <img 
                                        src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" 
                                        alt="Google" 
                                        className="google-icon"
                                    />
                                    <span>{isLoading ? 'Signing in...' : 'Sign in with Google'}</span>
                                </div>
                            </button>

                            <p className="terms-text">
                                By continuing, you agree to our{' '}
                                <a href="#" className="terms-link">Terms</a> and{' '}
                                <a href="#" className="terms-link">Privacy</a>
                            </p>
                        </>
                    ) : (
                        // Welcome screen for authenticated users
                        <div className="welcome-container">
                            <p className="welcome-text">Welcome, {user.displayName || user.email}</p>
                            <button 
                                onClick={onLogout}
                                className="google-sign-in-button"
                            >
                                Logout
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

export default LoginView;
</file>

<file path="src/views/PodcastChannelView.jsx">
import {
  Box,
  Typography,
  Button,
  Card,
  CardMedia,
  CardContent,
  Tooltip,
  Link,
  ToggleButton,
  ToggleButtonGroup,
  Snackbar,
  Alert
} from "@mui/material";
import { TopNav } from "../components/TopNav";
import React, { useState } from "react";
import FavoriteIcon from "@mui/icons-material/Favorite";
import CheckIcon from "@mui/icons-material/Check";

// Episode card component for displaying individual podcast episodes
function EpisodeCard({ episode, onPlay, showSnackbar }) {
  const [expanded, setExpanded] = useState(false);
  const isClamped = episode.description?.length > 180;

  function handlePlay() {
    if (!episode?.enclosure?.url) {
      showSnackbar?.("This episode has no playable audio file", "warning");
      return;
    }
    onPlay(episode);
  }

  return (
    <Card
      sx={{
        p: 2,
        width: "100%",
        borderRadius: 3,
        transition: "background-color 0.3s",
        "&:hover": {
          backgroundColor: "#f5f5f5",
        },
        maxWidth: "100%",
      }}
      elevation={1}
    >
      <Box
        sx={{
          display: "flex",
          flexDirection: { xs: "column", sm: "row" },
          justifyContent: "space-between", 
          width: "100%",
          gap: 2,
        }}
      >
        <Box sx={{ display: "flex", gap: 2, flex: 1, minWidth: 0 }}>
          <CardMedia
            component="img"
            image={
              episode.coverImage ||
              "https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Episode%20Cover.svg?alt=media&token=5e5257bc-23e1-4db9-8342-a89502538bd0"
            }
            alt={episode.title}
            sx={{ width: 100, height: 100, borderRadius: 2 }}
          />

          <CardContent sx={{ p: 0 }}>
            <Typography
              variant="h6"
              sx={{
                display: "-webkit-box",
                WebkitBoxOrient: "vertical",
                WebkitLineClamp: 2,
                overflow: "hidden",
                textOverflow: "ellipsis",
                wordBreak: "break-word",
                lineHeight: 1.4,
              }}
            >
              {episode.title}
            </Typography>

            <Typography
              variant="body2"
              color="text.secondary"
              mt={1}
              sx={{
                ...(expanded
                  ? {}
                  : {
                      display: "-webkit-box",
                      overflow: "hidden",
                      WebkitBoxOrient: "vertical",
                      WebkitLineClamp: 2,
                    }),
                overflowWrap: "break-word",
                wordBreak: "break-word",
                lineHeight: 1.4,
              }}
            >
              {episode.description}
            </Typography>

            {isClamped && (
              <Link
                component="button"
                variant="body2"
                onClick={function() {
                  setExpanded(!expanded);
                }}
                sx={{ mt: 0.5, pl: 0, textTransform: "none" }}
              >
                {expanded ? "Show less" : "Show more"}
              </Link>
            )}

            <Typography
              variant="caption"
              color="text.secondary"
              mt={1}
              display="block"
            >
              🎧 {episode.duration}
            </Typography>
          </CardContent>
        </Box>

        <Box
          sx={{
            minWidth: 100,
            flexShrink: 0,
            display: "flex",
            justifyContent: "flex-end",
            alignItems: "flex-start",
          }}
        >
        <Button
          variant="contained"
          size="small"
          onClick={handlePlay}
          color={episode.isTranscribed ? "success" : "primary"}
        >
          {episode.isTranscribed ? "Continue" : "Learn"}
        </Button>
        </Box>
      </Box>
    </Card>
  );
}

// Main podcast channel view component
export function PodcastChannelView({
  channelInfo,
  episodes,
  isSaved,
  onSavePodcast,
  onRemovePodcast,
  onPlay,
  filterType,
  onFilterChange,
  snackbarState,
  onSnackbarClose
}) {
  const [visibleCount, setVisibleCount] = useState(10);
  const [descExpanded, setDescExpanded] = useState(false);
  const [open, setOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState("success");

  function showSnackbar(message, severity = "success") {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setOpen(true);
  }

  const descClamped = channelInfo.description?.length > 180;

  function handleClose(event, reason) {
    if (reason === "clickaway") return;
    setOpen(false);
  }

  function handleSubscribe() {
    const result = isSaved ? onRemovePodcast(channelInfo) : onSavePodcast(channelInfo);
    if (result && result.type === "warning") {
      showSnackbar(result.message, result.type);
    } else {
      showSnackbar(
        isSaved ? "Podcast removed from saved list" : "Podcast saved successfully",
        "success"
      );
    }
  }

  function handleFilterChange(event, newFilterType) {
    if (newFilterType !== null) {
      onFilterChange(event, newFilterType);
    }
  }

  return (
    <Box sx={{ bgcolor: "background.default", minHeight: "100vh" }}>
      <TopNav />

      <Box sx={{ maxWidth: 1200, mx: "auto", px: 4, pt: 4 }}>
        {/* Channel info card */}
        <Box
          display="flex"
          gap={5}
          flexWrap="wrap"
          alignItems="flex-start"
          width="100%"
        >
          <Card sx={{ width: 200, height: 200, borderRadius: 4, boxShadow: 3 }}>
            <CardMedia
              component="img"
              image={channelInfo.coverImage}
              alt={channelInfo.title}
              sx={{ width: "100%", height: "100%", objectFit: "cover" }}
            />
          </Card>

          <Box
            flex={1}
            display="flex"
            flexDirection="column"
            gap={2}
            justifyContent="flex-start"
            maxWidth={{ xs: "100%", md: "calc(100% - 240px)" }}
          >
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              width="100%"
            >
              <Typography variant="h4" fontWeight={700} color="text.primary">
                {channelInfo.title}
              </Typography>
              <Box ml={2}>
                <Button
                  variant="contained"
                  size="small"
                  color={isSaved ? "success" : "primary"}
                  onClick={handleSubscribe}
                  startIcon={<FavoriteIcon />}
                  sx={{ borderRadius: 2 }}
                >
                  {isSaved ? "Saved" : "Save"}
                </Button>
              </Box>
            </Box>
            <Typography
              variant="body1"
              color="text.secondary"
              sx={
                descExpanded
                  ? {}
                  : {
                      display: "-webkit-box",
                      overflow: "hidden",
                      WebkitBoxOrient: "vertical",
                      WebkitLineClamp: 3,
                    }
              }
            >
              <span
                dangerouslySetInnerHTML={{ __html: channelInfo.description }}
              />
            </Typography>
            {descClamped && (
              <Link
                component="button"
                variant="body2"
                onClick={function() {
                  setDescExpanded(!descExpanded);
                }}
                sx={{ textTransform: "none", alignSelf: "flex-start" }}
              >
                {descExpanded ? "Show less" : "Show more"}
              </Link>
            )}
          </Box>
        </Box>

        {/* Episode list */}
        <Box mt={6}>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
            mb={3}
          >
            <ToggleButtonGroup
              value={filterType}
              exclusive
              onChange={handleFilterChange}
              aria-label="Episode Filter"
              size="small"
            >
              <ToggleButton value="all" aria-label="All">
                All Episodes
              </ToggleButton>
              <ToggleButton value="untranscribed" aria-label="Untranscribed">
                New Episodes
              </ToggleButton>
              <ToggleButton value="transcribed" aria-label="Transcribed">
                Learned Episodes
              </ToggleButton>
            </ToggleButtonGroup>
          </Box>

          <Box display="flex" flexDirection="column" gap={2}>
            {episodes.slice(0, visibleCount).map((episode, index) => (
              <EpisodeCard key={episode.guid || index} episode={episode} onPlay={onPlay} showSnackbar={showSnackbar} />
            ))}
          </Box>
        </Box>
      </Box>

      {/* Snackbar notification */}
      <Snackbar 
        open={open}
        autoHideDuration={3000}
        onClose={handleClose}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={handleClose}
          severity={snackbarSeverity}
          sx={{ width: "100%" }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
}
</file>

<file path="src/views/SavedPodcastsView.jsx">
import "../styles/HomePage.css";
import { useNavigate } from "react-router-dom";
import { TopNav } from "../components/TopNav";
import {
  Grid,
  Box,
  Card,
  CardMedia,
  CardContent,
  Typography
} from "@mui/material";

/**
 * View component for displaying saved podcasts
 * @param {Object} props - Component props
 * @param {Array} props.savedPodcasts - Array of saved podcast objects
 */
function SavedPodcastsView(props) {
  const savedPodcasts = props.savedPodcasts;
  const navigate = useNavigate();

  function handleViewPodcast(podcast) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.rssUrl } });
  }

  return (
    <div className="homepage-container">
      <TopNav />
<div className="saved-section">
  <div className="saved-header">
    <h2 className="saved-title">
      <img src="/saved-icon.png" alt="" className="saved-icon" />
      All Saved Podcasts
    </h2>
  </div>

  {savedPodcasts && savedPodcasts.length > 0 ? (
    <div className="saved-grid">
      {savedPodcasts.map(function (podcast, index) {
        return (
          <div
            key={index}
            className="saved-item"
            onClick={function () {
              handleViewPodcast(podcast);
            }}
          >
            <div className="saved-item-image-wrapper">
              <img
                src={podcast.coverImage}
                alt={podcast.title}
                className="saved-item-image"
              />
            </div>
            <h3 className="saved-item-title">{podcast.title}</h3>
            <p className="saved-item-description">{podcast.description}</p>
          </div>
        );
      })}
      </div>
      ) : (
        <Box
          width="100%"
          display="flex"
          justifyContent="center"
          alignItems="center"
          sx={{ mt: 4 }}
        >
          <Box
            display="flex"
            flexDirection="column"
            alignItems="center"
          >
            <img
              src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea"
              alt="No saved podcasts"
              style={{ width: "160px", marginBottom: "16px" }}
            />
            <Typography variant="body1" color="text.secondary">
              No saved podcasts yet.
            </Typography>
          </Box>
        </Box>
      )}
    </div>
  </div>
  );
}

export { SavedPodcastsView };
</file>

<file path="src/views/suspenseView.jsx">
export function SuspenseView(props) {
  if (!props.promise) {
    return <span>no data</span>;
  }
  if (props.error) {
    return <span>{props.error.toString()}</span>;
  } else return <img src="https://brfenergi.se/iprog/loading.gif" />;
}
</file>

<file path="src/views/WordlistView.jsx">
import '../styles/Wordlist.css';
import { TopNav } from '../components/TopNav';

/**
 * WordlistView Component - Part of the View layer in MVP
 * Displays the user's wordlist and selected word details
 */
export function WordlistView({ 
  words, 
  selectedWordIndex, 
  selectedWord, 
  onWordSelect,
  isLoading,
  error,
  isLoggedIn
}) {
  return (
    <div className="page-container">
      <TopNav />
      <div className="wordlist-container">
        {/* Left sidebar - Word list */}
        <div className="wordlist-sidebar">
          <h2 className="sidebar-title">My Wordlist</h2>

          {!isLoggedIn && (
            <div className="login-prompt">
              <p>Please log in to view your saved words.</p>
            </div>
          )}

          {isLoggedIn && isLoading && (
            <div className="loading-state">
              <p>Loading your wordlist...</p>
            </div>
          )}

          {isLoggedIn && error && (
            <div className="error-state">
              <p>{error}</p>
            </div>
          )}

          {isLoggedIn && !isLoading && !error && words.length === 0 && (
            <div className="empty-state">
              <p>You haven't saved any words yet.</p>
              <p>Look up words in podcast transcripts and add them to your wordlist.</p>
            </div>
          )}

          {isLoggedIn && !isLoading && words.length > 0 && (
            <div className="wordlist-list">
              {words.map((word, index) => (
                <div
                  key={index}
                  className={`wordlist-item ${selectedWordIndex === index ? 'selected' : ''}`}
                  onClick={() => onWordSelect(index)}
                >
                  <span className="wordlist-name">{word.word}</span>
                  <span className="wordlist-count">
                    {word.meanings && word.meanings.length > 0 ? word.meanings[0].partOfSpeech : ''}
                  </span>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Right content - Word details */}
        <div className="wordlist-content">
          {selectedWord ? (
            <div className="word-details">
              <h2 className="content-title">{selectedWord.word}</h2>
              
              {/* Phonetics section - Simplified to show only one phonetic */}
              {selectedWord.phonetics && selectedWord.phonetics.length > 0 && (
                <div className="phonetics-section">
                  {(() => {
                    // Find the first phonetic with audio, or just use the first one
                    const phoneticWithAudio = selectedWord.phonetics.find(p => p.audio) || selectedWord.phonetics[0];
                    
                    return (
                      <div className="phonetic-item">
                        <span className="phonetic-text">
                          {phoneticWithAudio.text || selectedWord.phonetic || ''}
                        </span>
                        {phoneticWithAudio.audio && (
                          <button 
                            className="phonetic-audio-btn"
                            onClick={() => {
                              const audio = new Audio(phoneticWithAudio.audio);
                              audio.play();
                            }}
                          >
                            🔊 Play
                          </button>
                        )}
                      </div>
                    );
                  })()}
                </div>
              )}
              
              {/* Meanings section */}
              {selectedWord.meanings && selectedWord.meanings.map((meaning, meaningIndex) => (
                <div key={meaningIndex} className="meaning-section">
                  <h3 className="part-of-speech">{meaning.partOfSpeech}</h3>
                  
                  {meaning.definitions && meaning.definitions.map((def, defIndex) => (
                    <div key={defIndex} className="definition-item">
                      <p className="definition-text">{def.definition}</p>
                      {def.example && (
                        <p className="example-text">Example: "{def.example}"</p>
                      )}
                    </div>
                  ))}
                  
                  {/* Synonyms */}
                  {meaning.synonyms && meaning.synonyms.length > 0 && (
                    <div className="word-synonyms">
                      <h4>Synonyms:</h4>
                      <div className="synonyms-list">
                        {meaning.synonyms.map((synonym, synIndex) => (
                          <span key={synIndex} className="synonym-tag">{synonym}</span>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Antonyms */}
                  {meaning.antonyms && meaning.antonyms.length > 0 && (
                    <div className="word-antonyms">
                      <h4>Antonyms:</h4>
                      <div className="antonyms-list">
                        {meaning.antonyms.map((antonym, antIndex) => (
                          <span key={antIndex} className="antonym-tag">{antonym}</span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="no-selection">
              <p>Select a word from your wordlist to view details.</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/firestoreModel.js">
// initialize Firebase app
import { initializeApp } from "firebase/app";
import { firebaseConfig } from "../listenary-backend/config/firebaseConfig.js";
import {
  getFirestore,
  doc,
  setDoc,
  getDoc,
  arrayUnion,
  updateDoc,
} from "firebase/firestore";
import loginModel from "./loginModel";
import { model } from "./Model";

export const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);

// make doc and setDoc available at the Console for testing
window.doc = doc;
window.setDoc = setDoc;
window.db = db;

export function saveUserData(uid, data) {
  const userDoc = doc(db, "users", uid);
  return setDoc(userDoc, data, { merge: true });
}

export function loadUserData(uid) {
  const userDoc = doc(db, "users", uid);
  return getDoc(userDoc).then(function (docSnap) {
    if (docSnap.exists()) {
      return docSnap.data();
    } else {
      return null;
    }
  });
}

export async function getUserWordlist(uid) {
  try {
    const userDoc = doc(db, "users", uid);
    const docSnap = await getDoc(userDoc);

    if (docSnap.exists() && docSnap.data().wordlist) {
      return docSnap.data().wordlist;
    } else {
      return [];
    }
  } catch (error) {
    console.error("Error getting user wordlist:", error);
    return [];
  }
}

export async function saveWordToUserWordlist(uid, wordData) {
  try {
    const userDoc = doc(db, "users", uid);

    // First check if user document exists
    const docSnap = await getDoc(userDoc);

    if (docSnap.exists()) {
      // User exists, update wordlist
      await updateDoc(userDoc, {
        wordlist: arrayUnion(wordData),
      });
    } else {
      // Create new user document with wordlist
      await setDoc(userDoc, {
        username: loginModel.user?.displayName || "User",
        wordlist: [wordData],
      });
    }
    return true;
  } catch (error) {
    console.error("Error saving word to wordlist:", error);
    return false;
  }
}

export function connectToPersistence(model) {
  // You can call saveUserData/loadUserData here if you want auto sync
}
// save transcription data to firestore
export async function saveTranscriptionData(uid, guid, title, phrases) {
  const docRef = doc(db, "users", uid, "transcriptions", guid);
  try {
    await setDoc(docRef, {
      title: title,
      phrases: phrases,
      updatedAt: new Date(),
    });
    console.log(`Transcription saved for episode ${title}`);
  } catch (err) {
    console.error(err);
  }
}

export async function getTranscriptionData(uid, guid) {
  const docRef = doc(db, "users", uid, "transcriptions", guid);
  try {
    const snap = await getDoc(docRef);
    if (snap.exists()) {
      return snap.data().phrases || [];
    } else {
      return [];
    }
  } catch (err) {
    console.error(err);
    return [];
  }
}

// Save podcast channel info to localStorage
export function savePodcastChannelInfo(channelInfo) {
  localStorage.setItem("podcastChannelInfo", JSON.stringify(channelInfo));
}

// Load podcast channel info from localStorage
export function loadPodcastChannelInfo() {
  const savedInfo = localStorage.getItem("podcastChannelInfo");
  return savedInfo ? JSON.parse(savedInfo) : null;
}

// Save podcast episodes to localStorage
export function savePodcastEpisodes(episodes) {
  localStorage.setItem("podcastEpisodes", JSON.stringify(episodes));
}

// Load podcast episodes from localStorage
export function loadPodcastEpisodes() {
  const savedEpisodes = localStorage.getItem("podcastEpisodes");
  return savedEpisodes ? JSON.parse(savedEpisodes) : [];
}

// Save RSS URL to localStorage
export function saveRssUrl(url) {
  localStorage.setItem("rssUrl", url);
}

// Load RSS URL from localStorage
export function loadRssUrl() {
  return localStorage.getItem("rssUrl") || "";
}

// Save audio URL to localStorage
export function saveAudioUrl(url) {
  localStorage.setItem("audioUrl", url);
}

// Load audio URL from localStorage
export function loadAudioUrl() {
  return localStorage.getItem("audioUrl") || "";
}
</file>

<file path="src/index.jsx">
import { observable, runInAction } from "mobx";
import React, { useState } from "react";
import { createRoot } from "react-dom/client";
import { ReactRoot } from "./ReactRoot";
import { model } from "./Model";
import { AsrTest } from "./test/asrTest";
import "./styles/LoginPage.css";
import { db, connectToPersistence } from "./firestoreModel";
import loginModel from "./loginModel";
import { loadUserData } from "./firestoreModel";
// 新增：引入 MUI 
import { ThemeProvider, CssBaseline } from "@mui/material";
import theme from "./styles/theme.js"; 

const myModel = observable(model);
connectToPersistence();

// Global auth state listener: sync login state and savedPodcasts
loginModel.setupAuthStateListener(function(user) {
  if (user) {
    // User just logged in or refreshed
    loadUserData(user.uid)
      .then(function(userData) {
        if (userData && userData.savedPodcasts) {
          runInAction(function() {
            myModel.savedPodcasts.replace(userData.savedPodcasts);
          });
        }
      });
  } else {
    // User logged out
    runInAction(function() {
      myModel.savedPodcasts.replace([]);
    });
  }
});

// 包裹 ThemeProvider 和 CssBaseline
createRoot(document.getElementById("root")).render(
  <ThemeProvider theme={theme}>
    <CssBaseline />
    <ReactRoot model={myModel} />
  </ThemeProvider>
);

window.myModel = myModel;

import { doc, setDoc } from "firebase/firestore";
const firestoreDoc = doc(db, "test collection", "test document");
setDoc(firestoreDoc, { dummyField: "dummyValue" }, { merge: true }).catch(
  console.error
);
</file>

<file path="src/loginModel.js">
import {
  getAuth,
  GoogleAuthProvider,
  signInWithPopup,
  onAuthStateChanged,
  signOut,
} from "firebase/auth";
import { app } from "./firestoreModel.js";
import { makeAutoObservable, runInAction } from "mobx";

// Pure data model for login
class LoginModel {
  constructor() {
    // Initialize Firebase Auth
    this.auth = getAuth(app);
    this.googleProvider = new GoogleAuthProvider();
    this.isLoading = false;
    this.user = null;
    this.viewUpdateCallbacks = [];
    makeAutoObservable(this);

    // Set up initial auth state
    const self = this;
    onAuthStateChanged(this.auth, function(user) {
      runInAction(function() {
        self.user = user;
      });
    });
  }

  getIsLoading() {
    return this.isLoading;
  }
  getUser() {
    return this.user;
  }

  // Firebase auth state monitoring
  setupAuthStateListener(callback) {
    if (callback) {
      this.viewUpdateCallbacks.push(callback);
    }
    const self = this;
    return onAuthStateChanged(this.auth, function(user) {
      runInAction(function() {
        self.user = user;
      });
      if (callback) callback(user);
    });
  }

  notifyViewUpdate() {
    const self = this;
    this.viewUpdateCallbacks.forEach(function(callback) {
      callback();
    });
  }

  // Authentication methods
  googleLogin() {
    const self = this;
    return new Promise(function(resolve, reject) {
      runInAction(function() {
        self.isLoading = true;
      });

      if (self.auth.currentUser) {
        signOut(self.auth)
          .then(function() {
            runInAction(function() {
              self.user = null;
              self.isLoading = false;
            });
            resolve({ success: true });
          })
          .catch(function(error) {
            runInAction(function() {
              self.isLoading = false;
            });
            reject({ success: false, error: error.message });
          });
      } else {
        signInWithPopup(self.auth, self.googleProvider)
          .then(function(result) {
            runInAction(function() {
              self.user = result.user;
              self.isLoading = false;
            });
            resolve(result);
          })
          .catch(function(error) {
            runInAction(function() {
              self.isLoading = false;
            });
            reject({ success: false, error: error.message });
          });
      }
    });
  }

  logout() {
    const self = this;
    return signOut(self.auth)
      .then(function() {
        runInAction(function() {
          self.user = null;
        });
        return { success: true };
      })
      .catch(function(error) {
        return { success: false, error: error.message };
      });
  }

  setUser(user) {
    const self = this;
    runInAction(function() {
      self.user = user;
    });
  }
}
// Create and export a singleton instance
const loginModel = new LoginModel();
export default loginModel;
</file>

<file path="src/Model.js">
import { resolvePromise } from "./resolvePromise.js";
import { speechToText } from "./speechToText.js";
import { PARSE_RSS_FEED_URL } from "../listenary-backend/config/apiConfig.js";
import { RssModel } from "./rssModel.js";
import { DictionaryAPI } from "./api/DictionaryAPI";
import {
  saveUserData,
  savePodcastChannelInfo,
  loadPodcastChannelInfo,
  savePodcastEpisodes,
  loadPodcastEpisodes,
  saveRssUrl,
  loadRssUrl,
  saveAudioUrl,
  loadAudioUrl,
} from "./firestoreModel";
import loginModel from "./loginModel";
import { observable, runInAction } from "mobx";

export const model = {
  // RSS related states
  rssUrl: loadRssUrl(),
  // Podcast channel information
  podcastChannelInfo: loadPodcastChannelInfo(),
  podcastEpisodes: loadPodcastEpisodes(),
  podcastLoadError: null,
  errorMsg: "", // Error message state

  rssModel: new RssModel(), // RssModel instance
  // Saved podcasts
  savedPodcasts: observable([]),

  //podcast player states
  audioUrl: loadAudioUrl(),
  // Single episode information
  currentEpisode: null,
  audioFile: null, // Store audio file
  transcripResults: [],
  transcripResultsPromiseState: {},

  // Dictionary lookup state
  dictionaryResult: null,
  dictionaryLookupPromiseState: {},

  setResults(results) {
    this.transcripResults.replace(results);
  },

  setAudioUrl(url) {
    this.audioUrl = url;
    saveAudioUrl(url);
  },

  setAudioFile(file) {
    this.audioFile = file;
  },

  setAudioDuration(duration) {
    this.audioDuration = duration;
  },

  setRssUrl(url) {
    this.rssUrl = url;
    saveRssUrl(url);
  },

  setCurrentEpisode(episode) {
    this.currentEpisode = episode;
  },

  async loadRssData() {
    this.podcastLoadError = null;
    this.podcastChannelInfo = null;
    this.podcastEpisodes = [];

    try {
      const { feed, items } = await this.rssModel.loadFeed(this.rssUrl);
      this.podcastChannelInfo = {
        title: feed.title,
        description: feed.description,
        coverImage: feed.image,
        rssUrl: this.rssUrl,
      };
      savePodcastChannelInfo(this.podcastChannelInfo);

      this.podcastEpisodes = items;
      savePodcastEpisodes(this.podcastEpisodes);
    } catch (err) {
      console.error("RSS fetch failed", err);
      this.podcastLoadError = err.message;
      throw err;
    }
  },

  // Store ASR API result in transcription result promise state
  getTranscription(params) {
    resolvePromise(speechToText(params), transcripResultsPromiseState);
  },

  // Save selected podcast
  addToSaved(podcastToAdd) {
    function isPodcastAlreadySaved(savedPodcast) {
      return savedPodcast.title === podcastToAdd.title;
    }

    if (!this.savedPodcasts.find(isPodcastAlreadySaved)) {
      if (!podcastToAdd.rssUrl) {
        podcastToAdd.rssUrl = this.rssUrl;
      }

      runInAction(() => {
        this.savedPodcasts.push(podcastToAdd);
      });
      console.log("Added to savedPodcasts: " + podcastToAdd.title);
      this.persistUserData();
    }
  },

  // Unsave selected podcast
  removeFromSaved(podcastToRemove) {
    function shouldWeKeepPodcastCB(podcast) {
      return podcast.title !== podcastToRemove.title;
    }
    runInAction(() => {
      this.savedPodcasts = this.savedPodcasts.filter(shouldWeKeepPodcastCB);
    });
    console.log("Removed from savedPodcasts: " + podcastToRemove.title);
    this.persistUserData();
  },

  /**
   * Persist user data to Firestore (username, savedPodcasts)
   */
  persistUserData() {
    const user = loginModel.getUser();
    if (user) {
      saveUserData(user.uid, {
        username: user.displayName,
        savedPodcasts: this.savedPodcasts.slice(),
      });
    }
  },

  // Dictionary lookup method
  async lookupWord(word) {
    try {
      const result = await DictionaryAPI.getWord(word);
      this.dictionaryResult = result;
      return result;
    } catch (error) {
      console.error("Dictionary lookup failed:", error);
      this.dictionaryResult = null;
      return null;
    }
  },

  // Set error message
  setErrorMsg(message) {
    this.errorMsg = message;
  },
};
</file>

<file path="src/ReactRoot.jsx">
import { observer } from "mobx-react-lite";
import { createHashRouter, RouterProvider } from "react-router-dom";
import { HomePagePresenter } from "./presenter/HomePagePresenter";
// import { Transcription } from "./presenter/TranscrptionPresenter";
import { WordlistPresenter } from "./presenter/WordlistPresenter";
import PodcastChannelPresenter from "./presenter/PodcastChannelPresenter";
import PodcastPlayPresenter from "./presenter/PodcastPlayPresenter";
import LoginPresenter from "./presenter/loginPagePresenter.jsx";
import { RssPresenter } from "./presenter/rssPresenter";
import TestPresenter from "./test/TestPresenter";
import SavedPodcastsPresenter from "./presenter/SavedPodcastsPresenter";

const ReactRoot = observer(function ReactRoot(props) {
  return (
    <RouterProvider router={makeRouter(props.model)} />
    /*RouterProvider comes from react-router-dom*/
  );
});

export { ReactRoot };

export function makeRouter(ReactiveModel) {
  return createHashRouter([
    {
      path: "/",
      element: <HomePagePresenter model={ReactiveModel} />,
    },
    {
      path: "/wordlist",
      element: <WordlistPresenter model={ReactiveModel} />,
    },
    // {
    //   path: "/Transcription",
    //   element: <Transcription model={ReactiveModel} />,
    // },
    {
      path: "/login",
      element: <LoginPresenter model={ReactiveModel} />,
    },
    {
      path: "/podcast-channel",
      element: <PodcastChannelPresenter model={ReactiveModel} />,
    },
    {
      path: "/podcast-play",
      element: <PodcastPlayPresenter model={ReactiveModel} />,
    },
    {
      path: "/rss-test",
      element: <RssPresenter />,
    },
    {
      path: "/test",
      element: <TestPresenter />,
    },
    {
      path: "/saved-podcasts",
      element: <SavedPodcastsPresenter model={ReactiveModel} />,
    },
  ]);
}
</file>

<file path="src/resolvePromise.js">
//TW2.2.1:

export function resolvePromise(prms, promiseState){
  promiseState.promise = prms; //record prms
  promiseState.data = null; // clear the previous data
  promiseState.error = null; // clear the previous error

  if (!prms) return; // in case of empty promise

  function successACB(result){
    if(promiseState.promise === prms)
      promiseState.data = result;
  }
  function failureACB(result){
    if(promiseState.promise === prms)
      promiseState.error = result;
  }

  prms.then(successACB).catch(failureACB);
  
}
</file>

<file path="src/rssModel.js">
import { PARSE_RSS_FEED_URL } from "../listenary-backend/config/apiConfig.js";
// Change to frontend RSS processing
import Parser from "rss-parser";

// function formatDuration(duration) {
//   if (!duration) return "Unknown";

//   if (typeof duration === "number") {
//     const m = Math.floor(duration / 60);
//     const s = duration % 60;
//     return `${m}:${s.toString().padStart(2, "0")}`;
//   }

//   if (typeof duration === "string") {
//     if (/^\d+$/.test(duration)) {
//       // Pure number of seconds
//       return formatDuration(Number(duration));
//     }
//     if (
//       /^\d{1,2}:\d{2}$/.test(duration) ||
//       /^\d{1,2}:\d{2}:\d{2}$/.test(duration)
//     ) {
//       // Already in standard format
//       return duration;
//     }
//   }

//   return "Unknown";
// }

export class RssModel {
  constructor() {
    this.feed = null;
    this.items = [];
    this.subscribers = [];
    // this.parser = new Parser({
    //   customFields: {
    //     feed: ["image", "language", "copyright"],
    //     item: [
    //       "itunes:duration",
    //       "itunes:image",
    //       "itunes:episode",
    //       "itunes:season",
    //       "itunes:summary",
    //       "enclosure",
    //     ],
    //   },
    // });
  }

  async loadFeed(url) {
    try {
      // Use fetch to get RSS data
      // const response = await fetch(url);
      // Call Firebase Function
      const response = await fetch(
        `${PARSE_RSS_FEED_URL}?url=${encodeURIComponent(url)}`
        // Add header that allows CORS [debug]
      );
      if (!response.ok) {
        throw new Error(`Failed to fetch RSS feed: ${response.status}`);
      }
      const data = await response.json();

      this.feed = data.feed;
      this.items = data.items;

      // this.feed = {
      //   title: data.title,
      //   description: data.description,
      //   image: data.image,
      //   link: data.link,
      // };

      // this.items = data.items.map(function(item) {
      //   return {
      //     title: item.title,
      //     description: item.contentSnippet || item.description,
      //     pubDate: item.pubDate || item.isoDate,
      //     // duration: item.itunes?.duration, // Duration cannot be displayed
      //     duration: formatDuration(item.itunes?.duration),
      //     episode: item.itunes?.episode,
      //     season: item.itunes?.season,
      //     image: item.itunes?.image || data.image,
      //     guid: item.guid,
      //     link: item.link,
      //     enclosure: item.enclosure,
      //   };
      // });

      this.notifySubscribers();

      return { feed: this.feed, items: this.items };
    } catch (error) {
      console.error("Error loading RSS feed:", error);
      throw error;
    }
  }

  getFeedInfo() {
    return this.feed;
  }

  getEpisodes() {
    return this.items;
  }

  subscribe(callback) {
    this.subscribers.push(callback);
    return function () {
      this.subscribers = this.subscribers.filter(function (cb) {
        return cb !== callback;
      });
    };
  }

  notifySubscribers() {
    this.subscribers.forEach(function (callback) {
      callback(this);
    });
  }
}
</file>

<file path="src/speechToText.js">
// import { model } from "./Model.js";
import { model } from "./Model.js";
import {
  AZURE_API_URL,
  AZURE_API_KEY,
  PROXY_URL,
} from "../listenary-backend/config/apiConfig.js";

// export function speechToText(params) {
// Rewrite original method: Replace FormData with JSON request body, use audio URL
export function speechToText(params) {
  const { audio, definition } = params;
  // Create FormData object to store audio file and definition parameters
  const formData = new FormData();
  if (params.audio) {
    formData.append("audio", audio); // Appends "audio" as a new parameter.
  }
  if (params.definition) {
    formData.append("definition", definition); // Appends "definition" as a new parameter.
  } // Send request
  return fetch(
    `${PROXY_URL}?url=${encodeURIComponent(
      AZURE_API_URL +
        "/speechtotext/transcriptions:transcribe?api-version=2024-11-15"
    )}`, // New URL
    {
      method: "POST",
      body: formData,
    }
  )
    .then(gotResponseACB) // Convert response data to JSON
    .catch(function (error) {
      console.error("Fail to upload or transcribe", error.message);
    });

  function gotResponseACB(response) {
    // Change 7: Check status, provide more user-friendly error messages
    if (!response.ok)
      throw new Error(`Transcription API failed: ${response.status}`);
    return response.json();
  }
}
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "dh2642-29c50"
  }
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Firebase local runtime & logs
functions/.runtimeconfig.json
firebase-debug.log
</file>

<file path="firebase.json">
{
  "hosting": {
    "public": "dist",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "/deepl/**",
        "function": "translate"
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "runtime": "nodejs20"
    },
    {
      "source": "listenary-backend",
      "codebase": "listenary-backend",
      "runtime": "nodejs20",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    }
  ]
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" href="/asset/SingleLOGO.svg" type="image/svg+xml">
    <title>Listenary - Turn every podcast into knowledge.</title>
    <meta charset="UTF-8" />
     <!-- 引入 Google Fonts 的 Candal 字体 -->
     <link href="https://fonts.googleapis.com/css2?family=Candal&display=swap" rel="stylesheet">
    </head>
  <body>
    <div id="root"></div> <!--*entry page for the app; provide the root element*-->
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "jigao-liyuans-ruopeng-yuezhe-vt25-project",
  "version": "1.0.0",
  "private": true,
  "description": "Listenary is an English language learning platform for English learners, where you can listen to podcasts, transcribe them, translate them, and build your wordlist.",
  "repository": {
    "type": "git",
    "url": "https://gits-15.sys.kth.se/iprog-students/jigao-liyuans-ruopeng-yuezhe-vt25-Project.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@emotion/react": "^11.9.3",
    "@emotion/styled": "^11.9.3",
    "@material/web": "^2.3.0",
    "@mui/icons-material": "^7.1.0",
    "@mui/material": "^7.1.0",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "dotenv": "^17.2.2",
    "express": "^5.1.0",
    "firebase": "^11.6.0",
    "mobx": "^6.13.5",
    "mobx-react-lite": "^4.0.7",
    "mongoose": "^8.18.2",
    "newskit": "^7.7.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-h5-audio-player": "^3.10.0-rc.1",
    "react-router-dom": "^6.22.1",
    "react-toastify": "^11.0.5",
    "rss-parser": "^3.13.0",
    "wavesurfer.js": "^7.9.5",
    "web-vitals": "^2.1.4"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.4",
    "vite": "^6.2.6",
    "vitest": "^3.1.1"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "main": "vite.config.js"
}
</file>

<file path="README.md">
# Listenary – Podcast-Based Language Learning Platform

Listenary is an English language learning platform for English learners, where you can listen to podcasts, transcribe them, translate them, and build your wordlist.

You only need 3 simple steps to start your learning journey:

**Step 1**: Open the third-party tool Castos RSS Finder, search the podcast title you want to learn, and copy paste the rss link of the podcast into the Parse box above.

**Step 2**: Click on Parse, then on the podcast channel page click on the episode you want to learn.

**Step 3**: On the episode page, click on Transcibe to see the transcription result in English. You can also click Translate to get translation in your own language.

## Features

1. Load and parse podcast episodes from any public RSS feed

2. Display podcast metadata (title, publish date, description, episodes)

3. Integrated audio streaming and waveform visualization

4. Time-aligned transcription results of the podcast alongside the audio for easy navigation

5. One-click full podcast translation and vocabulary look-up
   
6. Personal vocabulary list management

## Tech Stack

1. **Frontend Framework**: React
2. **State Management**: MobX
3. **Speech to Text**: Microsoft Azure Speech-to-Text API
4. **Translation**: DeepL API
5. **Dictionary**: Dictionary API (https://dictionaryapi.dev/)
6. **Authentication**: Google OAuth 2.0 API
7. **RSS Parsing**: rss-parser (Node.js library)
8. **Languages**: JavaScript / CSS / HTML
9. **Build Tool**: Vite

## Running deployed application

https://dh2642-29c50.web.app

## Setup and Running Instructions locally

### Install Dependences

```bash
npm install
```

### Start the development server:

```bash
npm run dev
```

## Used Third-party components

1. [Audio Waveform Player](https://wavesurfer.xyz/): We use this open-source audio visualization library to build an audio player that visually represents the playing progress. With this third-party component, users can efficiently locate the sentence they are listening to, click on the waveform, and seamlessly synchronize the audio with the transcription.

2. [Material UI](https://m3.material.io/develop/web): We use this popular React component library to build modern and responsive user interfaces. With this third-party component, users can enjoy a consistent and intuitive design while interacting with various features, enhancing the overall user experience.

## Sample RSS Feeds

Feel free to use the following sample links to test podcast loading and transcription:

- https://feeds.captivate.fm/one-minute-podcast-tips/
- https://feed.podcastmachine.com/podcasts/1288/mp3.rss
- http://img.webmd.com/video_itunes/feed.xml
- https://feeds.buzzsprout.com/2295449.rss

You can also get rss links by searching podcast name from this website: https://castos.com/tools/find-podcast-rss-feed/

### Due to limitation of API usage, we recommend you to choose podcast episodes that are no longer than 30 minutes.
</file>

<file path="vite.config.js">
import { defineConfig } from "vite";
import reactJsxPlugin from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [reactJsxPlugin()],
  server: { 
    port: 8080,
    proxy:{
      '/deepl': {
        target: 'https://api-free.deepl.com',
        changeOrigin: true, //*makes the proxy set the request's Origin and Host headers *
        // *to match the target server, so it looks like the request is coming from the same origin.*
        rewrite: (path) => path.replace(/^\/deepl/, ''),
        configure: (proxy, options) => {
          proxy.on('error', (err, req, res) => {
            console.error('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq, req, res) => {
            console.log('Proxying:', req.method, req.url);
          });
        }
      }
    }
   },
  build: { sourcemap: true, minify: false, rollupOptions: {
    output: {
      manualChunks: {
        vendor: ['react', 'react-dom']
      }
    }
  } },
});
</file>

</files>
