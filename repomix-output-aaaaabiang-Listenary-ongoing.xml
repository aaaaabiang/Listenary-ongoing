This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebase/
  hosting.ZGlzdA.cache
asset/
  Episode-Cover.svg
  LOGO.svg
  Podcast.svg
  SingleLOGO.svg
functions/
  src/
    index.ts
  package.json
  tsconfig.json
listenary-backend/
  backups/
    backup-2025-10-17T21-35-28.json
  config/
    firebaseConfig.ts
  src/
    config/
      firebaseAdmin.ts
    middleware/
      authMiddleware.ts
      errorMiddleware.ts
      firebaseAdmin.ts
      validationMiddleware.ts
    modules/
      dictionary/
        dictionaryController.ts
      podcast-discovery/
        podcastController.ts
        podcastService.ts
      rss/
        controller.ts
        model.ts
        service.ts
      transcription/
        controller/
          transcriptController.ts
          transcriptionWebSocket.ts
        service/
          transcriptionStreamService.ts
          transcriptService.ts
        transcriptModel.ts
      translation/
        translateRoutes.ts
      user&wordlist/
        controllers/
          authController.ts
          userController.ts
        models/
          User.ts
        services/
          authService.ts
          userService.ts
    types/
      express/
        index.d.ts
    server.ts
  .dockerignore
  docker-compose.yml
  Dockerfile
  package.json
  tsconfig.json
src/
  api/
    dictionaryAPI.tsx
    transcriptionAPI.tsx
    TranslationAPI.tsx
    userAPI.tsx
  components/
    AudioPlayerComponent.tsx
    CollapseBox.tsx
    DiscoveryCard.tsx
    RecommendationRow.tsx
    TopNav.tsx
  config/
    apiConfig.ts
  hooks/
    useAudioPlayback.tsx
    useInfinitePodcastSearch.ts
    useRSSInput.ts
    useTranscriptionManager.ts
    useTranscriptionSync.ts
    useTranslationHandler.ts
    useWordLookup.ts
  presenter/
    HomePagePresenter.tsx
    loginPagePresenter.tsx
    PodcastChannelPresenter.tsx
    PodcastPlayPresenter.tsx
    PodcastSearchPresenter.tsx
    SavedPodcastsPresenter.tsx
    WordlistPresenter.tsx
  styles/
    AudioPlayer.css
    CollapseBox.css
    HomePage.css
    LoginPage.css
    PodcastChannel.css
    PodcastPlay.css
    Skeleton.css
    theme.ts
    TopNav.css
    Wordlist.css
  test/
    TestPresenter.tsx
  utils/
    phoneticFormat.ts
    prefetchCache.ts
  views/
    PodcastView/
      DictionaryCard.tsx
      PodcastInfoCard.tsx
      PodcastPlayView.tsx
      TranscriptList.tsx
    _suspenseView.tsx
    HomePageView.tsx
    loginPageView.tsx
    PodcastChannelView.tsx
    PodcastSearchView.tsx
    SavedPodcastsView.tsx
    WordlistView.tsx
  firebaseApp.ts
  firebaseConfig.ts
  firestoreModel.ts
  index.tsx
  loginModel.ts
  Model.ts
  ReactRoot.tsx
  resolvePromise.ts
  rssModel.ts
  services.ts
.firebaserc
.gitignore
app-backup.json
db-backup.json
firebase.json
index.html
package.json
README.md
repomix-output-aaaaabiang-Listenary-ongoing.xml
tsconfig.base.json
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".firebase/hosting.ZGlzdA.cache">
saved-icon.png,1744807418273,f1b651238a58fe290baec6c5e32f3bdb1943dd2bd582f02569231f7a757c7837
logo.png,1744807418273,f1b651238a58fe290baec6c5e32f3bdb1943dd2bd582f02569231f7a757c7837
index.html,1747682694766,bda2cd4056b9f0476b38b317696e636e0ed15a199a4f3bef9e1b0649d77a350b
assets/index-BxHg_pkS.css,1747682694767,e5a4976e17a1178a0e102b8547a678538be7d339552c1a0104323ad236494f9c
assets/SingleLOGO-S-Kjgs1i.svg,1747682694766,b6cee4df303cdbe1f887681e106b52bd3e34469e50446ecdf2d790beedd34d8b
assets/vendor-XyqgThqv.js,1747682694766,e2c8f9fd1555f8fd2901722fd5873064f361129ea1cdcab8b8407df54297a500
assets/vendor-XyqgThqv.js.map,1747682694766,07168351d1f4a888f16a01e44ddca65715bd003fb652b7ee9d4aedcbd87db6e0
assets/index-B1fHrxOB.js,1747682694767,9669a3708e2f279c4d7c59d4a14bdf2a1e7506d92e74c71966dad964fa4b4544
assets/index-B1fHrxOB.js.map,1747682694768,2feb6a1b45ca0d696f4e343f64a2bf11db439a33db551dcfc7d4c754543dc16b
</file>

<file path="asset/Episode-Cover.svg">
<svg width="160" height="160" viewBox="0 0 160 160" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="160" height="160" fill="#F5F9FF"/>
<g filter="url(#filter0_i_269_1730)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M78.2744 113.5C79.0461 113.5 79.5331 112.659 79.197 111.964C77.8 109.078 77 105.845 77 102.4C77 90.153 87.0128 80.2 99.3333 80.2C100.204 80.2 101.057 80.2701 101.905 80.374C102.512 80.4485 103.056 79.9827 103.056 79.3711V46.9C103.056 42.793 99.7056 39.5 95.6111 39.5H75.2778C74.7255 39.5 74.2778 39.9477 74.2778 40.5V64.7257C74.2778 65.4824 73.4699 65.9649 72.8036 65.6061L64.4464 61.1054C64.1504 60.9459 63.7941 60.9459 63.4981 61.1054L55.1408 65.6061C54.4746 65.9649 53.6667 65.4824 53.6667 64.7257V40.5C53.6667 39.9477 53.219 39.5 52.6667 39.5H50.9444C46.8128 39.5 43.5 42.83 43.5 46.9V106.1C43.5 110.207 46.8128 113.5 50.9444 113.5H78.2744Z" fill="#D8E3FF"/>
</g>
<g filter="url(#filter1_i_269_1730)">
<path d="M94.5034 93.242C93.1701 92.4687 91.5 93.4307 91.5 94.9721V117.028C91.5 118.569 93.1701 119.531 94.5034 118.758L113.517 107.73C114.846 106.959 114.846 105.041 113.517 104.27L94.5034 93.242Z" fill="#006BFE"/>
</g>
<g filter="url(#filter2_i_269_1730)">
<path d="M56.5 60.6667V41C56.5 40.1716 57.1716 39.5 58 39.5H70C70.8284 39.5 71.5 40.1716 71.5 41V60.6667C71.5 61.0441 71.0978 61.2855 70.7647 61.1078L64.4706 57.751C64.1765 57.5941 63.8235 57.5941 63.5294 57.751L57.2353 61.1078C56.9022 61.2855 56.5 61.0441 56.5 60.6667Z" fill="#465A8D"/>
</g>
<defs>
<filter id="filter0_i_269_1730" x="43.5" y="39.5" width="59.5557" height="74" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
<filter id="filter1_i_269_1730" x="91.5" y="92.969" width="23.0137" height="26.062" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.5 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
<filter id="filter2_i_269_1730" x="56.5" y="39.5" width="15" height="21.6672" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
</defs>
</svg>
</file>

<file path="asset/LOGO.svg">
<svg width="416" height="81" viewBox="0 0 416 81" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_244_1660)">
<path d="M40.4445 5C49.2198 5 56.3334 12.136 56.3334 20.9388V27.4592C56.3334 31.6943 54.6861 35.5428 52.0001 38.3973V20.2143C52.0001 13.8123 46.8265 8.62245 40.4445 8.62245H27.4446C21.0626 8.62245 15.889 13.8123 15.889 20.2143V38.3973C13.203 35.5428 11.5557 31.6943 11.5557 27.4592V20.9388C11.5557 12.136 18.6693 5 27.4446 5H40.4445Z" fill="#D8E3FF"/>
<path d="M41.8889 13.6938C44.681 13.6938 46.9444 15.8879 46.9444 18.5943V63.4476C46.9444 66.154 46.1254 66.8991 43.3333 66.8991H6.5C5.05556 66.8991 4.33333 68.0306 4.33333 69.0237V69.6994C4.33333 70.8593 5.30339 71.7995 6.5 71.7995H49.8333C51.03 71.7995 52 70.8593 52 69.6994V34.5331C55.9722 34.5331 52.8932 34.5331 56.3333 34.5331C56.3333 36.9834 56.3333 38.4003 56.3333 39.4336V71.0995C56.3333 73.8059 54.0699 76 51.2778 76H5.05556C2.26345 76 0 73.8059 0 71.0995V18.5943C0 18.516 0.00188737 18.438 0.00564236 18.3605C0.00771593 18.3178 0.0116124 18.2752 0.0148112 18.2327C0.0177014 18.1943 0.0201823 18.156 0.02398 18.1178C0.0273287 18.0842 0.0319233 18.0508 0.0359701 18.0173C0.0417566 17.9695 0.047112 17.9218 0.0543077 17.8744C0.0591405 17.8426 0.0650688 17.8111 0.0705295 17.7794C0.0782398 17.7348 0.0862687 17.6903 0.0952149 17.6461C0.101088 17.617 0.107153 17.5881 0.113553 17.5593C0.125659 17.5047 0.138379 17.4504 0.152344 17.3966C0.157503 17.3766 0.163156 17.3569 0.168565 17.3371C0.181777 17.2887 0.195492 17.2406 0.210178 17.1928C0.221022 17.1576 0.232395 17.1225 0.244032 17.0876C0.255402 17.0534 0.26718 17.0195 0.279297 16.9856C0.293668 16.9456 0.308323 16.9057 0.32373 16.866C0.335141 16.8367 0.347023 16.8076 0.358995 16.7785C0.375235 16.7391 0.391813 16.6998 0.409071 16.6609C0.427301 16.6198 0.446148 16.5791 0.465495 16.5386C0.478581 16.5112 0.491401 16.4836 0.504991 16.4565C0.523706 16.4192 0.543874 16.3826 0.563531 16.3458C0.632423 16.2167 0.707058 16.0911 0.787107 15.969C0.808123 15.9371 0.828837 15.9048 0.850583 15.8733C0.879248 15.8318 0.908823 15.791 0.938744 15.7503C0.951983 15.7323 0.964766 15.7141 0.978243 15.6963C1.00843 15.6564 1.03996 15.6176 1.07134 15.5787C1.08848 15.5575 1.10535 15.5361 1.12283 15.5151C1.15043 15.482 1.17899 15.4497 1.20747 15.4173C1.22943 15.3924 1.25129 15.3673 1.27376 15.3429C1.30835 15.305 1.3438 15.2681 1.37956 15.2314C1.39086 15.2198 1.40199 15.208 1.41341 15.1965C1.45123 15.1585 1.48931 15.1206 1.52837 15.0837C1.5497 15.0636 1.57157 15.044 1.59326 15.0242C1.6272 14.9933 1.66142 14.9626 1.69623 14.9327C1.71504 14.9164 1.73431 14.9007 1.75336 14.8848C1.85127 14.8028 1.95168 14.7235 2.05594 14.6489C2.06638 14.6415 2.07717 14.6345 2.08767 14.6271C2.43093 14.3854 2.80686 14.1849 3.20768 14.0323C3.22035 14.0274 3.23304 14.0226 3.24577 14.0179C3.30172 13.9971 3.35815 13.9773 3.41504 13.9584C3.42467 13.9552 3.4343 13.952 3.44395 13.9489L3.55187 13.914C3.58217 13.9048 3.613 13.8973 3.64355 13.8887C3.65691 13.885 3.67035 13.8814 3.68376 13.8777C3.74238 13.8618 3.80133 13.8466 3.86078 13.8327C3.87906 13.8283 3.89744 13.8244 3.9158 13.8203C3.97515 13.8071 4.03481 13.7946 4.09494 13.7834C4.10902 13.7808 4.12314 13.7784 4.13726 13.7759C4.43513 13.7229 4.74188 13.6938 5.05556 13.6938H41.8889Z" fill="#006BFE"/>
<path d="M29.9895 50.2806C29.9895 52.8814 27.8878 54.9898 25.295 54.9898H20.9273C18.3346 54.9898 16.2329 52.8814 16.2329 50.2806C16.2329 48.281 19.3144 46.6582 23.1112 46.6582C26.908 46.6582 29.9895 48.281 29.9895 50.2806ZM23.1112 31.8061C25.4827 31.8061 27.7571 32.7984 29.434 34.5647C31.1109 36.331 32.053 38.7266 32.053 41.2245C32.053 42.382 31.8564 43.4922 31.4953 44.5172C31.1854 45.3972 30.0863 45.5602 29.4064 44.9231C28.9363 44.4826 28.8272 43.7881 29.0144 43.1707C29.2012 42.5546 29.3016 41.8983 29.3016 41.2245C29.3016 37.602 26.5503 34.7041 23.1112 34.7041C19.672 34.7041 16.9207 37.602 16.9207 41.2245C16.9207 41.8983 17.0212 42.5546 17.208 43.1707C17.3952 43.7881 17.286 44.4826 16.8159 44.9231C16.136 45.5602 15.037 45.3972 14.7271 44.5172C14.366 43.4922 14.1694 42.382 14.1694 41.2245C14.1694 38.7266 15.1115 36.331 16.7884 34.5647C18.4653 32.7984 20.7397 31.8061 23.1112 31.8061ZM23.1112 26.0102C26.9421 26.0102 30.6161 27.6131 33.3249 30.4664C36.0338 33.3196 37.5556 37.1894 37.5556 41.2245C37.5556 43.9222 36.886 46.4556 35.7191 48.6512C35.3087 49.4232 34.2848 49.5331 33.651 48.9323C33.1552 48.4623 33.0717 47.7084 33.3855 47.1008C34.289 45.352 34.8043 43.3485 34.8043 41.2245C34.8043 37.958 33.5724 34.8253 31.3795 32.5155C29.1866 30.2058 26.2124 28.9082 23.1112 28.9082C20.01 28.9082 17.0358 30.2058 14.8429 32.5155C12.65 34.8253 11.4181 37.958 11.4181 41.2245C11.4181 43.3485 11.9334 45.352 12.8369 47.1008C13.1507 47.7084 13.0672 48.4623 12.5714 48.9323C11.9375 49.5331 10.9137 49.4232 10.5033 48.6512C9.33639 46.4556 8.66675 43.9222 8.66675 41.2245C8.66675 37.1894 10.1885 33.3196 12.8975 30.4664C15.6063 27.6131 19.2803 26.0102 23.1112 26.0102ZM23.1112 37.602C24.0233 37.602 24.898 37.9837 25.5431 38.663C26.188 39.3423 26.5503 40.2637 26.5503 41.2245C26.5503 42.1852 26.188 43.1066 25.5431 43.7859C24.898 44.4653 24.0233 44.8469 23.1112 44.8469C22.1991 44.8469 21.3243 44.4653 20.6793 43.7859C20.0344 43.1066 19.672 42.1852 19.672 41.2245C19.672 40.2637 20.0344 39.3423 20.6793 38.663C21.3243 37.9837 22.1991 37.602 23.1112 37.602Z" fill="#D8E3FF"/>
<path d="M52 29.9949C52 28.1943 53.4551 26.7347 55.25 26.7347C60.6347 26.7347 65 31.1136 65 36.5153V45.2092C65 50.6108 60.6347 54.9898 55.25 54.9898C53.4551 54.9898 52 53.5302 52 51.7296V29.9949Z" fill="#D8E3FF"/>
<path d="M52 29.9949C52 28.1943 53.4551 26.7347 55.25 26.7347C60.6347 26.7347 65 31.1136 65 36.5153V45.2092C65 50.6108 60.6347 54.9898 55.25 54.9898C53.4551 54.9898 52 53.5302 52 51.7296V29.9949Z" fill="#D8E3FF"/>
</g>
<rect x="123.541" y="18.5457" width="13.3056" height="9.31393" rx="4.65696" fill="#006BFE"/>
<path d="M88 19C88 18.4477 88.4477 18 89 18H100.971C101.523 18 101.971 18.4477 101.971 19V52.1143C101.971 52.6666 102.419 53.1143 102.971 53.1143H115.94C116.492 53.1143 116.94 53.5621 116.94 54.1143V61.0956C116.94 61.6479 116.492 62.0956 115.94 62.0956H89C88.4477 62.0956 88 61.6479 88 61.0956V19Z" fill="#006BFE"/>
<path d="M123.613 32.1081C123.613 31.5558 124.061 31.1081 124.613 31.1081H136.085C136.638 31.1081 137.085 31.5558 137.085 32.1081V61.0956C137.085 61.6479 136.638 62.0956 136.085 62.0956H124.613C124.061 62.0956 123.613 61.6479 123.613 61.0956V32.1081Z" fill="#006BFE"/>
<path d="M173.46 37.0452C173.424 37.7516 172.685 38.199 172.033 37.9262C170.421 37.2524 168.834 36.7122 167.272 36.3056C165.297 35.7651 163.561 35.4948 162.064 35.4948C160.484 35.4948 159.362 35.6507 158.696 35.9626C158.031 36.2536 157.699 36.7734 157.699 37.5218C157.699 38.1871 158.187 38.7173 159.164 39.1123C160.141 39.4865 161.576 39.9231 163.468 40.422C165.36 40.921 167.054 41.4719 168.551 42.0748C170.048 42.6778 171.316 43.4262 172.356 44.3202C173.416 45.2141 174.216 46.2848 174.757 47.5322C175.318 48.7796 175.599 50.3077 175.599 52.1164C175.599 53.738 175.287 55.2245 174.663 56.5759C174.04 57.9064 173.094 59.0499 171.825 60.0062C170.557 60.9626 168.956 61.7006 167.023 62.2204C165.089 62.7401 162.813 63 160.193 63C157.865 63 155.526 62.8233 153.177 62.4699C151.043 62.1678 148.893 61.6429 146.726 60.8952C146.329 60.7582 146.067 60.3817 146.067 59.9617V52.5531C146.067 51.8322 146.807 51.347 147.477 51.6134C149.152 52.2798 150.834 52.832 152.522 53.2703C154.684 53.8316 156.742 54.1123 158.696 54.1123C162.21 54.1123 163.967 53.3846 163.967 51.9293C163.967 51.6798 163.884 51.4511 163.717 51.2432C163.551 51.0353 163.239 50.8378 162.782 50.6507C162.345 50.4428 161.721 50.2349 160.911 50.027C160.121 49.7983 159.102 49.5281 157.854 49.2162C156.129 48.8004 154.497 48.2703 152.958 47.6258C151.441 46.9605 150.11 46.1601 148.967 45.2245C147.844 44.2682 146.95 43.1559 146.285 41.8877C145.64 40.6195 145.318 39.1746 145.318 37.553C145.318 36.0977 145.62 34.7568 146.222 33.5301C146.846 32.3035 147.771 31.2536 148.998 30.3805C150.245 29.5073 151.784 28.8316 153.613 28.3534C155.464 27.8545 157.605 27.605 160.037 27.605C161.451 27.605 162.802 27.6674 164.091 27.7921C165.401 27.9168 166.638 28.0728 167.802 28.2599C168.967 28.4262 170.048 28.6133 171.046 28.8212C171.736 28.9479 172.387 29.0698 173.001 29.187C173.49 29.2804 173.834 29.7206 173.808 30.2177L173.46 37.0452Z" fill="#006BFE"/>
<path d="M199.985 63C198.052 63 196.202 62.7609 194.435 62.2827C192.667 61.8254 191.108 61.0457 189.757 59.9439C188.426 58.8212 187.356 57.3451 186.545 55.5156C185.755 53.6653 185.36 51.368 185.36 48.6237V37.1809C185.36 36.6286 184.912 36.1809 184.36 36.1809H180.154C179.602 36.1809 179.154 35.7332 179.154 35.1809V30.3528C179.154 29.8335 179.549 29.3982 180.064 29.326C181.813 29.0806 185.629 28.3596 187.407 26.5811C189.169 24.8197 189.662 20.9812 189.799 19.1702C189.84 18.6255 190.289 18.1871 190.835 18.1871H197.832C198.384 18.1871 198.832 18.6348 198.832 19.1871V27.447C198.832 27.9993 199.279 28.447 199.832 28.447H207.591C208.222 28.447 208.695 29.0243 208.578 29.6444C208.417 30.4983 208.266 31.3569 208.125 32.2204C207.983 33.1825 207.889 34.1745 207.842 35.1964C207.818 35.7422 207.374 36.1809 206.828 36.1809H199.832C199.279 36.1809 198.832 36.6286 198.832 37.1809V48.499C198.832 49.2474 198.884 49.9751 198.988 50.6819C199.112 51.368 199.351 51.9813 199.705 52.5218C200.058 53.0416 200.568 53.4678 201.233 53.8004C201.898 54.1123 202.782 54.2682 203.884 54.2682C204.59 54.2682 205.37 54.2058 206.222 54.0811C206.742 53.9924 207.303 53.8614 207.907 53.6879C208.531 53.5088 209.18 53.9252 209.24 54.5713L209.8 60.611C209.842 61.0632 209.575 61.4892 209.142 61.6283C208.011 61.9924 206.746 62.2937 205.349 62.5322C203.665 62.8441 201.877 63 199.985 63Z" fill="#006BFE"/>
<path d="M247.293 60.0315C247.293 60.4631 247.017 60.8471 246.604 60.9751C244.846 61.521 242.965 61.9777 240.963 62.3451C238.696 62.7817 236.337 63 233.884 63C231.202 63 228.644 62.6466 226.212 61.9397C223.78 61.2328 221.638 60.131 219.788 58.6341C217.938 57.1372 216.462 55.2453 215.36 52.9584C214.279 50.6507 213.738 47.9064 213.738 44.7256C213.738 42.9168 214.019 41.2432 214.58 39.7048C215.141 38.1455 215.9 36.7318 216.857 35.4636C217.834 34.1954 218.967 33.0728 220.256 32.0956C221.565 31.1185 222.958 30.2973 224.435 29.632C225.931 28.9667 227.47 28.4678 229.05 28.1351C230.63 27.7817 232.179 27.605 233.696 27.605C236.087 27.605 238.198 27.8753 240.027 28.4158C241.857 28.9356 243.374 29.6424 244.58 30.5364C245.807 31.4304 246.732 32.4699 247.356 33.6549C247.979 34.8399 248.291 36.0977 248.291 37.4283C248.291 39.0499 248.01 40.4324 247.449 41.5759C246.909 42.7193 246.17 43.6861 245.235 44.4761C244.32 45.2453 243.249 45.8586 242.023 46.316C240.817 46.7526 239.538 47.0956 238.187 47.3451C236.836 47.5738 235.453 47.7193 234.04 47.7817C232.647 47.8441 231.316 47.8753 230.048 47.8753C229.611 47.8753 229.185 47.8753 228.769 47.8753C228.757 47.8746 228.746 47.874 228.734 47.8734C228.127 47.8424 227.654 48.3839 227.804 48.9725C227.984 49.677 228.233 50.2988 228.551 50.8378C229.05 51.6486 229.663 52.3139 230.391 52.8337C231.139 53.3326 231.992 53.6965 232.948 53.9252C233.925 54.1331 234.965 54.237 236.067 54.237C236.898 54.237 237.782 54.1746 238.717 54.0499C239.674 53.9252 240.63 53.7588 241.586 53.5509C242.563 53.3222 243.53 53.0728 244.486 52.8025C244.988 52.6531 245.479 52.5009 245.958 52.346C246.614 52.1345 247.293 52.6177 247.293 53.3061V60.0315ZM227.384 41.96C227.319 42.5406 227.803 43.0204 228.387 42.991C228.64 42.9781 228.913 42.9638 229.206 42.948C229.996 42.9064 230.827 42.8337 231.701 42.7297C232.574 42.6258 233.447 42.4802 234.32 42.2931C235.193 42.106 235.983 41.8669 236.69 41.5759C237.397 41.2848 237.969 40.921 238.405 40.4844C238.842 40.0478 239.06 39.5177 239.06 38.894C239.06 37.8337 238.634 36.9917 237.782 36.368C236.95 35.7235 235.786 35.4012 234.289 35.4012C233.603 35.4012 232.865 35.5052 232.075 35.7131C231.285 35.9002 230.547 36.2744 229.861 36.8358C229.175 37.3971 228.593 38.1767 228.114 39.1746C227.75 39.9344 227.507 40.8629 227.384 41.96Z" fill="#006BFE"/>
<path d="M256.586 29.447C256.586 28.8947 257.034 28.447 257.586 28.447H268.866C269.488 28.447 269.961 29.0087 269.876 29.6247C269.812 30.092 269.748 30.6141 269.684 31.1913C269.679 31.2358 269.674 31.2803 269.669 31.3249C269.563 32.3086 270.931 32.8036 271.674 32.1506C271.828 32.0155 271.986 31.8828 272.148 31.7526C273.229 30.8794 274.414 30.1414 275.703 29.5385C276.992 28.9148 278.353 28.4366 279.788 28.1039C281.243 27.7713 282.709 27.605 284.185 27.605C285.807 27.605 287.345 27.8545 288.8 28.3534C290.256 28.8316 291.534 29.6008 292.636 30.6611C293.738 31.7214 294.611 33.1039 295.256 34.8087C295.9 36.4927 296.222 38.5405 296.222 40.9522V61.0956C296.222 61.6479 295.775 62.0956 295.222 62.0956H283.751C283.198 62.0956 282.751 61.6479 282.751 61.0956V42.9168C282.751 41.6279 282.615 40.5572 282.345 39.7048C282.075 38.8524 281.701 38.1767 281.222 37.6778C280.744 37.1788 280.173 36.8254 279.507 36.6175C278.863 36.4096 278.156 36.3056 277.387 36.3056C276.555 36.3056 275.734 36.4511 274.923 36.7422C274.112 37.0125 273.374 37.3867 272.709 37.8649C272.044 38.343 271.472 38.9044 270.994 39.5489C270.537 40.1647 270.232 40.8184 270.079 41.5102C270.064 41.5745 270.058 41.6402 270.058 41.7061V61.0956C270.058 61.6479 269.611 62.0956 269.058 62.0956H257.586C257.034 62.0956 256.586 61.6479 256.586 61.0956V29.447Z" fill="#006BFE"/>
<path d="M313.717 63C312.387 63 311.108 62.8129 309.882 62.4387C308.676 62.0644 307.605 61.4927 306.669 60.7235C305.734 59.9543 304.985 58.9875 304.424 57.8233C303.884 56.6383 303.613 55.2453 303.613 53.6445C303.613 52.106 303.863 50.7755 304.362 49.6528C304.861 48.5094 305.526 47.5322 306.358 46.7214C307.21 45.9106 308.198 45.2453 309.32 44.7256C310.464 44.185 311.669 43.7692 312.938 43.4782C314.206 43.1663 315.505 42.9584 316.836 42.8545C318.187 42.7297 319.497 42.6674 320.765 42.6674C321.638 42.6674 322.48 42.6881 323.291 42.7297C323.688 42.7501 324.072 42.7729 324.443 42.7982C325.042 42.8389 325.558 42.3562 325.473 41.7625C325.357 40.9443 325.139 40.2376 324.819 39.6424C324.362 38.7692 323.759 38.0832 323.01 37.5842C322.262 37.0644 321.389 36.7006 320.391 36.4927C319.393 36.2848 318.343 36.1809 317.241 36.1809C316.222 36.1809 315.173 36.2536 314.091 36.3992C313.031 36.5239 311.992 36.6902 310.973 36.8981C309.954 37.0852 308.977 37.2931 308.042 37.5218C307.629 37.6251 307.237 37.724 306.866 37.8188C306.231 37.9814 305.609 37.5027 305.609 36.8464V30.2141C305.609 29.7462 305.933 29.3402 306.391 29.2432C307.181 29.0759 308.012 28.9145 308.884 28.7588C310.069 28.5301 311.295 28.3326 312.563 28.1663C313.832 28 315.121 27.8649 316.43 27.7609C317.761 27.657 319.071 27.605 320.36 27.605C321.961 27.605 323.53 27.7089 325.069 27.9168C326.628 28.1039 328.094 28.4262 329.466 28.8836C330.859 29.341 332.137 29.9543 333.301 30.7235C334.486 31.4927 335.495 32.4491 336.326 33.5925C337.179 34.7152 337.844 36.0457 338.322 37.5842C338.8 39.1227 339.04 40.9002 339.04 42.9168V61.0956C339.04 61.6479 338.592 62.0956 338.04 62.0956H327.191C326.639 62.0956 326.191 61.6479 326.191 61.0956V59.9836C326.191 59.1314 324.733 58.6853 324.102 59.2578V59.2578C323.208 60.0478 322.2 60.7235 321.077 61.2848C319.954 61.8462 318.759 62.2723 317.491 62.5634C316.222 62.8545 314.965 63 313.717 63ZM318.988 55.6715C319.57 55.6715 320.235 55.5156 320.983 55.2037C321.753 54.8711 322.47 54.3721 323.135 53.7069C323.821 53.0416 324.393 52.1996 324.85 51.1809C325.212 50.4105 325.437 49.5273 325.525 48.5311C325.574 47.9809 325.12 47.5322 324.568 47.5322H324.538C323.541 47.5322 322.511 47.6362 321.451 47.8441C320.412 48.052 319.455 48.3638 318.582 48.7796C317.709 49.1954 316.992 49.7048 316.43 50.3077C315.869 50.9106 315.588 51.6071 315.588 52.3971C315.588 53.0208 315.692 53.5405 315.9 53.9563C316.108 54.3721 316.368 54.7152 316.68 54.9854C317.012 55.2349 317.376 55.4116 317.771 55.5156C318.187 55.6195 318.593 55.6715 318.988 55.6715Z" fill="#006BFE"/>
<path d="M348.083 29.447C348.083 28.8947 348.531 28.447 349.083 28.447H359.82C360.403 28.447 360.862 28.9429 360.835 29.5248C360.824 29.7595 360.815 30.0031 360.807 30.2557C360.786 30.9002 360.775 31.5863 360.775 32.3139C360.775 33.0208 360.775 33.738 360.775 34.4657V34.4657C360.775 34.9155 361.459 35.0653 361.674 34.6701C361.896 34.2621 362.137 33.8509 362.397 33.4366C363.062 32.3555 363.842 31.3888 364.736 30.5364C365.651 29.684 366.68 28.9875 367.823 28.447C368.988 27.8857 370.287 27.605 371.721 27.605C371.992 27.605 372.283 27.6258 372.595 27.6674C372.927 27.6881 373.249 27.7297 373.561 27.7921C373.873 27.8545 374.164 27.9376 374.435 28.0416C374.499 28.0599 374.561 28.0793 374.62 28.0997C374.964 28.2184 375.133 28.5791 375.102 28.9423L374.172 39.8832C374.116 40.5445 373.442 40.9686 372.803 40.7916C372.251 40.6388 371.683 40.5156 371.098 40.422C370.058 40.2349 369.154 40.1414 368.385 40.1414C367.324 40.1414 366.389 40.2765 365.578 40.5468C364.788 40.7963 364.112 41.1289 363.551 41.5447C362.99 41.9605 362.543 42.4179 362.21 42.9168C361.925 43.3729 361.718 43.8203 361.589 44.2589C361.565 44.3407 361.555 44.4256 361.555 44.5108V61.0956C361.555 61.6479 361.107 62.0956 360.555 62.0956H349.083C348.531 62.0956 348.083 61.6479 348.083 61.0956V29.447Z" fill="#006BFE"/>
<path d="M402.408 28.6258C402.408 28.0735 402.855 27.6258 403.408 27.6258H414.879C415.432 27.6258 415.879 28.0735 415.879 28.6258V42C415.879 44.3493 415.478 48.1289 415 50C414.522 51.8711 414.019 53.1247 413.166 54.58C412.314 56.0561 411.295 57.3139 410.11 58.3534C408.946 59.4137 407.657 60.2765 406.243 60.9418C404.83 61.6279 403.322 62.1268 401.721 62.4387C400.121 62.7713 398.478 62.9376 396.794 62.9376C394.528 62.9376 392.23 62.9833 389.965 62.5946C386.771 62.0466 384.413 61.3586 382.483 60.1253C382.179 59.9313 382.023 59.5774 382.061 59.2192L382.781 52.407C382.855 51.704 383.615 51.2993 384.245 51.6192C386.074 52.5473 387.364 53.091 389 53.5C390.29 53.8226 392.5 54 394.5 54C397.5 54 399.507 53.4029 401.285 51.7754C402.715 50.466 402.994 49.1434 403.049 45.8662C403.061 45.1307 401.858 44.7319 401.285 45.1933V45.1933C400.536 45.7963 399.705 46.3056 398.79 46.7214C397.875 47.1372 396.909 47.4491 395.89 47.657C394.892 47.8649 393.915 47.9688 392.958 47.9688C391.295 47.9688 389.715 47.7193 388.218 47.2204C386.721 46.7006 385.391 45.9002 384.227 44.8191C383.083 43.7173 382.168 42.3139 381.482 40.6091C380.817 38.9044 380.484 36.8669 380.484 34.4969V28.6258C380.484 28.0735 380.932 27.6258 381.484 27.6258H391.459C392.012 27.6258 392.459 28.0735 392.459 28.6258V34.1227C392.459 35.1622 392.605 36.0665 392.896 36.8358C393.208 37.5842 393.603 38.2079 394.081 38.7069C394.58 39.185 395.141 39.5489 395.765 39.7983C396.389 40.027 397.023 40.1414 397.667 40.1414C398.27 40.1414 398.852 40.0478 399.414 39.8607C399.996 39.6528 400.505 39.3617 400.942 38.9875C401.378 38.5925 401.732 38.1143 402.002 37.553C402.272 36.9917 402.408 36.3472 402.408 35.6195V28.6258Z" fill="#006BFE"/>
<defs>
<clipPath id="clip0_244_1660">
<rect width="65" height="71" fill="white" transform="translate(0 5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="asset/Podcast.svg">
<svg width="145" height="135" viewBox="0 0 145 135" fill="none" xmlns="http://www.w3.org/2000/svg">
<g filter="url(#filter0_i_266_1702)">
<path d="M41 66V61.5C41 44.103 55.103 30 72.5 30V30C89.897 30 104 44.103 104 61.5V64.0274" stroke="#D8E3FF" stroke-width="8"/>
<path d="M36.5 61.5H42C43.3807 61.5 44.5 62.6193 44.5 64V91C44.5 92.3807 43.3807 93.5 42 93.5H36.5C27.6634 93.5 20.5 86.3366 20.5 77.5C20.5 68.6634 27.6634 61.5 36.5 61.5Z" fill="#D8E3FF" stroke="#D8E3FF"/>
<path d="M108.5 93.5L103 93.5C101.619 93.5 100.5 92.3807 100.5 91L100.5 64C100.5 62.6193 101.619 61.5 103 61.5L108.5 61.5C117.337 61.5 124.5 68.6634 124.5 77.5C124.5 86.3366 117.337 93.5 108.5 93.5Z" fill="#D8E3FF" stroke="#D8E3FF"/>
<g filter="url(#filter1_i_266_1702)">
<path d="M57 63.5L57 92.5" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter2_i_266_1702)">
<path d="M65 51L65 105" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter3_i_266_1702)">
<path d="M73 60L73 96" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter4_i_266_1702)">
<path d="M81 69.5L81 86.5" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter5_i_266_1702)">
<path d="M89 72L89 84" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
</g>
<defs>
<filter id="filter0_i_266_1702" x="20" y="26" width="105" height="83.5" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="2"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.0793038 0 0 0 0 0.101942 0 0 0 0 0.350962 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter1_i_266_1702" x="54.5" y="61" width="5" height="38" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter2_i_266_1702" x="62.5" y="48.5" width="5" height="63" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter3_i_266_1702" x="70.5" y="57.5" width="5" height="45" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter4_i_266_1702" x="78.5" y="67" width="5" height="26" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter5_i_266_1702" x="86.5" y="69.5" width="5" height="21" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
</defs>
</svg>
</file>

<file path="asset/SingleLOGO.svg">
<svg width="71" height="78" viewBox="0 0 71 78" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_276_1691)">
<path d="M44.1776 0C53.7629 5.12777e-07 61.5332 7.83959 61.5332 17.5102V24.6735C61.5332 29.3261 59.7338 33.5541 56.7998 36.69V16.7143C56.7998 9.68107 51.1487 3.97959 44.1776 3.97959H29.9776C23.0065 3.97959 17.3554 9.68107 17.3554 16.7143V36.69C14.4214 33.5541 12.6221 29.3261 12.6221 24.6735V17.5102C12.6221 7.83959 20.3924 0 29.9776 0H44.1776Z" fill="#D8E3FF"/>
<path d="M45.7556 9.55103C48.8054 9.55103 51.2778 11.9614 51.2778 14.9346V64.2101C51.2778 67.1833 50.3832 68.0018 47.3333 68.0018H7.1C5.52222 68.0018 4.73333 69.2449 4.73333 70.3359V71.0782C4.73333 72.3525 5.79293 73.3854 7.1 73.3854H54.4333C55.7404 73.3854 56.8 72.3525 56.8 71.0782V32.4448C61.1389 32.4448 57.7757 32.4448 61.5333 32.4448C61.5333 35.1367 61.5333 36.6934 61.5333 37.8285V72.6164C61.5333 75.5896 59.0609 78 56.0111 78H5.52222C2.47239 78 0 75.5896 0 72.6164V14.9346C0 14.8486 0.00206159 14.7629 0.00616319 14.6778C0.00842817 14.6308 0.0126843 14.584 0.0161784 14.5374C0.0193354 14.4952 0.0220453 14.4531 0.0261936 14.4111C0.0298514 14.3742 0.0348701 14.3375 0.0392904 14.3007C0.045611 14.2482 0.0514608 14.1958 0.0593207 14.1438C0.0645997 14.1089 0.0710752 14.0742 0.0770399 14.0394C0.0854619 13.9903 0.094232 13.9415 0.104004 13.8929C0.110419 13.861 0.117044 13.8292 0.124035 13.7976C0.137259 13.7376 0.151153 13.6779 0.166407 13.6188C0.172042 13.5969 0.178216 13.5752 0.184125 13.5535C0.198556 13.5003 0.213537 13.4474 0.229579 13.395C0.241424 13.3562 0.253847 13.3177 0.266558 13.2793C0.278977 13.2418 0.291843 13.2045 0.305078 13.1674C0.320776 13.1233 0.336784 13.0795 0.353613 13.036C0.366078 13.0037 0.379056 12.9717 0.392133 12.9398C0.409872 12.8965 0.42798 12.8534 0.446831 12.8106C0.466744 12.7655 0.487331 12.7207 0.508463 12.6762C0.522757 12.6461 0.536762 12.6159 0.551606 12.5861C0.572048 12.545 0.594077 12.5048 0.615549 12.4644C0.6908 12.3227 0.772325 12.1846 0.859763 12.0505C0.882719 12.0154 0.905345 11.98 0.929098 11.9454C0.960409 11.8998 0.992714 11.8549 1.0254 11.8102C1.03986 11.7905 1.05382 11.7704 1.06854 11.7509C1.10152 11.7071 1.13595 11.6644 1.17024 11.6217C1.18895 11.5984 1.20738 11.5749 1.22648 11.5519C1.25663 11.5155 1.28782 11.48 1.31893 11.4444C1.34292 11.4171 1.3668 11.3895 1.39134 11.3626C1.42912 11.3211 1.46785 11.2805 1.5069 11.2402C1.51925 11.2274 1.53141 11.2145 1.54388 11.2018C1.58519 11.1601 1.62678 11.1184 1.66945 11.0779C1.69275 11.0558 1.71664 11.0343 1.74033 11.0126C1.77741 10.9786 1.81478 10.9449 1.85281 10.912C1.87335 10.8941 1.8944 10.8769 1.91521 10.8594C2.02216 10.7693 2.13184 10.6822 2.24571 10.6003C2.25712 10.5921 2.26891 10.5844 2.28038 10.5762C2.65532 10.3107 3.06595 10.0905 3.50378 9.9228C3.51762 9.91747 3.53148 9.91221 3.54538 9.90704C3.60649 9.8842 3.66814 9.86247 3.73028 9.84169C3.74079 9.83819 3.75131 9.83461 3.76186 9.83119L3.87973 9.7929C3.91283 9.7828 3.94651 9.77452 3.97988 9.76505C3.99448 9.76099 4.00915 9.75709 4.0238 9.75303C4.08782 9.73552 4.15222 9.7188 4.21716 9.70352C4.23713 9.69875 4.25721 9.69445 4.27726 9.68999C4.34209 9.67543 4.40725 9.66174 4.47294 9.6494C4.48831 9.64654 4.50374 9.64391 4.51917 9.64112C4.84453 9.58294 5.17959 9.55103 5.52222 9.55103H45.7556Z" fill="#006BFE"/>
<path d="M32.7578 49.7449C32.7578 52.6022 30.4621 54.9184 27.63 54.9184H22.8591C20.0271 54.9184 17.7314 52.6022 17.7314 49.7449C17.7314 47.5482 21.0973 45.7653 25.2446 45.7653C29.3918 45.7653 32.7578 47.5482 32.7578 49.7449ZM25.2446 29.449C27.835 29.449 30.3193 30.5391 32.1511 32.4795C33.9827 34.42 35.0118 37.0518 35.0118 39.7959C35.0118 41.0676 34.797 42.2873 34.4026 43.4133C34.0641 44.3801 32.8636 44.5591 32.1209 43.8592C31.6074 43.3753 31.4882 42.6123 31.6927 41.934C31.8967 41.2572 32.0065 40.5362 32.0065 39.7959C32.0065 35.8164 29.0012 32.6327 25.2446 32.6327C21.488 32.6327 18.4827 35.8164 18.4827 39.7959C18.4827 40.5362 18.5924 41.2572 18.7964 41.934C19.0009 42.6123 18.8817 43.3753 18.3682 43.8592C17.6256 44.5591 16.425 44.3801 16.0865 43.4133C15.6922 42.2873 15.4773 41.0676 15.4773 39.7959C15.4773 37.0518 16.5064 34.42 18.3381 32.4795C20.1698 30.5391 22.6542 29.449 25.2446 29.449ZM25.2446 23.0817C29.4291 23.0817 33.4422 24.8426 36.4011 27.9772C39.3601 31.1117 41.0224 35.3631 41.0224 39.7959C41.0224 42.7596 40.2909 45.5428 39.0163 47.9549C38.568 48.803 37.4496 48.9238 36.7573 48.2636C36.2157 47.7473 36.1245 46.9191 36.4673 46.2516C37.4541 44.3304 38.0171 42.1294 38.0171 39.7959C38.0171 36.2074 36.6714 32.7658 34.2761 30.2284C31.8808 27.6909 28.6321 26.2653 25.2446 26.2653C21.8571 26.2653 18.6084 27.6909 16.2131 30.2284C13.8178 32.7658 12.4721 36.2074 12.4721 39.7959C12.4721 42.1294 13.035 44.3304 14.0218 46.2516C14.3647 46.9191 14.2734 47.7473 13.7318 48.2636C13.0395 48.9238 11.9211 48.803 11.4729 47.9549C10.1983 45.5428 9.4668 42.7596 9.4668 39.7959C9.4668 35.3631 11.1291 31.1117 14.088 27.9772C17.0469 24.8426 21.0601 23.0817 25.2446 23.0817ZM25.2446 35.8164C26.2409 35.8164 27.1964 36.2356 27.9009 36.982C28.6054 37.7282 29.0012 38.7405 29.0012 39.7959C29.0012 40.8514 28.6054 41.8637 27.9009 42.6099C27.1964 43.3563 26.2409 43.7755 25.2446 43.7755C24.2483 43.7755 23.2928 43.3563 22.5882 42.6099C21.8838 41.8637 21.488 40.8514 21.488 39.7959C21.488 38.7405 21.8838 37.7282 22.5882 36.982C23.2928 36.2356 24.2483 35.8164 25.2446 35.8164Z" fill="#D8E3FF"/>
<path d="M56.7998 27.4592C56.7998 25.4811 58.3892 23.8776 60.3498 23.8776C66.2316 23.8776 70.9998 28.6883 70.9998 34.6225V44.1735C70.9998 50.1077 66.2316 54.9184 60.3498 54.9184C58.3892 54.9184 56.7998 53.3148 56.7998 51.3368V27.4592Z" fill="#D8E3FF"/>
<path d="M56.7998 27.4592C56.7998 25.4811 58.3892 23.8776 60.3498 23.8776C66.2316 23.8776 70.9998 28.6883 70.9998 34.6225V44.1735C70.9998 50.1077 66.2316 54.9184 60.3498 54.9184C58.3892 54.9184 56.7998 53.3148 56.7998 51.3368V27.4592Z" fill="#D8E3FF"/>
</g>
<defs>
<clipPath id="clip0_276_1691">
<rect width="71" height="78" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="functions/src/index.ts">
// functions/src/index.ts

const { onRequest } = require("firebase-functions/v2/https");
const admin = require("firebase-admin");
const axios = require("axios");
const Parser = require("rss-parser");

// 在 Node.js 环境中，使用 process.env 获取环境变量
// 您需要在 Firebase Functions 的环境变量中设置这些值
const AZURE_API_KEY = process.env.VITE_AZURE_API_KEY;
const DEEPL_API_KEY = process.env.VITE_DEEPL_API_KEY;

admin.initializeApp();

// ==================== 新增的辅助函数 ====================
function normalizeImageUrl(imageData) {
  if (!imageData) {
    return undefined;
  }
  
  // Case 1: 本身就是 URL 字符串
  if (typeof imageData === 'string' && imageData.startsWith('http')) {
    return imageData;
  }
  
  // Case 2: 是一个数组
  if (Array.isArray(imageData) && imageData.length > 0) {
    // 递归处理数组的第一个元素，无论它是字符串还是对象
    return normalizeImageUrl(imageData[0]);
  }
  
  // Case 3: 是一个对象
  if (typeof imageData === 'object' && imageData !== null) {
    // 常见格式: { url: '...' }
    if (imageData.url && typeof imageData.url === 'string') {
      return imageData.url;
    }
    // iTunes 常见格式: { href: '...' }
    if (imageData.href && typeof imageData.href === 'string') {
      return imageData.href;
    }
    // 处理 rss-parser 解析 XML 属性时的格式: { $: { href: '...' } }
    if (imageData.$ && imageData.$.href && typeof imageData.$.href === 'string') {
      return imageData.$.href;
    }
  }
  
  // 如果所有尝试都失败，返回 undefined
  return undefined;
}

// proxy 函数 (保持不变)
exports.proxy = onRequest({ cors: true }, async function (req, res) {
  const targetUrl = req.query.url;

  if (!targetUrl) {
    return res.status(400).send("Missing 'url' query parameter");
  }
  try {
    const axiosOptions = {
      method: req.method,
      url: targetUrl,
      headers: {
        "Content-Type": req.headers["content-type"],
        "Ocp-Apim-Subscription-Key": AZURE_API_KEY,
      },
      data: req.rawBody,
    };
    const response = await axios(axiosOptions);
    res.status(response.status).send(response.data);
  } catch (error) {
    console.error("Proxy error:", {
      message: error.message,
      code: error.code,
      config: error.config,
      responseData: error.response?.data,
      responseStatus: error.response?.status,
    });
    res.status(500).send("Failed to fetch target URL");
  }
  console.log("Incoming headers:", req.headers);
});

// Translation API Cloud Function (保持不变)
exports.translate = onRequest({ cors: true }, async function (req, res) {
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  try {
    console.log("Using API key:", DEEPL_API_KEY ? DEEPL_API_KEY.substr(0, 5) + "..." : "Not found");

    const response = await axios.post(
      "https://api-free.deepl.com/v2/translate",
      req.body,
      {
        headers: {
          Authorization: `DeepL-Auth-Key ${DEEPL_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    res.json(response.data);
  } catch (error) {
    console.error("Translation error:", {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
    });

    res.status(error.response?.status || 500).json({
      error: "Translation failed",
      details: error.response?.data || error.message,
    });
  }
});

// RSS Parser (已修改)
exports.parseRssFeed = onRequest({ cors: true }, async function (req, res) {
  const rssUrl = req.query.url;

  if (!rssUrl) {
    return res.status(400).send("Missing 'url' query parameter");
  }

  try {
    const response = await axios.get(rssUrl, {
      responseType: "text",
    });

    const parser = new Parser({
      customFields: {
        feed: ["image", "language", "copyright"],
        item: [
          "itunes:duration",
          "itunes:image",
          "itunes:episode",
          "itunes:season",
          "itunes:summary",
          "enclosure",
        ],
      },
    });
    const feed = await parser.parseString(response.data);

    // ==================== 修改的核心部分 ====================
    // 使用新的辅助函数来清洗图片 URL
    const channelImage = normalizeImageUrl(feed.image);

    const result = {
      feed: {
        title: feed.title,
        description: feed.description,
        image: channelImage, // <--- 使用清洗后的 URL
        link: feed.link,
      },
      items: feed.items.map(function (item) {
        // 同样为每一集的图片进行清洗
        // 如果单集没有自己的图片，则使用频道的封面图作为后备
        const itemImage = normalizeImageUrl(item.itunes?.image) || channelImage;

        return {
          title: item.title,
          description: item.contentSnippet || item.description,
          pubDate: item.pubDate || item.isoDate,
          duration: formatDuration(item.itunes?.duration),
          episode: item.itunes?.episode,
          season: item.itunes?.season,
          image: itemImage, // <--- 使用清洗后的 URL
          guid: item.guid,
          link: item.link,
          enclosure: item.enclosure,
        };
      }),
    };
    // ========================================================

    res.status(200).json(result);
  } catch (error) {
    console.error("Error parsing RSS feed:", error.message);
    res.status(500).send("Failed to parse RSS feed");
  }
});

// formatDuration 函数 (保持不变)
function formatDuration(duration) {
  if (!duration) return "Unknown";

  if (typeof duration === "number") {
    const m = Math.floor(duration / 60);
    const s = duration % 60;
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  if (typeof duration === "string") {
    if (/^\d+$/.test(duration)) {
      return formatDuration(Number(duration));
    }
    if (
      /^\d{1,2}:\d{2}$/.test(duration) ||
      /^\d{1,2}:\d{2}:\d{2}$/.test(duration)
    ) {
      return duration;
    }
  }

  return "Unknown";
}

// downloadAudio 函数 (保持不变)
exports.downloadAudio = onRequest({ cors: true }, async function (req, res) {
  const audioUrl = req.query.url;
  if (!audioUrl) return res.status(400).send("Missing audio URL");

  try {
    const response = await axios.get(audioUrl, {
      responseType: "arraybuffer",
    });

    res.set("Content-Type", response.headers["content-type"]);
    res.status(200).send(response.data);
  } catch (err) {
    console.error("Download audio failed:", err.message);
    res.status(500).send("Failed to download audio");
  }
});

exports.proxyImage = onRequest({ cors: true }, async (req, res) => {
  const imageUrl = req.query.url;
  if (!imageUrl || typeof imageUrl !== 'string') {
    return res.status(400).send("Missing 'url' query parameter");
  }

  try {
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer', // 关键：以二进制形式获取图片数据
      headers: {
        // 伪装成一个普通的浏览器请求
        'Referer': new URL(imageUrl).origin, 
      }
    });

    // 将图片数据和原始的 Content-Type 头返回给前端
    res.set('Content-Type', response.headers['content-type']);
    res.status(200).send(response.data);
  } catch (err) {
    console.error("Image proxy failed:", err.message);
    res.status(502).send("Failed to proxy image");
  }
});
</file>

<file path="functions/package.json">
{
  "name": "listenary-functions",
  "version": "1.0.0",
  "main": "lib/index.js",
  "private": true,
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc --noEmit -p tsconfig.json",
    "serve": "npm run build && firebase emulators:start --only functions",
    "deploy": "npm run build && firebase deploy --only functions"
  },
  "dependencies": {
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "firebase-admin": "^13.3.0",
    "firebase-functions": "^6.3.2",
    "rss-parser": "^3.13.0"
  },
  "devDependencies": {
    "typescript": "^5.5.0",
    "@types/node": "^20.0.0"
  },
  "engines": {
    "node": "20"
  }
}
</file>

<file path="functions/tsconfig.json">
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "Node",

    "rootDir": "src",
    "outDir": "lib",
    "sourceMap": true,

    /* 迁移友好：先放宽，先跑通 */
    "allowJs": true,
    "checkJs": false,
    "strict": false,
    "noImplicitAny": false,
    "skipLibCheck": true,

    /* 其它常用 */
    "esModuleInterop": true,
    "resolveJsonModule": true
  },
  "include": ["src"],
  "exclude": ["lib", "node_modules"]
}
</file>

<file path="listenary-backend/backups/backup-2025-10-17T21-35-28.json">
{
  "timestamp": "2025-10-17T21-35-28",
  "database": "listenary",
  "collections": {
    "feeditems": {
      "count": 0,
      "documents": []
    },
    "users": {
      "count": 1,
      "documents": [
        {
          "_id": "68f2aed4f6a0ce1f92ae370a",
          "email": "zrp99930@gmail.com",
          "displayName": "basin Z",
          "wordlist": [
            {
              "word": "bother",
              "phonetics": [
                {
                  "uk": null,
                  "us": null
                }
              ],
              "meanings": []
            }
          ],
          "savedPodcasts": [],
          "createdAt": "2025-10-17T21:02:12.512Z",
          "updatedAt": "2025-10-17T21:13:39.383Z",
          "__v": 1
        }
      ]
    },
    "transcriptions": {
      "count": 6,
      "documents": [
        {
          "_id": "68f2584bcd1c070e0c90ebb9",
          "userId": "65fd3a2b9f1c2a0012ab3456",
          "episodeId": "939758f4-ab62-11f0-9976-93b75701272e",
          "audioUrl": "https://pdst.fm/e/chrt.fm/track/25F5FC/dts.podtrac.com/redirect.mp3/traffic.megaphone.fm/FOXM5559449970.mp3",
          "status": "error",
          "resultText": "",
          "rssUrl": "https://feeds.megaphone.fm/FOXM9589275261",
          "createdAt": "2025-10-17T14:52:59.142Z",
          "updatedAt": "2025-10-17T15:39:47.479Z",
          "sentences": [],
          "__v": 0
        },
        {
          "_id": "68f26643b567d0d8151789e5",
          "userId": "65fd3a2b9f1c2a0012ab3456",
          "episodeId": "f53c0912-ab6a-11f0-a3ab-8f55070670c0",
          "audioUrl": "https://pdst.fm/e/chrt.fm/track/25F5FC/dts.podtrac.com/redirect.mp3/traffic.megaphone.fm/FOXM2034134516.mp3",
          "status": "error",
          "resultText": "",
          "rssUrl": "https://feeds.megaphone.fm/FOXM9589275261",
          "createdAt": "2025-10-17T15:52:35.533Z",
          "updatedAt": "2025-10-17T15:52:35.741Z",
          "sentences": [],
          "__v": 0
        },
        {
          "_id": "68f2667cb567d0d8151789e9",
          "userId": "65fd3a2b9f1c2a0012ab3456",
          "episodeId": "52470ea9-8ea4-4a48-8cf2-8c6089c2236a",
          "audioUrl": "https://media.transistor.fm/47170c87/857e1069.mp3",
          "status": "error",
          "resultText": "",
          "rssUrl": "https://feeds.transistor.fm/one-minute-mind-armor",
          "createdAt": "2025-10-17T15:53:32.391Z",
          "updatedAt": "2025-10-17T20:56:28.761Z",
          "sentences": [],
          "__v": 0
        },
        {
          "_id": "68f29db72e32304f925fa02b",
          "userId": "65fd3a2b9f1c2a0012ab3456",
          "episodeId": "32afb584-44ce-4759-8aaa-84c9f37d5687",
          "audioUrl": "https://anchor.fm/s/f1343ff4/podcast/play/89241316/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2024-6-15%2F383236202-44100-2-e266471b0390f.m4a",
          "status": "error",
          "resultText": "",
          "rssUrl": "https://anchor.fm/s/f1343ff4/podcast/rss",
          "createdAt": "2025-10-17T19:49:11.979Z",
          "updatedAt": "2025-10-17T19:49:12.171Z",
          "sentences": [],
          "__v": 0
        },
        {
          "_id": "68f2a0b2e61720b3a43aeaa7",
          "userId": "65fd3a2b9f1c2a0012ab3456",
          "episodeId": "7c6d11f8-ab8c-11f0-9edc-dfd665979682",
          "audioUrl": "https://pdst.fm/e/chrt.fm/track/25F5FC/dts.podtrac.com/redirect.mp3/traffic.megaphone.fm/FOXM4774959445.mp3",
          "status": "error",
          "resultText": "",
          "rssUrl": "https://feeds.megaphone.fm/FOXM9589275261",
          "createdAt": "2025-10-17T20:01:54.807Z",
          "updatedAt": "2025-10-17T20:13:10.963Z",
          "sentences": [],
          "__v": 0
        },
        {
          "_id": "68f2b12300c1ed15f1e7173a",
          "userId": "65fd3a2b9f1c2a0012ab3456",
          "episodeId": "51e88527-9b8b-4545-bb1d-5a8ea6e518d4",
          "audioUrl": "https://media.transistor.fm/dcceccd1/3b1d734c.mp3",
          "status": "done",
          "resultText": "Most of us were taught that asking for help makes you look weak, like you should have just figured it out yourself, right? But researchers found the opposite is true. People who ask for help are seen as more competent, not less. Here's why. Asking good questions shows you know what you don't know. And that's clarity. And that's confidence. The people who never ask, they often come across as defensive or fearful. And your brain knows this already. That's why collaboration just feels really natural. Because you're designed for it. So when that little voice in your head says, don't ask, don't bother, it's outdated wiring that's talking, asking for help isn't weakness. It's wisdom. And you got it.",
          "rssUrl": "https://feeds.transistor.fm/one-minute-mind-armor",
          "createdAt": "2025-10-17T21:12:03.162Z",
          "updatedAt": "2025-10-17T21:12:20.648Z",
          "sentences": [
            {
              "start": 0,
              "end": 7.04,
              "text": "Most of us were taught that asking for help makes you look weak, like you should have just figured it out yourself, right?"
            },
            {
              "start": 7.04,
              "end": 10.16,
              "text": "But researchers found the opposite is true."
            },
            {
              "start": 10.16,
              "end": 14.32,
              "text": "People who ask for help are seen as more competent, not less."
            },
            {
              "start": 14.32,
              "end": 20.56,
              "text": "Here's why. Asking good questions shows you know what you don't know."
            },
            {
              "start": 20.56,
              "end": 22,
              "text": "And that's clarity."
            },
            {
              "start": 22,
              "end": 32.08,
              "text": "And that's confidence. The people who never ask, they often come across as defensive or fearful. And your brain knows this already."
            },
            {
              "start": 32.08,
              "end": 36.04,
              "text": "That's why collaboration just feels really natural."
            },
            {
              "start": 36.04,
              "end": 38.32,
              "text": "Because you're designed for it."
            },
            {
              "start": 38.32,
              "end": 48.76,
              "text": "So when that little voice in your head says, don't ask, don't bother, it's outdated wiring that's talking, asking for help isn't weakness."
            },
            {
              "start": 48.76,
              "end": 49.92,
              "text": "It's wisdom."
            },
            {
              "start": 49.92,
              "end": 53.04,
              "text": "And you got it."
            }
          ],
          "__v": 1
        }
      ]
    },
    "subscriptions": {
      "count": 0,
      "documents": []
    }
  }
}
</file>

<file path="listenary-backend/config/firebaseConfig.ts">
// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
export const firebaseConfig = {
  apiKey: "AIzaSyAa84m37fzjOZzhNDMHzNlPmOGplU78kTI",
  authDomain: "dh2642-29c50.firebaseapp.com",
  projectId: "dh2642-29c50",
  storageBucket: "dh2642-29c50.firebasestorage.app",
  messagingSenderId: "389069809164",
  appId: "1:389069809164:web:eb9eb7fba4aab24fb33029",
  measurementId: "G-JMBEQCV08T",
};
</file>

<file path="listenary-backend/src/config/firebaseAdmin.ts">
// src/config/firebaseAdmin.ts
import admin from 'firebase-admin';

// 初始化 Firebase Admin SDK
if (!admin.apps.length) {
  // 使用环境变量中的服务账户密钥，如果没有则使用默认配置
  const serviceAccount = process.env.FIREBASE_PRIVATE_KEY ? {
    type: "service_account",
    project_id: process.env.FIREBASE_PROJECT_ID || "dh2642-29c50",
    private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
    private_key: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n'),
    client_email: process.env.FIREBASE_CLIENT_EMAIL,
    client_id: process.env.FIREBASE_CLIENT_ID,
    auth_uri: "https://accounts.google.com/o/oauth2/auth",
    token_uri: "https://oauth2.googleapis.com/token",
    auth_provider_x509_cert_url: "https://www.googleapis.com/oauth2/v1/certs",
    client_x509_cert_url: `https://www.googleapis.com/robot/v1/metadata/x509/${process.env.FIREBASE_CLIENT_EMAIL}`
  } : undefined;

  if (serviceAccount) {
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount as admin.ServiceAccount),
      projectId: process.env.FIREBASE_PROJECT_ID || "dh2642-29c50",
    });
  } else {
    // 如果没有服务账户密钥，使用默认配置（仅用于开发环境）
    console.warn("Firebase Admin SDK: 未找到服务账户密钥，使用默认配置");
    admin.initializeApp({
      projectId: "dh2642-29c50",
    });
  }
}

export default admin;
</file>

<file path="listenary-backend/src/middleware/authMiddleware.ts">
// src/middleware/authMiddleware.ts
// 认证中间件 - 合并Firebase认证和MongoDB用户管理

import admin from "../config/firebaseAdmin";
import User from "../modules/user&wordlist/models/User";
import { Request, Response, NextFunction } from "express";

/**
 * 认证中间件
 * 功能：
 * 1. 验证Firebase ID Token
 * 2. 查找或创建MongoDB用户记录
 * 3. 将用户信息附加到请求对象
 * 4. 统一错误处理
 */
export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // 1. 检查Authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        success: false,
        error: {
          code: "MISSING_TOKEN",
          message: "认证失败，未提供有效的Firebase Token"
        }
      });
    }

    // 2. 提取并验证Firebase ID Token
    const idToken = authHeader.split("Bearer ")[1];
    
    if (!idToken) {
      return res.status(401).json({
        success: false,
        error: {
          code: "INVALID_TOKEN_FORMAT",
          message: "认证失败，Token格式无效"
        }
      });
    }

    // 3. 验证Firebase ID Token
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    
    // 4. 查找或创建MongoDB用户记录
    let user = await User.findOne({ firebaseUid: decodedToken.uid });
    
    if (!user) {
      // 创建新用户记录（只包含业务数据）
      user = await User.create({
        firebaseUid: decodedToken.uid,
        wordlist: [],
        savedPodcasts: [],
        preferences: {
          language: 'en',
          theme: 'light',
          notifications: true
        }
      });
      console.log(`新用户创建成功: ${decodedToken.uid}`);
    }

    // 5. 将用户信息附加到请求对象
    req.user = user; // MongoDB业务数据
    
    // 6. 附加Firebase用户信息（用于显示）
    (req as any).firebaseUser = {
      uid: decodedToken.uid,
      email: decodedToken.email,
      displayName: (decodedToken as any).name || (decodedToken as any).display_name,
      photoURL: (decodedToken as any).picture || (decodedToken as any).photo_url,
      email_verified: decodedToken.email_verified
    };

    // 7. 继续到下一个中间件
    next();
    
  } catch (error: any) {
    console.error("统一认证中间件错误:", error.message);
    
    // 8. 统一错误处理
    let errorCode = "AUTH_ERROR";
    let errorMessage = "认证失败，Token验证错误";
    
    if (error.code === 'auth/id-token-expired') {
      errorCode = "TOKEN_EXPIRED";
      errorMessage = "认证失败，Token已过期";
    } else if (error.code === 'auth/invalid-id-token') {
      errorCode = "INVALID_TOKEN";
      errorMessage = "认证失败，无效的Token";
    } else if (error.code === 'auth/user-disabled') {
      errorCode = "USER_DISABLED";
      errorMessage = "认证失败，用户已被禁用";
    }
    
    return res.status(401).json({
      success: false,
      error: {
        code: errorCode,
        message: errorMessage
      }
    });
  }
};

export default authMiddleware;
</file>

<file path="listenary-backend/src/middleware/errorMiddleware.ts">
// src/middleware/errorMiddleware.ts
import { Request, Response, NextFunction } from 'express';

export const notFound = (req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`路由未找到 - ${req.method} ${req.originalUrl}`);
  res.status(404);
  next(error);
};

export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  // 如果错误对象中有关联的状态码，就用它；否则，看响应中是否已设置；最后默认为 500
  const statusCode = err.statusCode || (res.statusCode === 200 ? 500 : res.statusCode);
  res.status(statusCode);
  
  res.json({
    message: err.message,
    stack: process.env.NODE_ENV === 'production' ? '🥞' : err.stack,
  });
};
</file>

<file path="listenary-backend/src/middleware/firebaseAdmin.ts">
import admin from "firebase-admin";

if (!admin.apps.length) {
  // 使用项目ID初始化Firebase Admin
  // 注意：在生产环境中，应该使用服务账户密钥文件
  admin.initializeApp({
    projectId: "dh2642-29c50", // 从前端配置中获取的项目ID
    // 开发环境可以使用默认凭据，但需要设置环境变量
    // 或者使用服务账户密钥文件
  });
}

export { admin };
</file>

<file path="listenary-backend/src/middleware/validationMiddleware.ts">
// 数据验证中间件
import { Request, Response, NextFunction } from 'express';

// 验证RSS URL格式
export const validateRssUrl = (req: Request, res: Response, next: NextFunction) => {
  const { url } = req.body;
  
  if (!url) {
    return res.status(400).json({ 
      message: "URL is required",
      code: "MISSING_URL"
    });
  }

  try {
    new URL(url);
  } catch (e) {
    return res.status(400).json({ 
      message: "Invalid URL format",
      code: "INVALID_URL_FORMAT"
    });
  }

  const rssPatterns = [/\.xml$/i, /\/feed/i, /\/rss/i, /\/podcast/i, /\/itunes/i, /\/feedburner/i];
  if (!rssPatterns.some(pattern => pattern.test(url))) {
    return res.status(400).json({ 
      message: "Invalid RSS URL format. Please provide a valid RSS feed URL.",
      code: "INVALID_RSS_URL"
    });
  }

  next();
};

// 验证单词格式
export const validateWord = (req: Request, res: Response, next: NextFunction) => {
  const { word } = req.params;
  
  if (!word) {
    return res.status(400).json({ 
      message: "Word parameter is missing",
      code: "MISSING_WORD"
    });
  }

  const cleanWord = word.replace(/[^\w'-]/g, "");
  if (!cleanWord) {
    return res.status(400).json({ 
      message: "Invalid word format. Please provide a valid word.",
      code: "INVALID_WORD_FORMAT"
    });
  }

  // 将清理后的单词添加到请求中
  req.params.word = cleanWord;
  next();
};

// 验证音频时长
export const validateAudioDuration = (req: Request, res: Response, next: NextFunction) => {
  const { duration } = req.body;
  
  if (duration && duration > 1800) {
    return res.status(400).json({ 
      message: "Please select a shorter episode (less than 30 minutes).",
      code: "AUDIO_TOO_LONG"
    });
  }

  next();
};

// 验证翻译文本
export const validateTranslationText = (req: Request, res: Response, next: NextFunction) => {
  const { text, target_lang } = req.body;
  
  if (!Array.isArray(text) || text.length === 0) {
    return res.status(400).json({ 
      message: "Text array is required and cannot be empty",
      code: "INVALID_TEXT_ARRAY"
    });
  }

  if (!target_lang) {
    return res.status(400).json({ 
      message: "Target language is required",
      code: "MISSING_TARGET_LANG"
    });
  }

  // 验证文本长度
  const totalLength = text.reduce((sum, t) => sum + (t?.length || 0), 0);
  if (totalLength > 10000) { // 10KB限制
    return res.status(400).json({ 
      message: "Text too long. Please reduce the amount of text to translate.",
      code: "TEXT_TOO_LONG"
    });
  }

  next();
};
</file>

<file path="listenary-backend/src/modules/dictionary/dictionaryController.ts">
// listenary-backend/src/modules/dictionary/dictionaryController.ts
import { Request, Response, NextFunction, Router } from "express";
import axios from "axios";
import { validateWord } from "../../middleware/validationMiddleware";


// Merriam-Webster Dictionary API
async function getWordFromMerriamWebster(word: string) {
  try {
    const key = process.env.MERRIAM_WEBSTER_API_KEY;
    if (!key) {
      console.error('Merriam-Webster API key not found');
      return null;
    }

    const response = await axios.get(
      `https://www.dictionaryapi.com/api/v3/references/collegiate/json/${word}`,
      {
        params: {
          key: key
        },
        timeout: 15000,
        headers: {
          'User-Agent': 'ListenaryApp/1.0'
        }
      }
    );

    if (response.data && response.data.length > 0) {
      return response.data[0]; // 返回第一个结果
    }
    return null;
  } catch (error) {
    console.error('Merriam-Webster API failed:', error);
    return null;
  }
}


// 格式化Merriam-Webster响应
function formatMerriamWebsterResponse(data: any, word: string) {
  if (!data) return null;

  // 提取定义信息 - 使用shortdef字段
  const meanings = [];
  if (data.shortdef && data.shortdef.length > 0) {
    meanings.push({
      partOfSpeech: data.fl || 'noun',
      definitions: data.shortdef.map((shortdef: string) => ({
        definition: shortdef,
        example: null,
        synonyms: [],
        antonyms: []
      }))
    });
  }

  // 如果没有找到定义，提供默认定义
  if (meanings.length === 0) {
    meanings.push({
      partOfSpeech: data.fl || 'noun',
      definitions: [{
        definition: 'Definition not available',
        example: null,
        synonyms: [],
        antonyms: []
      }]
    });
  }

  const result = {
    word: data.hwi?.hw || word,
    phonetic: data.hwi?.prs?.[0]?.mw || null,
    phonetics: data.hwi?.prs?.map((pr: any) => ({
      text: pr.mw,
      audio: pr.sound?.audio ? `https://media.merriam-webster.com/audio/prons/en/us/mp3/${pr.sound.audio.charAt(0)}/${pr.sound.audio}.mp3` : null
    })) || [],
    meanings: meanings,
    etymology: data.et?.[0] || null,
    date: data.date || null,
    provider: 'Merriam-Webster'
  };

  return result;
}

export const lookupWord = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const word = req.params.word; // 已经由验证中间件清理过
    
    console.log(`开始查询单词: ${word}`);
    
    // 直接使用Merriam-Webster API
    const mwData = await getWordFromMerriamWebster(word);
    if (mwData) {
      const formattedResult = formatMerriamWebsterResponse(mwData, word);
      if (formattedResult) {
        console.log(`Merriam-Webster查询成功 - 单词: ${word}`);
        return res.status(200).json([formattedResult]);
      }
    }
    
    // Merriam-Webster查询失败
    console.log(`Merriam-Webster查询失败 - 单词: ${word}`);
    res.status(404).json({ 
      message: `No definition found for "${word}"` 
    });
    
  } catch (error: any) {
    console.error(`查询失败 - 单词: ${req.params.word}`, error);
    res.status(500).json({ 
      message: "Dictionary service error",
      details: error.message 
    });
  }
};


// 路由注册 — 与 transcriptController.ts 的风格保持一致
const router = Router();
router.get("/:word", validateWord, lookupWord);

export const dictionaryRoutes = router;
</file>

<file path="listenary-backend/src/modules/podcast-discovery/podcastController.ts">
// listenary-backend/src/modules/podcast-discovery/podcastController.ts

import { Request, Response, NextFunction, Router } from "express";
import * as podcastService from "./podcastService";

/**
 * 处理播客搜索请求
 */
export const searchPodcasts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const searchTerm = req.query.q as string;

    if (!searchTerm) {
      const error = new Error(
        'A search term (query parameter "q") is required.'
      );
      (error as any).statusCode = 400; // Bad Request
      throw error;
    }

    const results = await podcastService.searchPodcastsByTerm(searchTerm);
    res.status(200).json(results);
  } catch (error) {
    next(error); // 将错误传递给全局错误处理器
  }
};

/**
 * 获取播客分类列表
 */
export const getCategories = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const categories = await podcastService.getPodcastCategories();
    res.status(200).json(categories);
  } catch (error) {
    next(error);
  }
};

/**
 * 发现播客
 */
export const discoverPodcasts = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { category, lang, sort } = req.query;
    const results = await podcastService.discoverPodcasts(
      category as string, 
      lang as string, 
      sort as string
    );
    res.status(200).json(results);
  } catch (error) {
    next(error);
  }
};

// 路由注册并导出，保持与项目中其他 controller 的风格一致
const router = Router();
// 定义搜索路由：GET /api/podcasts/search?q=your_search_term
router.get("/search", searchPodcasts);
// 定义分类路由：GET /api/podcasts/categories
router.get("/categories", getCategories);
// 定义发现路由：GET /api/podcasts/discover?lang=en&sort=trending
router.get("/discover", discoverPodcasts);

export const podcastRoutes = router;
</file>

<file path="listenary-backend/src/modules/podcast-discovery/podcastService.ts">
// 文件路径: listenary-backend/src/modules/podcast-discovery/podcastService.ts

import axios from 'axios';
import crypto from 'crypto';

// Podcast Index API 的基础 URL
const API_URL = 'https://api.podcastindex.org/api/1.0';

/**
 * 生成调用 Podcast Index API 所需的认证请求头。
 * 它会从 .env 文件中读取 API Key 和 Secret，并根据 API 要求生成一个 SHA1 哈希值。
 * 这是所有 API 请求成功的前提。
 */
const generateApiHeaders = () => {
  const apiKey = process.env.PODCAST_INDEX_API_KEY as string;
  const apiSecret = process.env.PODCAST_INDEX_API_SECRET as string;

  // 如果在 .env 文件中找不到必要的密钥，则立即抛出错误。
  // 这会导致调用此函数的任何请求都失败，并向前端返回 500 错误。
  if (!apiKey || !apiSecret) {
    throw new Error('Podcast Index API Key or Secret is not defined in .env');
  }

  const apiHeaderTime = Math.floor(Date.now() / 1000);
  const hash = crypto.createHash('sha1').update(apiKey + apiSecret + apiHeaderTime).digest('hex');
  
  return {
    'User-Agent': 'ListenaryApp/1.0', // API 推荐的 User-Agent
    'X-Auth-Key': apiKey,
    'X-Auth-Date': apiHeaderTime.toString(),
    'Authorization': hash,
  };
};

/**
 * 一个辅助函数，用于将从 Podcast Index API 获取的播客数据
 * 格式化为前端期望的统一结构。
 * @param feeds - 从 API 响应中获取的播客列表 (response.data.feeds)
 * @returns 格式化后的播客对象数组
 */
const mapFeedsToFrontendFormat = (feeds: any[]) => {
  if (!feeds) return [];
  return feeds.map((feed: any) => ({
    id: feed.id,
    title: feed.title,
    url: feed.url,
    author: feed.author,
    image: feed.image,
    description: feed.description,
    // API 返回的 categories 是一个对象，我们将其转换为前端期望的字符串数组
    categories: feed.categories ? Object.values(feed.categories) : [],
  }));
};

/**
 * 根据搜索词查询播客。
 * @param term - 用户输入的搜索关键词
 * @returns 格式化后的播客列表
 */
export const searchPodcastsByTerm = async (term: string) => {
  try {
    const headers = generateApiHeaders();
    const params = new URLSearchParams({ q: term, max: '200' }); // max: 返回的最大结果数
    const response = await axios.get(`${API_URL}/search/byterm`, { headers, params });
    
    return mapFeedsToFrontendFormat(response.data.feeds);
  } catch (error: any) {
    // 如果请求失败，在后端控制台打印详细错误，并向上抛出
    console.error('Error in searchPodcastsByTerm:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * 获取所有可用的播客分类列表。
 * @returns 分类对象数组 (e.g., [{ id: 7, name: 'Arts' }, ...])
 */
export const getPodcastCategories = async () => {
  try {
    const headers = generateApiHeaders();
    const response = await axios.get(`${API_URL}/categories/list`, { headers });
    
    // 根据 API 文档，分类列表在返回数据的 `feeds` 字段中
    return response.data.feeds; 
    
  } catch (error: any) {
    console.error('Error in getPodcastCategories:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * 用于“发现”功能，可以获取热门或最新的播客。
 * @param category - 可选，按分类名称筛选
 * @param lang - 可选，按语言筛选 (e.g., 'en')
 * @param sort - 可选，'trending' (热门) 或 'recent' (最新)
 * @returns 格式化后的播客列表
 */
export const discoverPodcasts = async (category?: string, lang?: string, sort?: string) => {
  try {
    // 根据 sort 参数决定使用哪个 API 端点
    const endpoint = sort === 'recent' ? 'recent/feeds' : 'podcasts/trending';
    const headers = generateApiHeaders();
    const params = new URLSearchParams({ max: '200' });

    // 如果提供了参数，则将其添加到请求中
    if (category && category !== 'all') params.append('cat', category);
    if (lang) params.append('lang', lang);

    const response = await axios.get(`${API_URL}/${endpoint}`, { headers, params });

    return mapFeedsToFrontendFormat(response.data.feeds);
  } catch (error: any) {
    console.error('Error in discoverPodcasts:', error.response?.data || error.message);
    throw error;
  }
};
</file>

<file path="listenary-backend/src/modules/rss/controller.ts">
//controller.ts — Express 路由层，接收请求、校验、调用 service、返回 HTTP 响应
import express from "express";
import {
  createSubscription,
  listSubscriptions,
  deleteSubscription,
  fetchAndPersistFeed,
  listItemsBySubscription,
  fetchFeedFromUrl
} from "./service";
import { validateRssUrl } from "../../middleware/validationMiddleware";

const router = express.Router();

// POST /api/rss/subscriptions  -> 创建订阅 
router.post("/subscriptions", validateRssUrl, async (req, res) => {
  try {
    const { url, title } = req.body;
    const sub = await createSubscription(url, title);
    res.status(201).json(sub);
  } catch (err: any) {
    console.error(err);
    res.status(500).json({ message: err.message });
  }
});

// GET /api/rss/subscriptions -> 列出订阅 
router.get("/subscriptions", async (req, res) => {
  const subs = await listSubscriptions();
  res.json(subs);
});

// DELETE /api/rss/subscriptions/:id -> 删除订阅及其条目 
router.delete("/subscriptions/:id", async (req, res) => {
  try {
    await deleteSubscription(req.params.id);
    res.status(204).send();
  } catch (err: any) {
    console.error(err);
    res.status(500).json({ message: err.message });
  }
});

// GET /api/rss/fetch?url=... -> 立刻解析并返回（不持久化）
router.get("/fetch", (req, res, next) => {
  const url = String(req.query.url || "");
  if (!url) return res.status(400).json({ message: "url required" });
  
  // 将query参数转换为body参数以使用验证中间件
  req.body = { url };
  next();
}, validateRssUrl, async (req, res) => {
  try {
    const result = await fetchFeedFromUrl(req.body.url);
    res.json(result);
  } catch (err: any) {
    console.error("Fetch error:", err);
    res.status(502).json({ message: "Failed to fetch feed", detail: err.message });
  }
});

// POST /api/rss/subscriptions/:id/fetch-and-save -> 抓取并持久化 
router.post("/subscriptions/:id/fetch-and-save", async (req, res) => {
  try {
    const result = await fetchAndPersistFeed(req.params.id);
    res.json(result);
  } catch (err: any) {
    console.error(err);
    res.status(500).json({ message: err.message });
  }
});

// GET /api/rss/subscriptions/:id/items -> 列出 DB 中该订阅的条目  前端后续调用
router.get("/subscriptions/:id/items", async (req, res) => {
  try {
    const items = await listItemsBySubscription(req.params.id, Number(req.query.limit || 50));
    res.json(items);
  } catch (err: any) {
    console.error(err);
    res.status(500).json({ message: err.message });
  }
});

// test
router.get("/test", (req, res) => {
  res.json({ message: "RSS route OK" });
});

export const rssRoutes = router;
</file>

<file path="listenary-backend/src/modules/rss/model.ts">
//model.ts — 描述数据结构与 DB schema（TypeScript interface + Mongoose schema 或替代的 ORM model）
import { Schema, model, Document, Types } from "mongoose";

// TypeScript 接口
export interface IFeedItem {
  guid: string;
  title: string;
  link?: string;
  pubDate?: Date | null;
  content?: string;
  enclosure?: any;
  itunes?: {
    duration?: string | number;
    episode?: string | number;
    season?: string | number;
    image?: string;
    summary?: string;
  };
  feedId?: Types.ObjectId | string; // 关联的订阅
  createdAt?: Date;
}

// 订阅（Feed Source）接口 
export interface ISubscription {
  url: string;
  title?: string;
  lastFetchedAt?: Date | null;
  // 可加入 owner 字段（userId）等
  createdAt?: Date;
  updatedAt?: Date;
}

// Mongoose Documents
export interface FeedItemDoc extends IFeedItem, Document {}
export interface SubscriptionDoc extends ISubscription, Document {}

// FeedItem Schema（持久化条目） 
const FeedItemSchema = new Schema<FeedItemDoc>({
  guid: { type: String, required: true, index: true },
  title: { type: String, required: true },
  link: { type: String },
  pubDate: { type: Date },
  content: { type: String },
  enclosure: { type: Schema.Types.Mixed },
  itunes: { type: Schema.Types.Mixed },
  feedId: { type: Schema.Types.ObjectId, ref: "Subscription" },
}, {
  timestamps: { createdAt: true, updatedAt: false } // 记录抓取时间
});

//保证单个订阅中 guid 唯一，避免重复写入
FeedItemSchema.index({ guid: 1, feedId: 1 }, { unique: true, background: true });


//Subscription Schema
const SubscriptionSchema = new Schema<SubscriptionDoc>({
  url: { type: String, required: true, unique: true },
  title: { type: String },
  lastFetchedAt: { type: Date, default: null },
}, {
  timestamps: true
});

export const FeedItemModel = model<FeedItemDoc>("FeedItem", FeedItemSchema);
export const SubscriptionModel = model<SubscriptionDoc>("Subscription", SubscriptionSchema);
</file>

<file path="listenary-backend/src/modules/rss/service.ts">
//service.ts — 业务逻辑：抓取 RSS、解析、缓存、存/取订阅、去重、变更检测等（不做 HTTP 路由）

import Parser from "rss-parser";
import { SubscriptionModel, FeedItemModel } from "./model";
import { Types } from "mongoose";

const parser = new Parser({
  // 可在此处加入 customFields 如需解析 itunes 字段：
  // customFields: { item: ['itunes:duration','itunes:image','itunes:episode','itunes:season','itunes:summary'] }
});

const DEFAULT_MAX_ITEMS = Number(process.env.MAX_ITEMS_PER_FEED ?? 50);

// RSS URL 验证函数
export function isValidRssUrl(url: string): boolean {
  try {
    new URL(url);
  } catch (e) {
    return false;
  }
  const rssPatterns = [/\.xml$/i, /\/feed/i, /\/rss/i, /\/podcast/i, /\/itunes/i, /\/feedburner/i];
  return rssPatterns.some(pattern => pattern.test(url));
}

/**
 * 格式化时长为标准格式 HH:MM:SS 或 MM:SS
 * 支持多种输入格式：秒数、"MM:SS"、"HH:MM:SS"、纯数字字符串等
 */
function formatDuration(duration: any): string {
  if (!duration) return "Unknown";

  // 如果是纯数字（秒数）
  if (typeof duration === "number") {
    const hours = Math.floor(duration / 3600);
    const minutes = Math.floor((duration % 3600) / 60);
    const seconds = Math.floor(duration % 60);
    
    if (hours > 0) {
      return `${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    }
    return `${minutes}:${String(seconds).padStart(2, "0")}`;
  }

  // 如果是字符串
  if (typeof duration === "string") {
    // 纯数字字符串（秒数）
    if (/^\d+$/.test(duration)) {
      return formatDuration(Number(duration));
    }
    
    // 已经是标准格式 MM:SS 或 HH:MM:SS
    if (/^\d{1,2}:\d{2}(:\d{2})?$/.test(duration)) {
      const parts = duration.split(':');
      if (parts.length === 2) {
        // MM:SS 格式
        return `${parts[0]}:${parts[1]}`;
      } else if (parts.length === 3) {
        // HH:MM:SS 格式
        return duration;
      }
    }
  }

  return "Unknown";
}

// 解析 URL 并返回映射后的结果（不持久化）
export async function fetchFeedFromUrl(url: string, maxItems = DEFAULT_MAX_ITEMS) {
  const feed = await parser.parseURL(url);
  const items = (feed.items || []).slice(0, maxItems).map(it => {
    const anyIt = it as any;
    
    // 处理 itunes:image - 可能是字符串或对象
    const itunesImageValue = anyIt['itunes:image'] ?? anyIt.itunes?.image;
    let itunesImageUrl: string | undefined = undefined;
    
    if (typeof itunesImageValue === 'string') {
      itunesImageUrl = itunesImageValue;
    } else if (itunesImageValue && typeof itunesImageValue === 'object') {
      itunesImageUrl = itunesImageValue.url || itunesImageValue.href;
    }
    
    // 处理 enclosure（音频附件），其中可能也包含图片
    const enclosureValue = anyIt.enclosure;
    
    // 提取常用字段
    const durationRaw = anyIt['itunes:duration'] ?? anyIt.itunes?.duration;
    const durationValue = formatDuration(durationRaw);  // 格式化时长
    const contentValue = anyIt.contentSnippet ?? anyIt.content;
    
    return {
      guid: anyIt.guid ?? anyIt.id ?? (anyIt.link ?? anyIt.title ?? Math.random().toString(36).slice(2)),
      title: anyIt.title ?? "",
      link: anyIt.link,
      pubDate: anyIt.pubDate ? new Date(anyIt.pubDate) : (anyIt.isoDate ? new Date(anyIt.isoDate) : undefined),
      content: contentValue,
      description: contentValue,  // 兼容前端：description 和 content 都提供
      enclosure: enclosureValue,
      // 添加 image 字段：优先使用 itunes image，其次使用 feed image
      image: itunesImageUrl,
      // 添加 duration 到顶层，方便前端访问（已格式化）
      duration: durationValue,
      // 保留完整的 itunes 信息
      itunes: {
        duration: durationValue,  // 格式化后的时长
        episode: anyIt['itunes:episode'] ?? anyIt.itunes?.episode,
        season: anyIt['itunes:season'] ?? anyIt.itunes?.season,
        image: itunesImageUrl,
        summary: anyIt['itunes:summary'] ?? anyIt.itunes?.summary,
      }
    };
  });

  // 处理 feed image 字段：RSS parser 可能返回对象或字符串
  const imageValue = (feed as any).image;
  let feedImageUrl: string | undefined = undefined;
  
  if (typeof imageValue === 'string') {
    feedImageUrl = imageValue;
  } else if (imageValue && typeof imageValue === 'object') {
    // image 是对象时，提取 url 字段
    feedImageUrl = imageValue.url || imageValue.href || imageValue.link;
  }

  // 为没有图片的 item 添加 feed 的默认图片
  const itemsWithFallbackImage = items.map(item => ({
    ...item,
    image: item.image || feedImageUrl
  }));

  const feedMeta = {
    title: feed.title,
    description: feed.description,
    link: feed.link,
    image: feedImageUrl
  };

  return { feedMeta, items: itemsWithFallbackImage };
}

//创建订阅（若已存在则返回已存在）
export async function createSubscription(url: string, title?: string) {
  const existing = await SubscriptionModel.findOne({ url }).lean();
  if (existing) return existing;
  const created = await SubscriptionModel.create({ url, title });
  return created.toObject();
}

// 列出所有订阅
export async function listSubscriptions() {
  return SubscriptionModel.find().lean();
}

// 删除订阅（同时可选删除已保存条目） 
export async function deleteSubscription(id: string) {
  const sub = await SubscriptionModel.findByIdAndDelete(id);
  if (sub) {
    await FeedItemModel.deleteMany({ feedId: sub._id });
  }
}

// 抓取并持久化：将抓取到的 item upsert 到 DB（去重），返回已插入/存在的条目摘要
export async function fetchAndPersistFeed(subscriptionId: string | Types.ObjectId, url?: string) {
  // 确认订阅存在
  const sub = await SubscriptionModel.findById(subscriptionId);
  if (!sub) throw new Error("Subscription not found");

  const targetUrl = url ?? sub.url;
  const { feedMeta, items } = await fetchFeedFromUrl(targetUrl);

  const saved: any[] = [];
  for (const it of items) {
    try {
      const doc = await FeedItemModel.findOneAndUpdate(
        { guid: it.guid, feedId: sub._id },
        { $setOnInsert: { ...it, feedId: sub._id } },
        { upsert: true, new: true, setDefaultsOnInsert: true }
      ).lean();
      saved.push(doc);
    } catch (err: any) {
      if (err.code === 11000) continue; // 唯一键冲突 -> 已存在，忽略
      console.warn("Failed to persist item", err);
    }
  }

  sub.lastFetchedAt = new Date();
  await sub.save();

  return { feedMeta, saved };
}

// 从 DB 读取某订阅的条目（最近 N 条）
export async function listItemsBySubscription(subscriptionId: string | Types.ObjectId, limit = 50) {
  return FeedItemModel.find({ feedId: subscriptionId }).sort({ pubDate: -1 }).limit(limit).lean();
}
</file>

<file path="listenary-backend/src/modules/transcription/controller/transcriptController.ts">
//  •	接收请求，解析参数。
// •	调用 Service。
// •	返回 HTTP 响应。
// •	不写业务逻辑。

// 示例代码：
// const express = require("express");
// const router = express.Router();
// const userService = require("./user.service");

// router.get("/:id", async (req, res) => {
//   try {
//     const user = await userService.getUserById(req.params.id);
//     res.json(user);
//   } catch (err) {
//     res.status(400).json({ error: err.message });
//   }
// });

// module.exports = router;

import { Router, Request, Response } from "express";
import * as transcriptionService from "../service/transcriptService";
import { authMiddleware } from "../../../middleware/authMiddleware";
import { validateAudioDuration } from "../../../middleware/validationMiddleware";
import { Transcription } from "../transcriptModel";
import axios from "axios";

// 统一的数据格式转换函数
function formatSentencesToPhrases(sentences: any[] | undefined, resultText?: string) {
  if (Array.isArray(sentences) && sentences.length > 0) {
    return sentences.map((sentence: any) => {
      const offsetMilliseconds = sentence.start ? Math.round(sentence.start * 1000) : 0;
      const endOffsetMilliseconds = sentence.end ? Math.round(sentence.end * 1000) : undefined;
      
      // 计算时间戳格式
      const totalSeconds = Math.floor(offsetMilliseconds / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const timestamp = hours > 0 
        ? `${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`
        : `${minutes}:${String(seconds).padStart(2, "0")}`;
      
      return {
        text: sentence.text || '',
        offsetMilliseconds,
        endOffsetMilliseconds,
        timestamp, // 添加格式化后的时间戳
      };
    });
  }
  
  if (resultText) {
    return [{
      text: resultText,
      offsetMilliseconds: 0,
      timestamp: "0:00",
    }];
  }
  
  return [];
}

const router = Router();
/**
 * @route POST /api/transcriptions   // 表示这是一个 POST 请求接口
 * @desc 创建一个新的转写任务（调用外部 API 获取转写结果） // 简要说明接口作用
 * @body { rssUrl: string }          // 说明请求体需要传递的参数
 */
async function createTranscription(req: Request, res: Response) {
  try {
    const { audioUrl, episodeId, rssUrl, force } = req.body;

    if (!audioUrl || !episodeId) {
      res
        .status(400)
        .json({ error: "audioUrl and episodeId are required in request body" });
      return;
    }

    // 从 auth middleware 设置的 req.user 中获取 userId
    const user = (req as any).user;
    if (!user) {
      res.status(401).json({ error: "Authentication required" });
      return;
    }
    const userId = user._id ? String(user._id) : user.id;

    const transcriptionResult =
      await transcriptionService.createOrGetTranscription(
        userId,
        episodeId,
        audioUrl,
        rssUrl,
        Boolean(force)
      );

    const payload =
      typeof transcriptionResult.toObject === "function"
        ? transcriptionResult.toObject()
        : transcriptionResult;

    // 统一数据格式转换逻辑
    const phrases = formatSentencesToPhrases(payload.sentences, payload.resultText);

    res.status(201).json({ ...payload, phrases });
  } catch (err: any) {
    // 发生错误时返回 400 状态码和错误信息
    // Return status 400 and error message if error occurs
    res.status(400).json({ error: err.message });
  }
}

/**
 * @route POST /api/transcriptions/save
 * @desc 保存转录结果到数据库
 * @body { episodeId: string, title: string, phrases: any[] }
 */
async function saveTranscriptionResult(req: Request, res: Response) {
  try {
    const { episodeId, title, phrases } = req.body;

    if (!episodeId || !phrases || !Array.isArray(phrases)) {
      res.status(400).json({ 
        error: "episodeId and phrases array are required in request body" 
      });
      return;
    }

    // 从 auth middleware 设置的 req.user 中获取 userId
    const user = (req as any).user;
    if (!user) {
      res.status(401).json({ error: "Authentication required" });
      return;
    }
    const userId = user._id ? String(user._id) : user.id;

    // 查找是否已存在该episode的转录记录
    let transcription = await Transcription.findOne({ 
      userId, 
      episodeId 
    });

    if (transcription) {
      // 更新现有记录
      transcription.status = "done";
      transcription.resultText = phrases.map(p => p.text).join(' ');
      transcription.sentences = phrases.map(phrase => ({
        start: phrase.offsetMilliseconds / 1000, // 转换为秒
        end: (phrase.offsetMilliseconds + 5000) / 1000, // 假设每句5秒
        text: phrase.text,
        speaker: "speaker1"
      }));
      transcription.updatedAt = new Date();
      await transcription.save();
    } else {
      // 创建新记录
      transcription = await Transcription.create({
        userId,
        episodeId,
        audioUrl: `saved_${episodeId}`, // 占位符，因为这是保存的结果
        status: "done",
        resultText: phrases.map(p => p.text).join(' '),
        sentences: phrases.map(phrase => ({
          start: phrase.offsetMilliseconds / 1000,
          end: (phrase.offsetMilliseconds + 5000) / 1000,
          text: phrase.text,
          speaker: "speaker1"
        })),
        meta: {
          title: title,
          savedAt: new Date()
        }
      });
    }

    res.status(200).json({
      message: "转录结果保存成功",
      transcriptionId: transcription._id,
      episodeId: transcription.episodeId,
      status: transcription.status
    });
  } catch (error: any) {
    console.error("保存转录结果失败:", error);
    res.status(500).json({ 
      error: "保存转录结果失败",
      details: error.message 
    });
  }
}

/**
 * @route GET /api/transcriptions
 * @desc 获取当前用户的所有转录记录
 */
async function getUserTranscriptions(req: Request, res: Response) {
  try {
    // 从 auth middleware 设置的 req.user 中获取 userId
    const user = (req as any).user;
    if (!user) {
      res.status(401).json({ error: "Authentication required" });
      return;
    }
    const userId = user._id ? String(user._id) : user.id;

    // 查询该用户的所有转录记录
    const transcriptions = await Transcription.find({ userId })
      .sort({ createdAt: -1 }) // 按创建时间倒序排列
      .select('-__v') // 排除版本字段
      .lean(); // 返回普通对象而不是Mongoose文档

    // 格式化返回数据
    const formattedTranscriptions = transcriptions.map(transcription => ({
      id: transcription._id,
      episodeId: transcription.episodeId,
      audioUrl: transcription.audioUrl,
      status: transcription.status,
      resultText: transcription.resultText,
      rssUrl: transcription.rssUrl,
      sentences: transcription.sentences,
      createdAt: transcription.createdAt,
      updatedAt: transcription.updatedAt,
    }));

    res.status(200).json(formattedTranscriptions);
  } catch (error: any) {
    console.error("获取用户转录列表失败:", error);
    res.status(500).json({ error: "获取转录列表失败" });
  }
}

/**
 * @route GET /api/transcriptions/episode/:episodeId
 * @desc 通过episodeId获取转录记录
 */
async function getTranscriptionByEpisodeId(req: Request, res: Response) {
  try {
    const { episodeId } = req.params;
    
    // 从 auth middleware 设置的 req.user 中获取 userId
    const user = (req as any).user;
    if (!user) {
      res.status(401).json({ error: "Authentication required" });
      return;
    }
    const userId = user._id ? String(user._id) : user.id;

    // 查询该用户的该episode的转录记录
    const transcription = await Transcription.findOne({ 
      userId, 
      episodeId 
    }).lean();

    if (!transcription) {
      res.status(404).json({ 
        message: `No transcription found for episode ${episodeId}` 
      });
      return;
    }

    // 格式化返回数据
    const result = {
      id: transcription._id,
      episodeId: transcription.episodeId,
      status: transcription.status,
      resultText: transcription.resultText,
      sentences: transcription.sentences,
      phrases: formatSentencesToPhrases(transcription.sentences, transcription.resultText),
      createdAt: transcription.createdAt,
      updatedAt: transcription.updatedAt,
    };

    res.status(200).json(result);
  } catch (error: any) {
    console.error("获取转录记录失败:", error);
    res.status(500).json({ 
      error: "获取转录记录失败",
      details: error.message 
    });
  }
}

/**
 * @route GET /api/transcriptions/:id
 * @desc 获取单个转写任务详情（mock，后续会改为查询数据库） // 目前为 mock，后续将查询数据库【待验证】
 */
async function getTranscriptionById(req: Request, res: Response) {
  const id = req.params.id;
  // TODO: 以后将调用数据库查询转写任务详情
  const result = await transcriptionService.getTranscriptionById(id);

  res.status(201).json(result);
}

/**
 * @route GET /api/transcriptions/audio-proxy
 * @desc 音频代理端点 - 解决CORS问题
 */
async function audioProxy(req: Request, res: Response) {
  const audioUrl = req.query.url as string;
  
  if (!audioUrl) {
    return res.status(400).json({ error: "Missing audio URL parameter" });
  }

  try {
    const response = await axios.get(audioUrl, {
      responseType: 'stream',
      timeout: 30000, // 30秒超时
    });

    // 设置正确的响应头
    res.set({
      'Content-Type': response.headers['content-type'] || 'audio/mpeg',
      'Content-Length': response.headers['content-length'],
      'Cache-Control': 'public, max-age=3600', // 缓存1小时
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET',
      'Access-Control-Allow-Headers': 'Content-Type',
    });

    response.data.pipe(res);
  } catch (error: any) {
    console.error('Audio proxy error:', error.message);
    res.status(500).json({ 
      error: 'Failed to proxy audio file',
      details: error.message 
    });
  }
}

// 路由注册 - 使用认证中间件和验证中间件
router.post("/", authMiddleware, validateAudioDuration, createTranscription);
router.post("/save", authMiddleware, saveTranscriptionResult); // 保存转录结果
router.get("/", authMiddleware, getUserTranscriptions); // 获取用户转录列表
router.get("/episode/:episodeId", authMiddleware, getTranscriptionByEpisodeId); // 通过episodeId获取转录记录
router.get("/audio-proxy", audioProxy); // 音频代理端点
router.get("/:id", getTranscriptionById);

export const transcriptionRoutes = router;
</file>

<file path="listenary-backend/src/modules/transcription/controller/transcriptionWebSocket.ts">
import type { Server as HttpServer } from "http";
import { WebSocketServer, WebSocket } from "ws";
import {
  startStreamTranscription,
  mapSentences,
  sentenceToClientPayload,
  buildExistingResponse,
} from "../service/transcriptionStreamService";
import type { ITranscription } from "../transcriptModel";
import type { SpeechmaticsSentence } from "../service/transcriptService";

interface StartMessage {
  action: "start";
  audioUrl: string;
  episodeId: string;
  rssUrl?: string;
  force?: boolean;
}

interface ClientSentencePayload {
  index: number;
  text: string;
  start: number;
  end: number;
  offsetMilliseconds: number;
  endOffsetMilliseconds: number;
}

interface MessageEnvelope<T = unknown> {
  type: string;
  data?: T;
  message?: string;
}

function safeSend(ws: WebSocket, payload: MessageEnvelope) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(payload));
  }
}

// buildExistingResponse, mapSentences and sentenceToClientPayload are provided
// by the transcriptionStreamService and imported at the top of this file.

export function setupTranscriptionWebSocket(server: HttpServer) {
  const wss = new WebSocketServer({ server, path: "/ws/transcriptions" });

  wss.on("connection", (ws) => {
    let hasStarted = false;
    let closedByServer = false;
    let hasErrored = false;

    safeSend(ws, { type: "ready" });

    function closeWithMessage(code: number, reason: string) {
      if (
        ws.readyState === WebSocket.CLOSING ||
        ws.readyState === WebSocket.CLOSED
      ) {
        return;
      }
      closedByServer = true;
      ws.close(code, reason);
    }

    function handleError(error: Error) {
      if (hasErrored) {
        return;
      }
      hasErrored = true;
      safeSend(ws, { type: "error", message: error.message });
      closeWithMessage(1011, "transcription-error");
    }

    ws.on("message", async (raw) => {
      if (hasStarted) {
        safeSend(ws, {
          type: "error",
          message: "Transcription already in progress for this connection.",
        });
        return;
      }

      let payload: StartMessage;
      try {
        payload = JSON.parse(raw.toString());
      } catch (err) {
        safeSend(ws, { type: "error", message: "Invalid JSON payload." });
        closeWithMessage(1003, "invalid-json");
        return;
      }

      if (payload.action !== "start") {
        safeSend(ws, { type: "error", message: "Unsupported action." });
        return;
      }

      const { audioUrl, episodeId, rssUrl, force } = payload;
      if (!audioUrl || !episodeId) {
        safeSend(ws, {
          type: "error",
          message:
            "audioUrl and episodeId are required to start transcription.",
        });
        closeWithMessage(1008, "missing-parameters");
        return;
      }

      hasStarted = true;

      // NOTE: We are not changing auth here. Controller currently uses a userId
      // value from elsewhere; keep a fallback hardcoded ID to preserve behavior.
      const userId = "65fd3a2b9f1c2a0012ab3456";

      safeSend(ws, { type: "started" });

      try {
        await startStreamTranscription(
          userId,
          episodeId,
          audioUrl,
          rssUrl || "",
          {
            onExisting({ transcription }) {
              safeSend(ws, {
                type: "existing",
                data: buildExistingResponse(transcription),
              });
              closeWithMessage(1000, "transcription-exists");
            },
            onSentence(sentence, index) {
              safeSend(ws, {
                type: "sentence",
                data: sentenceToClientPayload(sentence, index),
              });
            },
            onComplete({ transcription, result }) {
              safeSend(ws, {
                type: "complete",
                data: {
                  sentences: mapSentences(result.sentences),
                  fullText: result.fullText,
                },
              });
              closeWithMessage(1000, "transcription-complete");
            },
            onError(error) {
              handleError(error);
            },
          },
          Boolean(force)
        );
      } catch (error) {
        handleError(error as Error);
      }
    });

    ws.on("close", () => {
      if (!closedByServer && ws.readyState === WebSocket.CLOSING) {
        closedByServer = true;
      }
    });
  });
}

export type { ClientSentencePayload };
</file>

<file path="listenary-backend/src/modules/transcription/service/transcriptionStreamService.ts">
import { streamTranscription } from "./transcriptService";
import type { ITranscription } from "../transcriptModel";
import type { SpeechmaticsSentence } from "./transcriptService";
import {
  sentenceToClientPayload,
  mapSentences,
  buildExistingResponse,
} from "./transcriptService";

export { sentenceToClientPayload, mapSentences, buildExistingResponse };

export async function startStreamTranscription(
  userId: string,
  episodeId: string,
  audioUrl: string,
  rssUrl: string,
  handlers: {
    onExisting?: (payload: { transcription: ITranscription }) => void;
    onSentence?: (sentence: SpeechmaticsSentence, index: number) => void;
    onComplete?: (payload: {
      transcription: ITranscription;
      result: { sentences: SpeechmaticsSentence[]; fullText: string };
    }) => void;
    onError?: (err: Error) => void;
  },
  force = false
) {
  return streamTranscription(
    userId,
    episodeId,
    audioUrl,
    rssUrl,
    {
      onExisting({ transcription }) {
        handlers.onExisting?.({ transcription });
      },
      onSentence(sentence, index) {
        handlers.onSentence?.(sentence, index);
      },
      onComplete({ transcription, result }) {
        handlers.onComplete?.({ transcription, result });
      },
      onError(error) {
        handlers.onError?.(error);
      },
    },
    Boolean(force)
  );
}
</file>

<file path="listenary-backend/src/modules/transcription/service/transcriptService.ts">
// 	•	编写业务逻辑。
//	•	调用 Repository（数据库）或其他 Service。
import axios from "axios";
import WebSocket from "ws";
import dotenv from "dotenv";
import { Transcription, Sentence, ITranscription } from "../transcriptModel";

dotenv.config();

// export async function createTranscription(userId: string, rssUrl: string) {
//   return {
//     // 返回创建成功的转写任务信息（mock）
//     id: "mock-transcription-id-1 from service",
//     userId: userId,
//     rssUrl: rssUrl,
//     audioUrl: "https://example.com/audio.mp3",
//     status: "processing",
//   };
// }

export async function getTranscriptionById(id: string) {
  // 从数据库查找并返回标准化对象
  try {
    if (!id || !require("mongoose").isValidObjectId(id)) {
      return null;
    }

    const transcription = await Transcription.findById(id).exec();
    if (!transcription) return null;

    const obj = transcription.toObject({
      getters: true,
      versionKey: false,
    }) as any;
    return {
      id: String(obj._id),
      userId: obj.userId,
      rssUrl: obj.rssUrl,
      audioUrl: obj.audioUrl,
      status: obj.status,
      resultText: obj.resultText || "",
      sentences: obj.sentences || [],
      createdAt: obj.createdAt ? obj.createdAt.toISOString() : undefined,
      updatedAt: obj.updatedAt ? obj.updatedAt.toISOString() : undefined,
      meta: obj.meta,
    };
  } catch (err) {
    // 日志或进一步处理可在调用处完成
    throw err;
  }
}

//transcribe audio
type SpeechmaticsSentence = Pick<Sentence, "start" | "end" | "text">;

interface TranscriptionAggregation {
  sentences: SpeechmaticsSentence[];
  fullText: string;
}

interface TranscribeAudioOptions {
  onSentence?: (sentence: SpeechmaticsSentence, index: number) => void;
  onComplete?: (result: TranscriptionAggregation) => void;
  onError?: (error: Error) => void;
}

export async function transcribeAudio(
  audioUrl: string,
  options: TranscribeAudioOptions = {}
): Promise<TranscriptionAggregation> {
  const apiKey = process.env.MATICS_API_KEY;
  if (!apiKey) {
    throw new Error("MATICS_API_KEY missing");
  }

  return new Promise(function (resolve, reject) {
    const ws = new WebSocket("wss://eu2.rt.speechmatics.com/v2/", {
      headers: {
        Authorization: `Bearer ${apiKey}`,
      },
    });

    let lastSequenceNumber = -1;

    const sentenceEndRegex = /[.!?]["')\]]*$/;
    const sentences: SpeechmaticsSentence[] = [];
    const fullTextParts: string[] = [];
    let currentSentenceText = "";
    let currentSentenceStart: number | null = null;
    let currentSentenceEnd: number | null = null;
    let resolved = false;

    function toNumber(value: unknown): number | null {
      if (typeof value === "number") {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        return Number.isFinite(parsed) ? parsed : null;
      }
      return null;
    }

    function appendSegmentText(segment: string) {
      const trimmed = segment.trim();
      if (!trimmed) {
        return;
      }

      if (!currentSentenceText) {
        currentSentenceText = trimmed;
        return;
      }

      const lastChar = currentSentenceText[currentSentenceText.length - 1];
      const firstChar = trimmed[0];
      const noSpaceBefore = /[.,!?;:")\]]/;
      const needsSpace =
        lastChar &&
        !/\s/.test(lastChar) &&
        firstChar &&
        !/\s/.test(firstChar) &&
        !noSpaceBefore.test(firstChar);

      currentSentenceText += (needsSpace ? " " : "") + trimmed;
    }

    function finalizeSentence(endTime?: number | null) {
      const text = currentSentenceText.trim();
      if (!text) {
        currentSentenceText = "";
        currentSentenceStart = null;
        currentSentenceEnd = null;
        return;
      }

      const start = currentSentenceStart ?? 0;
      const effectiveEnd =
        typeof endTime === "number"
          ? endTime
          : currentSentenceEnd ?? currentSentenceStart ?? 0;

      const sentence: SpeechmaticsSentence = {
        start,
        end: effectiveEnd,
        text,
      };

      sentences.push(sentence);
      fullTextParts.push(text);
      console.log(
        `[Speechmatics] sentence #${
          sentences.length
        }: "${text}" (start=${start.toFixed(3)}s)`
      );

      if (options.onSentence) {
        options.onSentence(sentence, sentences.length - 1);
      }

      currentSentenceText = "";
      currentSentenceStart = null;
      currentSentenceEnd = null;
    }

    function resolveIfNeeded() {
      if (resolved) {
        return;
      }
      resolved = true;
      const fullText = fullTextParts.join(" ");
      const result: TranscriptionAggregation = { sentences, fullText };
      if (options.onComplete) {
        options.onComplete(result);
      }
      resolve(result);
    }

    ws.on("open", async function () {
      try {
        console.log("WebSocket connection opened");

        const startRecognition = {
          message: "StartRecognition",
          audio_format: {
            type: "file",
          },
          transcription_config: {
            language: "en",
            operating_point: "enhanced",
            output_locale: "en-US",
            max_delay: 1,
            punctuation_overrides: {
              permitted_marks: [".", ",", "!", "?"],
              sensitivity: 0.5,
            },
          },
        };
        ws.send(JSON.stringify(startRecognition));

        const response = await axios.get(audioUrl, { responseType: "stream" });
        const stream = response.data as NodeJS.ReadableStream;

        stream.on("data", function (chunk: Buffer) {
          lastSequenceNumber += 1;
          ws.send(chunk);
        });

        stream.on("end", function () {
          console.log("Audio stream ended");
          const endOfStream = {
            message: "EndOfStream",
            last_seq_no: Math.max(lastSequenceNumber, 0),
          };
          ws.send(JSON.stringify(endOfStream));
        });

        stream.on("error", function (err: Error) {
          ws.close();
          if (options.onError) {
            options.onError(err);
          }
          reject(err);
        });
      } catch (err) {
        ws.close();
        if (options.onError) {
          options.onError(err as Error);
        }
        reject(err as Error);
      }
    });

    ws.on("message", function (data) {
      try {
        const message = JSON.parse(data.toString());
        if (
          message.message === "AddTranscript" &&
          message.metadata?.transcript
        ) {
          const metadata = message.metadata as Record<string, unknown>;
          const transcriptSegment = String(metadata.transcript);
          const isFinal = metadata.is_final;

          if (isFinal === false) {
            // Skip partial updates; wait for final segments.
            return;
          }

          const segmentStart = toNumber(metadata.start_time);
          const segmentEnd = toNumber(metadata.end_time);

          if (currentSentenceStart === null && segmentStart !== null) {
            currentSentenceStart = segmentStart;
          }

          if (segmentEnd !== null) {
            currentSentenceEnd = segmentEnd;
          }

          appendSegmentText(transcriptSegment);

          if (sentenceEndRegex.test(transcriptSegment.trim())) {
            finalizeSentence(segmentEnd);
          }
        } else if (message.message === "EndOfTranscript") {
          console.log("Transcription completed");
          if (currentSentenceText.trim()) {
            finalizeSentence(currentSentenceEnd);
          }
          console.log(
            `[Speechmatics] full transcript: ${fullTextParts.join(" ")}`
          );
          resolveIfNeeded();
          ws.close();
        }
      } catch (err) {
        ws.close();
        if (options.onError) {
          options.onError(err as Error);
        }
        reject(err as Error);
      }
    });

    ws.on("error", function (err) {
      ws.close();
      if (options.onError) {
        options.onError(err as Error);
      }
      reject(err);
    });

    ws.on("close", function () {
      if (!resolved) {
        const error = new Error(
          "WebSocket closed before transcription completed"
        );
        if (options.onError) {
          options.onError(error);
        }
        reject(error);
      }
    });
  });
}

interface TranscriptionStreamCallbacks {
  onExisting?: (payload: {
    transcription: ITranscription;
    sentences: SpeechmaticsSentence[];
    fullText: string;
  }) => void;
  onSentence?: (sentence: SpeechmaticsSentence, index: number) => void;
  onComplete?: (payload: {
    transcription: ITranscription;
    result: TranscriptionAggregation;
  }) => void;
  onError?: (error: Error) => void;
}

export async function streamTranscription(
  userId: string,
  episodeId: string,
  audioUrl: string,
  rssUrl: string,
  callbacks: TranscriptionStreamCallbacks = {},
  force = false
): Promise<ITranscription> {
  let transcription = await Transcription.findOne({ userId, episodeId });

  let errorNotified = false;
  function notifyError(error: Error) {
    if (!errorNotified) {
      errorNotified = true;
      callbacks.onError?.(error);
    }
  }

  if (transcription && transcription.status === "done" && !force) {
    callbacks.onExisting?.({
      transcription,
      sentences: transcription.sentences || [],
      fullText: transcription.resultText || "",
    });
    return transcription;
  }

  if (!transcription) {
    transcription = new Transcription({
      userId,
      episodeId,
      audioUrl,
      rssUrl,
      status: "processing",
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  } else {
    transcription.audioUrl = audioUrl;
    transcription.rssUrl = rssUrl;
    transcription.status = "processing";
    transcription.updatedAt = new Date();
  }

  await transcription.save();

  try {
    const result = await transcribeAudio(audioUrl, {
      onSentence: callbacks.onSentence,
      onError: notifyError,
    });

    transcription.resultText = result.fullText;
    transcription.sentences = result.sentences;
    transcription.status = "done";
    transcription.updatedAt = new Date();

    await transcription.save();

    callbacks.onComplete?.({ transcription, result });
    return transcription;
  } catch (error) {
    transcription.status = "error";
    transcription.updatedAt = new Date();
    await transcription.save();

    notifyError(error as Error);
    throw error;
  }
}

/**
 * Create or get an existing transcription for a given user and episode.
 * If transcription exists and is done, return it.
 * Otherwise, create/update transcription, perform transcription, save result and return.
 */
export async function createOrGetTranscription(
  userId: string,
  episodeId: string,
  audioUrl: string,
  rssUrl: string,
  force = false
) {
  return streamTranscription(userId, episodeId, audioUrl, rssUrl, {}, force);
}

export type { SpeechmaticsSentence, TranscriptionAggregation };

// Formatting helpers used by HTTP and WS controllers
export function sentenceToClientPayload(
  sentence: SpeechmaticsSentence,
  index: number
) {
  const start = Number.isFinite(sentence.start) ? sentence.start : 0;
  const end = Number.isFinite(sentence.end) ? sentence.end : start;
  return {
    index,
    text: sentence.text,
    start,
    end,
    offsetMilliseconds: Math.round(start * 1000),
    endOffsetMilliseconds: Math.round(end * 1000),
  };
}

export function mapSentences(sentences: SpeechmaticsSentence[]) {
  return (sentences || []).map((s, i) => sentenceToClientPayload(s, i));
}

export function buildExistingResponse(transcription: ITranscription) {
  const sentences = Array.isArray(transcription.sentences)
    ? (transcription.sentences as SpeechmaticsSentence[])
    : [];
  return {
    sentences: mapSentences(sentences),
    fullText: transcription.resultText || "",
  };
}
</file>

<file path="listenary-backend/src/modules/transcription/transcriptModel.ts">
import mongoose, { Schema, Document, Model } from "mongoose";

// Sentence interface
export interface Sentence {
  start: number;
  end: number;
  text: string;
  speaker?: string;
}

export interface ITranscription extends Document {
  userId: mongoose.Types.ObjectId;
  episodeId: string;
  audioUrl: string;
  status: "pending" | "processing" | "done" | "error";
  resultText?: string;
  rssUrl?: string;
  meta?: object;
  sentences?: Sentence[];
  createdAt?: Date;
  updatedAt?: Date;
}

// Sentence schema
const sentenceSchema = new Schema<Sentence>(
  {
    start: { type: Number, required: true },
    end: { type: Number, required: true },
    text: { type: String, required: true },
    speaker: { type: String },
  },
  { _id: false }
);

const transcriptionSchema: Schema<ITranscription> = new Schema(
  {
    userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
    episodeId: { type: String, required: true },
    audioUrl: { type: String, required: true },
    status: {
      type: String,
      enum: ["pending", "processing", "done", "error"],
      default: "pending",
      required: true,
    },
    resultText: { type: String, default: "" },
    rssUrl: { type: String },
    meta: { type: Object },
    sentences: { type: [sentenceSchema] },
  },
  { timestamps: true }
);

transcriptionSchema.index({ userId: 1, episodeId: 1 }, { unique: true });

const Transcription: Model<ITranscription> = mongoose.model<ITranscription>(
  "Transcription",
  transcriptionSchema
);

export { Transcription };
</file>

<file path="listenary-backend/src/modules/translation/translateRoutes.ts">
import express, { Request, Response } from 'express';
import axios from 'axios';
import { validateTranslationText } from '../../middleware/validationMiddleware';

const router = express.Router();

// 翻译文本
router.post('/', validateTranslationText, async (req: Request, res: Response) => {
  try {
    const { text, target_lang, source_lang } = req.body;
    
    // 后端处理翻译限制逻辑
    const MAX_WORDS = 100;
    let totalWords = 0;
    const textsToTranslate = [];
    const skippedTexts = [];
    
    for (const textItem of text) {
      const words = textItem.split(/\s+/).length;
      if (totalWords + words > MAX_WORDS) {
        skippedTexts.push({
          text: textItem,
          reason: 'Due to API usage limits, only part of the text is translated for reference.'
        });
        continue;
      }
      totalWords += words;
      textsToTranslate.push(textItem);
    }
    
    const key = process.env.DEEPL_API_KEY;
    if (!key) return res.status(500).json({ error: 'DEEPL_API_KEY not set' });

    // 构建请求体，只有当source_lang存在且不是'auto'时才包含它
    const requestBody: any = { 
      text: textsToTranslate, 
      target_lang
    };
    
    // 只有当source_lang存在且不是'auto'时才添加source_lang参数
    if (source_lang && source_lang !== 'auto') {
      requestBody.source_lang = source_lang;
    }

    console.log('DeepL翻译请求:', requestBody);

    const r = await axios.post(
      'https://api-free.deepl.com/v2/translate',
      requestBody,
      {
        headers: {
          Authorization: `DeepL-Auth-Key ${key}`,
          'Content-Type': 'application/json',
        },
        timeout: 15000,
      }
    );
    
    // 返回翻译结果和跳过的文本
    res.json({
      ...r.data,
      skippedTexts: skippedTexts,
      totalWords: totalWords,
      maxWords: MAX_WORDS
    });
  } catch (e: any) {
    console.error('DeepL翻译错误:', e.response?.data || e.message);
    res.status(e.response?.status || 500).json({
      error: 'Translation failed',
      details: e.response?.data || e.message,
    });
  }
});

// 获取支持的语言列表
router.get('/languages', async (req: Request, res: Response) => {
  try {
    const key = process.env.DEEPL_API_KEY;
    if (!key) return res.status(500).json({ error: 'DEEPL_API_KEY not set' });

    const r = await axios.get(
      'https://api-free.deepl.com/v2/languages?type=target',
      {
        headers: {
          Authorization: `DeepL-Auth-Key ${key}`,
        },
        timeout: 10000,
      }
    );
    res.json(r.data);
  } catch (e: any) {
    res.status(e.response?.status || 500).json({
      error: 'Failed to get languages',
      details: e.response?.data || e.message,
    });
  }
});

// 检测语言
router.post('/detect', async (req: Request, res: Response) => {
  try {
    const { text } = req.body;
    if (!text) {
      return res.status(400).json({ error: 'Missing text' });
    }
    const key = process.env.DEEPL_API_KEY;
    if (!key) return res.status(500).json({ error: 'DEEPL_API_KEY not set' });

    const r = await axios.post(
      'https://api-free.deepl.com/v2/translate',
      { 
        text: [text], 
        target_lang: 'EN' // 临时目标语言，我们只需要检测源语言
      },
      {
        headers: {
          Authorization: `DeepL-Auth-Key ${key}`,
          'Content-Type': 'application/json',
        },
        timeout: 10000,
      }
    );
    
    // 返回检测到的语言
    res.json({
      detected_source_language: r.data.translations[0]?.detected_source_language || 'unknown'
    });
  } catch (e: any) {
    res.status(e.response?.status || 500).json({
      error: 'Language detection failed',
      details: e.response?.data || e.message,
    });
  }
});

export { router as translateRoutes };
</file>

<file path="listenary-backend/src/modules/user&wordlist/controllers/authController.ts">
// src/modules/user/controllers/authController.ts
// 此控制器已废弃 - 现在使用Firebase认证
import { Request, Response, NextFunction, Router } from "express";

export const registerUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  res.status(410).json({
    success: false,
    error: {
      code: "DEPRECATED",
      message: "此功能已废弃，请使用Firebase认证"
    }
  });
};

export const loginUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  res.status(410).json({
    success: false,
    error: {
      code: "DEPRECATED", 
      message: "此功能已废弃，请使用Firebase认证"
    }
  });
};

// 路由注册并导出，保持与项目中其他 controller 的风格一致
const router = Router();
router.post("/register", registerUser);
router.post("/login", loginUser);

export const authRoutes = router;
</file>

<file path="listenary-backend/src/modules/user&wordlist/controllers/userController.ts">
// src/modules/user/controllers/userController.ts
import { Request, Response, NextFunction, Router } from 'express';
import * as userService from '../services/userService';
import { authMiddleware } from '../../../middleware/authMiddleware';

/**
 * 处理获取用户个人资料的 HTTP 请求
 * 现在返回Firebase用户信息 + MongoDB业务数据
 */
export const getUserProfile = (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!(req as any).firebaseUser || !req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    // 返回Firebase用户信息 + MongoDB业务数据
    res.status(200).json({
      // Firebase用户信息（用于显示）
      id: (req as any).firebaseUser.uid,
      email: (req as any).firebaseUser.email,
      displayName: (req as any).firebaseUser.displayName,
      photoURL: (req as any).firebaseUser.photoURL,
      email_verified: (req as any).firebaseUser.email_verified,
      authProvider: 'firebase',
      
      // MongoDB业务数据
      preferences: req.user.preferences,
      wordlistCount: req.user.wordlist.length,
      savedPodcastsCount: req.user.savedPodcasts.length,
      createdAt: (req.user as any).createdAt,
      updatedAt: (req.user as any).updatedAt
    });
  } catch (error) {
    next(error);
  }
};

/**
 * 处理获取用户单词本的 HTTP 请求
 */
export const getWordlist = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    // 直接返回MongoDB中的单词本数据
    res.status(200).json(req.user.wordlist);
  } catch (error) {
    next(error);
  }
};

/**
 * 处理向单词本添加单词的 HTTP 请求
 */
export const addWordToWordlist = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    const updatedWordlist = await userService.addWordToUserWordlist(req.user, req.body);
    res.status(201).json(updatedWordlist);
  } catch (error) {
    next(error);
  }
};

/**
 * 处理从单词本删除单词的 HTTP 请求
 */
export const deleteWordFromWordlist = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    const { wordText } = req.params;
    const updatedWordlist = await userService.deleteWordFromUserWordlist(req.user, wordText);
    res.status(200).json(updatedWordlist);
  } catch (error) {
    next(error);
  }
};

/**
 * 处理获取收藏播客列表的 HTTP 请求
 */
export const getSavedPodcasts = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    // 直接返回MongoDB中的收藏播客数据
    res.status(200).json(req.user.savedPodcasts);
  } catch (error) {
    next(error);
  }
};

/**
 * 处理添加播客到收藏的 HTTP 请求
 */
export const addSavedPodcast = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    const updatedPodcasts = await userService.addPodcastToSaved(req.user, req.body);
    res.status(201).json(updatedPodcasts);
  } catch (error) {
    next(error);
  }
};

/**
 * 处理从收藏中删除播客的 HTTP 请求
 */
export const removeSavedPodcast = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // 检查用户认证状态
    if (!req.user) {
      const error = new Error('用户未找到');
      (error as any).statusCode = 404;
      throw error;
    }
    
    const { podcastTitle } = req.params;
    const updatedPodcasts = await userService.removePodcastFromSaved(req.user, podcastTitle);
    res.status(200).json(updatedPodcasts);
  } catch (error) {
    next(error);
  }
};

// 路由注册
const router = Router();

// 使用认证中间件
router.use(authMiddleware);

// 定义具体的路由
// GET /api/user/profile -> 获取登录用户的个人资料
router.get('/profile', getUserProfile);

// GET /api/user/wordlist -> 获取用户的单词本
router.get('/wordlist', getWordlist);

// POST /api/user/wordlist -> 向用户单词本添加一个新单词
router.post('/wordlist', addWordToWordlist);

// DELETE /api/user/wordlist/:wordText -> 从单词本删除单词
router.delete('/wordlist/:wordText', deleteWordFromWordlist);

// GET /api/user/saved-podcasts -> 获取收藏的播客列表
router.get('/saved-podcasts', getSavedPodcasts);

// POST /api/user/saved-podcasts -> 添加播客到收藏
router.post('/saved-podcasts', addSavedPodcast);

// DELETE /api/user/saved-podcasts/:podcastTitle -> 从收藏中删除播客
router.delete('/saved-podcasts/:podcastTitle', removeSavedPodcast);

export const userRoutes = router;
</file>

<file path="listenary-backend/src/modules/user&wordlist/models/User.ts">
// src/modules/user/models/User.ts

import mongoose, { Document, Model, Schema, Types } from "mongoose";
import bcrypt from "bcryptjs";

// 定义 word 子文档的 TypeScript 接口
interface IWord extends Types.Subdocument {
  word: string;
  phonetic?: string;
  phonetics?: object[];
  meanings?: object[];
}

// 定义 podcast 子文档的 TypeScript 接口
interface IPodcast extends Types.Subdocument {
  title: string;
  rssUrl: string;
  coverImage?: string;
  description?: string;
}

// 定义 User 文档的 TypeScript 接口，它扩展了 Mongoose 的 Document
export interface IUser extends Document {
  // _id 属性已由 Document 提供
  firebaseUid: string; // Firebase UID，用于关联Firebase认证用户（必需）
  // 移除重复字段 - 这些信息从Firebase获取
  // email: string;        // 删除 - Firebase已有
  // password?: string;    // 删除 - 使用Firebase认证
  // displayName?: string; // 删除 - Firebase已有
  
  // 只保留业务数据
  wordlist: Types.DocumentArray<IWord>;
  savedPodcasts: Types.DocumentArray<IPodcast>;
  preferences?: {
    language?: string;
    theme?: string;
    notifications?: boolean;
  };
  
  // 为实例方法也提供类型定义
  matchPassword(enteredPassword: string): Promise<boolean>;
}

// word 子文档的 Mongoose Schema
const wordSchema = new Schema<IWord>(
  {
    word: { type: String, required: true },
    phonetic: String,
    phonetics: [Object],
    meanings: [Object],
  },
  { _id: false }
);

// podcast 子文档的 Mongoose Schema
const podcastSchema = new Schema<IPodcast>(
  {
    title: { type: String, required: true },
    rssUrl: { type: String, required: true },
    coverImage: String,
    description: String,
  },
  { _id: false }
);

// User 文档的主 Mongoose Schema
const userSchema = new Schema<IUser>(
  {
    firebaseUid: {
      type: String,
      required: [true, "Firebase UID is required"],
      unique: true,
      index: true, // 添加索引提高查询性能
    },
    // 移除重复字段 - 这些信息从Firebase获取
    // email: 删除 - Firebase已有
    // password: 删除 - 使用Firebase认证
    // displayName: 删除 - Firebase已有
    
    // 只保留业务数据
    wordlist: {
      type: [wordSchema],
      default: [],
    },
    savedPodcasts: {
      type: [podcastSchema],
      default: [],
    },
    preferences: {
      language: { type: String, default: 'en' },
      theme: { type: String, default: 'light' },
      notifications: { type: Boolean, default: true },
    },
  },
  {
    timestamps: true,
  }
);

// 移除密码相关中间件和方法，因为使用Firebase认证
// 不再需要密码加密和验证逻辑

// 将 Schema 编译成 Model
const User: Model<IUser> = mongoose.model<IUser>("User", userSchema);

export default User;
</file>

<file path="listenary-backend/src/modules/user&wordlist/services/authService.ts">
// src/modules/user&wordlist/services/authService.ts
// 此文件已废弃 - 现在使用Firebase认证
// 所有认证逻辑已移至统一认证中间件

// 保留文件以避免导入错误，但所有函数都已废弃
export const register = async () => {
  throw new Error('此功能已废弃，请使用Firebase认证');
};

export const login = async () => {
  throw new Error('此功能已废弃，请使用Firebase认证');
};
</file>

<file path="listenary-backend/src/modules/user&wordlist/services/userService.ts">
// src/modules/user/services/userService.ts
import { IUser } from '../models/User';

// 现在直接使用MongoDB用户对象，不再需要Firebase用户类型

/**
 * 获取用户的单词本
 * @param user - MongoDB用户对象
 * @returns {Promise<Array>} - 用户的单词本数组
 */
export const getWordlistForUser = async (user: IUser): Promise<any[]> => {
  if (!user) {
    throw new Error('用户未找到');
  }

  console.log('获取单词本 - 用户ID:', user._id);
  return user.wordlist || [];
};

/**
 * 向用户的单词本添加一个新单词
 * @param user - MongoDB用户对象
 * @param wordData - 要添加的单词数据
 * @returns {Promise<Array>} - 更新后的单词本数组
 */
export const addWordToUserWordlist = async (user: IUser, wordData: any): Promise<any[]> => {
  if (!user) {
    throw new Error('用户未找到');
  }

  console.log('添加单词 - 用户ID:', user._id, '单词:', wordData.word);
  
  // 检查单词是否已存在
  const wordExists = user.wordlist.find(item => item.word === wordData.word);
  if (wordExists) {
    const error = new Error('这个单词已经存在于你的单词本中');
    (error as any).statusCode = 400;
    throw error;
  }
  
  // 添加新单词到MongoDB
  user.wordlist.push(wordData);
  await user.save();
  console.log('单词添加成功，当前单词本数量:', user.wordlist.length);
  
  return user.wordlist;
};

/**
 * 从用户的单词本删除一个单词
 * @param user - MongoDB用户对象
 * @param wordText - 要删除的单词文本
 * @returns {Promise<Array>} - 更新后的单词本数组
 */
export const deleteWordFromUserWordlist = async (user: IUser, wordText: string): Promise<any[]> => {
  if (!user) {
    throw new Error('用户未找到');
  }

  console.log('删除单词 - 用户ID:', user._id, '单词:', wordText);

  const originalLength = user.wordlist.length;
  user.wordlist = user.wordlist.filter(item => item.word !== wordText) as any;
  
  if (user.wordlist.length === originalLength) {
    const error = new Error('单词不存在于单词本中');
    (error as any).statusCode = 404;
    throw error;
  }

  await user.save();
  console.log('单词删除成功，当前单词本数量:', user.wordlist.length);
  
  return user.wordlist;
};

/**
 * 获取用户收藏的播客列表
 */
export const getSavedPodcasts = async (user: IUser): Promise<any[]> => {
  if (!user) {
    throw new Error('用户未找到');
  }

  console.log('获取收藏播客 - 用户ID:', user._id);
  return user.savedPodcasts || [];
};

/**
 * 添加播客到收藏
 */
export const addPodcastToSaved = async (user: IUser, podcastData: any): Promise<any[]> => {
  if (!user) {
    throw new Error('用户未找到');
  }

  console.log('添加播客到收藏 - 用户ID:', user._id, '播客:', podcastData.title);

  // 检查播客是否已存在
  const podcastExists = user.savedPodcasts.find(
    (item: any) => item.title === podcastData.title || item.rssUrl === podcastData.rssUrl
  );
  
  if (podcastExists) {
    const error = new Error('这个播客已经在你的收藏中');
    (error as any).statusCode = 400;
    throw error;
  }

  user.savedPodcasts.push(podcastData);
  await user.save();
  console.log('播客添加成功:', podcastData.title);
  
  return user.savedPodcasts;
};

/**
 * 从收藏中删除播客
 */
export const removePodcastFromSaved = async (user: IUser, podcastTitle: string): Promise<any[]> => {
  if (!user) {
    throw new Error('用户未找到');
  }

  console.log('从收藏删除播客 - 用户ID:', user._id, '播客:', podcastTitle);

  const originalLength = user.savedPodcasts.length;
  user.savedPodcasts = user.savedPodcasts.filter(
    (item: any) => item.title !== podcastTitle
  ) as any;
  
  if (user.savedPodcasts.length === originalLength) {
    const error = new Error('播客不存在于收藏中');
    (error as any).statusCode = 404;
    throw error;
  }

  await user.save();
  console.log('播客删除成功:', podcastTitle);
  
  return user.savedPodcasts;
};

// 移除不再需要的createMongoUserFromFirebase函数
// 用户创建现在由统一认证中间件处理
</file>

<file path="listenary-backend/src/types/express/index.d.ts">
// src/types/express/index.d.ts

// 从您的 User 模型中导入 IUser 接口
import { IUser } from '../../modules/user&wordlist/models/User';

// 使用 declare global 来扩展全局模块
declare global {
  // 扩展 Express 的命名空间
  namespace Express {
    // 扩展 Request 接口
    interface Request {
      // 添加 user 属性，它的类型是 IUser 或者可能为 null
      // 定义为可选（?）是因为并非所有请求都经过 authMiddleware
      user?: IUser | null;
      
      // 添加 firebaseUser 属性，用于存储Firebase用户信息
      firebaseUser?: {
        uid: string;
        email?: string;
        displayName?: string;
        photoURL?: string;
        email_verified?: boolean;
      };
    }
  }
}
</file>

<file path="listenary-backend/src/server.ts">
// src/server.ts

import express, { Request, Response } from "express";
import { createServer } from "http";
import cors from "cors";
import mongoose from "mongoose"; // 1. 新增：导入 mongoose
import helmet from "helmet";
import rateLimit from "express-rate-limit";
import dotenv from "dotenv";
import { rssRoutes } from "./modules/rss/controller";

// 确保在所有其他代码之前加载环境变量
dotenv.config();

// --- 导入所有路由 ---
import { translateRoutes } from "./modules/translation/translateRoutes";
import { authRoutes } from "./modules/user&wordlist/controllers/authController";
import { userRoutes } from "./modules/user&wordlist/controllers/userController";
import { podcastRoutes } from "./modules/podcast-discovery/podcastController";
import { dictionaryRoutes } from "./modules/dictionary/dictionaryController";
import { transcriptionRoutes } from "./modules/transcription/controller/transcriptController";
import { setupTranscriptionWebSocket } from "./modules/transcription/controller/transcriptionWebSocket";

// --- 导入错误处理中间件 ---
import { notFound, errorHandler } from "./middleware/errorMiddleware";

const app = express();
const server = createServer(app);
const port = process.env.PORT || 3000;

// --- 全局中间件配置 (按正确顺序) ---

// 1. 安全中间件
app.use(helmet());
app.use(cors()); // 启用基本的 CORS，你可以根据需要配置 whitelist

// 2. 核心功能中间件
app.use(express.json()); // 解析 JSON 请求体

// 3. 限流中间件 (可选)
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 200, // 每个IP在15分钟内最多200次请求
  message: "Too many requests from this IP, please try again after 15 minutes",
});
app.use("/api", limiter); // 只对 /api/ 路径下的请求应用限流

//mounting rss router
app.use("/api/rss", rssRoutes);

// --- 路由组装 (必须在中间件配置之后，错误处理之前) ---

// 根路径和健康检查
app.get("/", (req: Request, res: Response) => {
  res.send("Listenary TypeScript Backend API is running...");
});
app.get("/healthz", (_: Request, res: Response) => res.send("ok"));

// 挂载不同模块的路由
app.use("/api/auth", authRoutes); // 处理 /api/auth/* 的请求
app.use("/api/user", userRoutes); // 处理 /api/user/* 的请求
app.use("/api/transcriptions", transcriptionRoutes); // 未来处理 /api/transcriptions/*

app.use("/api/podcasts", podcastRoutes); // 处理 /api/podcasts/* 的请求
app.use("/api/dictionary", dictionaryRoutes);
app.use("/api/translate", translateRoutes);

// --- 错误处理中间件 (必须在所有路由之后) ---
// 3. 只保留一组错误处理器
app.use(notFound); // 捕获 404 错误
app.use(errorHandler); // 统一处理所有其他错误

// --- 数据库连接 & 启动服务器 ---
const MONGO_URI = process.env.MONGO_URI as string;

if (!MONGO_URI) {
  console.error("Fatal Error: MONGO_URI is not defined in the .env file.");
  process.exit(1);
}

// 4. 将数据库连接和服务器启动逻辑整合在一起
setupTranscriptionWebSocket(server);

mongoose
  .connect(MONGO_URI, { dbName: "listenary" })
  .then(() => {
    console.log("Successfully connected to MongoDB!");
    server.listen(port, () => {
      console.log(`Backend server is running on http://localhost:${port}`);
    });
  })
  .catch((error) => {
    console.error("Database connection failed:", error);
    process.exit(1);
  });
</file>

<file path="listenary-backend/.dockerignore">
# listenary-backend/.dockerignore

node_modules
npm-debug.log
.env
Dockerfile
.dockerignore
dist

#src
</file>

<file path="listenary-backend/docker-compose.yml">
# listenary-backend/docker-compose.yml

# 'services' 是核心部分，在这里定义我们项目的所有服务（容器）
services:
  # --- 1. 我们的 Node.js/Express 应用服务 ---
  app:
    # 'build: .' 告诉 Docker Compose, 请使用当前目录下的 Dockerfile
    # 来构建这个服务的镜像。
    build: .

    # 'ports' 用于将你电脑的端口映射到容器的内部端口。
    ports:
      - "3000:3000"

    # 'env_file' 会读取指定的 .env 文件，并将其中的变量注入到容器中。
    # 这让我们可以方便地在本地开发时使用 .env 文件来管理密钥。
    env_file:
      - ./.env

    # 'environment' 用于向容器内部注入额外的环境变量。
    environment:
      # 【关键】这里定义了数据库的连接地址。
      # 'db' 是我们在下面定义的 MongoDB 服务的名称。
      # Docker Compose 的内部网络会让 'app' 容器能够通过 'db' 这个名字找到数据库容器。
      MONGO_URI: mongodb://db:27017/listenary
      # 设置 Node.js 环境为开发模式
      NODE_ENV: development

    # 'depends_on' 定义了服务启动的依赖关系。
    # 这确保了 'db' 服务（数据库）会先于 'app' 服务（我们的应用）启动。
    depends_on:
      - db

  # --- 2. 我们的 MongoDB 数据库服务 ---
  db:
    # 'image: mongo:latest' 告诉 Docker Compose, 直接从 Docker Hub
    # 拉取官方最新版本的 MongoDB 镜像。
    image: mongo:latest

    # 'ports' 是可选的，但对于开发非常有用。
    # 让你能用 MongoDB Compass 等图形化工具，通过 localhost:27017 直接连接到 Docker 里的数据库。
    ports:
      - "27017:27017"

    # 'volumes' 用于数据的持久化，这是极其重要的一步。
    # 它将容器内部的 /data/db 目录映射到一个名为 'mongo-data' 的 Docker 卷上。
    volumes:
      - mongo-data:/data/db

# 'volumes' 的顶层声明，用于定义具名卷。
# 这样做的好处是，即使你删除了 'db' 容器，数据也不会丢失。
volumes:
  mongo-data:
</file>

<file path="listenary-backend/Dockerfile">
# listenary-backend/Dockerfile

# --- Stage 1: Build Stage (构建阶段) ---
# 使用一个包含完整 TypeScript 工具链的 Node.js 镜像作为构建环境。
# 我们给这个阶段命名为 "builder"，以便后续引用。
FROM node:20 AS builder

# 在容器内部设置工作目录为 /app。
WORKDIR /app

# 复制 package.json 和 package-lock.json 文件。
# 这样做是为了利用 Docker 的层缓存机制：只要这两个文件不改变，
# 下一步的 npm install 就可以使用缓存，从而极大地加快构建速度。
COPY package*.json ./

# 安装所有依赖，包括构建 TypeScript 所需的 devDependencies。
RUN npm install

# 复制项目中的所有其他文件（源代码、配置文件等）。
COPY . .

# 【关键步骤】运行 package.json 中定义的 "build" 脚本。
# 这会调用 TypeScript 编译器 (tsc)，将 src/ 目录下的 .ts 文件
# 编译成 Node.js 能运行的 .js 文件，并输出到 dist/ 目录。
RUN npm run build


# --- Stage 2: Production Stage (生产阶段) ---
# 使用一个更轻量的 Node.js 镜像 (slim 版本) 作为最终的运行环境，以减小镜像体积。
FROM node:20-slim

# 同样设置工作目录。
WORKDIR /app

# 从 'builder' 阶段，只复制生产环境必需的文件。
COPY --from=builder /app/package*.json ./

# 【关键优化】只安装生产环境所需的依赖 (dependencies)，忽略 devDependencies。
# 这能显著减小最终镜像的大小，并提高安全性。
RUN npm install --production

# 从 'builder'  阶段，只复制编译后的 JavaScript 代码 (dist/ 目录)。
# 我们不需要将原始的 .ts 源代码包含在最终的生产镜像中。
COPY --from=builder /app/dist ./dist

# 声明容器内的应用将会监听 3000 端口。
# 这主要是一个元数据声明，方便使用者和平台了解容器的网络配置。
EXPOSE 3000

# 定义容器启动时要执行的默认命令。
# ["npm", "start"] 会执行 package.json 中 "scripts" 下的 "start" 脚本,
# 也就是 "node dist/server.js"，从而运行我们编译后的应用。
CMD [ "npm", "start" ]
</file>

<file path="listenary-backend/package.json">
{
  "name": "listenary-backend",
  "version": "1.0.0",
  "description": "Backend server for Listenary, written in TypeScript.",
  "main": "dist/server.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "axios": "^1.7.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.5.1",
    "firebase-admin": "^13.5.0",
    "helmet": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.4.1",
    "rss-parser": "^3.13.0",
    "ws": "^8.18.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.2",
    "@types/ws": "^8.18.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="listenary-backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    // 新增：让 TS 认识 "@/..." 指向 src 下的路径
    "baseUrl": "./src",
    "paths": {
      "@/*": ["*"]
    },


    "typeRoots": [
      "./src/types",
      "./node_modules/@types"
    ]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/api/dictionaryAPI.tsx">
// src/api/dictionaryAPI.tsx
// 字典相关的 API 调用，使用后端代理

import { API_BASE_URL, apiRequest } from '../config/apiConfig';

export const DictionaryAPI = {
    async getWord(word) {
        try {
            console.log(`查询字典单词: ${word}`);
            const response = await apiRequest(`/api/dictionary/${word}`, {
                method: 'GET',
            });
            
            if (!response.ok) {
                if (response.status === 404) {
                    console.log(`单词 "${word}" 未找到`);
                    return null; // 词汇不存在
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log(`字典查询成功 - 单词: ${word}`, data);
            return data;
        } catch (error) {
            console.error(`字典查询失败 - 单词: ${word}`, error);
            return null;
        }
    }
}
</file>

<file path="src/api/transcriptionAPI.tsx">
// src/api/transcriptionAPI.tsx
// 转录相关的 API 调用，替换 Firebase Firestore 操作
// 使用 Firebase Auth token 进行认证

import { API_BASE_URL, authenticatedApiRequest } from '../config/apiConfig';

/**
 * 保存转录数据到 MongoDB
 */
export async function saveTranscriptionData(
  episodeId: string,
  title: string,
  phrases: any[]
) {
  try {
    console.log(`保存转录数据 - Episode: ${episodeId}, 短语数量: ${phrases.length}`);
    
    const response = await authenticatedApiRequest('/api/transcriptions/save', {
      method: 'POST',
      body: JSON.stringify({
        episodeId,
        title,
        phrases,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('保存转录数据失败:', {
        status: response.status,
        statusText: response.statusText,
        error: errorData
      });
      throw new Error(`保存转录数据失败: ${errorData.error || response.statusText}`);
    }

    const result = await response.json();
    console.log('转录数据保存成功:', result);
    return result;
  } catch (error) {
    console.error('保存转录数据异常:', error);
    throw error;
  }
}

/**
 * 静默检查转录数据是否存在（不显示404错误）
 */
export async function checkTranscriptionExists(episodeId: string): Promise<boolean> {
  try {
    // 先获取用户的所有转录记录
    const response = await authenticatedApiRequest('/api/transcriptions', {
      method: 'GET',
    });

    if (!response.ok) {
      return false;
    }

    const transcriptions = await response.json();
    // 检查是否有匹配的episodeId
    return transcriptions.some((t: any) => t.episodeId === episodeId);
  } catch (error) {
    return false;
  }
}

/**
 * 获取转录数据（只在确认存在时调用）
 */
export async function getTranscriptionData(episodeId: string) {
  try {
    const response = await authenticatedApiRequest(
      `/api/transcriptions/episode/${episodeId}`,
      {
        method: 'GET',
      }
    );

    if (!response.ok) {
      if (response.status === 404) {
        // 404是正常情况，静默处理
        return []; // 没有找到转录数据，返回空数组
      }
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`获取转录数据失败: ${errorData.error || response.statusText}`);
    }

    const data = await response.json();
    console.log(`转录数据获取成功 - Episode: ${episodeId}`);
    return data.phrases || data.sentences || [];
  } catch (error) {
    // 只有在非404错误时才记录
    if (!error.message.includes('404')) {
      console.error(`获取转录数据异常 - Episode: ${episodeId}`, error);
    }
    return [];
  }
}

/**
 * 创建新的转录任务
 */
export async function createTranscriptionTask(params: {
  audioUrl: string;
  episodeId: string;
  rssUrl?: string;
  force?: boolean;
}) {
  try {
    console.log(`创建转录任务 - Episode: ${params.episodeId}`);
    
    const response = await authenticatedApiRequest('/api/transcriptions', {
      method: 'POST',
      body: JSON.stringify(params),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`创建转录任务失败: ${errorData.error || response.statusText}`);
    }

    const data = await response.json();
    console.log(`转录任务创建成功 - Episode: ${params.episodeId}`, data);
    return data;
  } catch (error) {
    console.error(`创建转录任务异常 - Episode: ${params.episodeId}`, error);
    throw error;
  }
}

/**
 * 获取用户的所有转录记录
 */
export async function getUserTranscriptions() {
  const response = await authenticatedApiRequest('/api/transcriptions', {
    method: 'GET',
  });

  if (!response.ok) {
    throw new Error('获取转录列表失败');
  }

  return response.json();
}

/**
 * 删除转录数据
 */
export async function deleteTranscriptionData(episodeId: string) {
  const response = await authenticatedApiRequest(
    `/api/transcriptions/${episodeId}`,
    {
      method: 'DELETE',
    }
  );

  if (!response.ok) {
    throw new Error('删除转录数据失败');
  }

  return response.json();
}

/**
 * 语音转文字功能 (兼容旧接口)
 */
export async function speechToText(params: {
  audioUrl: string;
  episodeId: string;
  rssUrl?: string;
  duration?: number;
}) {
  const { audioUrl, episodeId, rssUrl, duration } = params;
  if (!audioUrl || !episodeId) {
    return Promise.reject(new Error("audioUrl and episodeId are required"));
  }

  return apiRequest('/api/transcriptions', {
    method: "POST",
    body: JSON.stringify({
      audioUrl,
      episodeId,
      rssUrl,
      duration,
    }),
  }).then(function (response) {
    if (!response.ok) {
      const errorData = response.json().catch(() => ({}));
      if (response.status === 400) {
        return errorData.then((data: any) => {
          if (data.code === 'AUDIO_TOO_LONG') {
            throw new Error(data.error);
          }
          throw new Error(`Transcription API failed: ${response.status}`);
        });
      }
      throw new Error(`Transcription API failed: ${response.status}`);
    }
    return response.json();
  });
}
</file>

<file path="src/api/TranslationAPI.tsx">
import { useState } from "react";

import { apiRequest } from '../config/apiConfig';

export default function TranslationAPI({ textToTranslate, targetLang, onTranslationComplete }){
    // 使用统一的API配置
    const API_URL = "/api/translate";

    const translate = async function() {
        if (!textToTranslate || !targetLang) return '';
        
        try {
            // 确保textToTranslate是数组格式
            const texts = Array.isArray(textToTranslate) ? textToTranslate : [textToTranslate];
            
            const response = await apiRequest(API_URL, {
                method: "POST",
                body: JSON.stringify({
                text: texts, // 后端要求 text 是字符串数组
                target_lang: targetLang,
                }),
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Translation request failed:', {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                });
                throw new Error(`Translation failed with status: ${response.status}`);
            }

            const data = await response.json();
            
            if (onTranslationComplete) {
                onTranslationComplete(data);
            }
            
            // 如果是单个文本，返回第一个翻译结果
            if (Array.isArray(textToTranslate) && textToTranslate.length === 1) {
                return data.translations[0].text;
            }
            
            return data;
        } catch (error) {
            console.error('Translation error:', error);
            // Add retry logic
            if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                console.log('Retrying translation...');
                // Wait 1 second before retry
                await new Promise(function(resolve) {
                    setTimeout(resolve, 1000);
                });
                return translate();
            }
            return '';
        }
    };

    return { translate };
}
</file>

<file path="src/api/userAPI.tsx">
// src/api/userAPI.tsx
// 用户相关的 API 调用，替换 Firebase Firestore 操作
// 使用 Firebase Auth token 进行认证

import { authenticatedApiRequest } from '../config/apiConfig';

/**
 * 获取用户资料
 */
export async function getUserProfile() {
  const response = await authenticatedApiRequest('/api/user/profile', {
    method: 'GET',
  });

  if (!response.ok) {
    throw new Error('获取用户资料失败');
  }

  return response.json();
}

/**
 * 保存用户数据（username, savedPodcasts）
 */
export async function saveUserData(data: { 
  displayName?: string; 
  savedPodcasts?: any[] 
}) {
  const response = await authenticatedApiRequest('/api/user/profile', {
    method: 'PUT',
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    throw new Error('保存用户数据失败');
  }

  return response.json();
}

/**
 * 获取用户单词本
 */
export async function getUserWordlist() {
  const response = await authenticatedApiRequest('/api/user/wordlist', {
    method: 'GET',
  });

  if (!response.ok) {
    throw new Error('获取单词本失败');
  }

  return response.json();
}

/**
 * 添加单词到单词本
 */
export async function saveWordToUserWordlist(wordData: any) {
  const response = await authenticatedApiRequest('/api/user/wordlist', {
    method: 'POST',
    body: JSON.stringify(wordData),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || '保存单词失败');
  }

  return response.json();
}

/**
 * 从单词本删除单词
 */
export async function deleteWordFromUserWordlist(wordText: string) {
  const response = await authenticatedApiRequest(`/api/user/wordlist/${encodeURIComponent(wordText)}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error('删除单词失败');
  }

  return response.json();
}

/**
 * 获取收藏的播客列表
 */
export async function getSavedPodcasts() {
  const response = await authenticatedApiRequest('/api/user/saved-podcasts', {
    method: 'GET',
  });

  if (!response.ok) {
    throw new Error('获取收藏播客列表失败');
  }

  return response.json();
}

/**
 * 添加播客到收藏
 */
export async function addPodcastToSaved(podcastData: {
  title: string;
  rssUrl: string;
  coverImage?: string;
  description?: string;
}) {
  const response = await authenticatedApiRequest('/api/user/saved-podcasts', {
    method: 'POST',
    body: JSON.stringify(podcastData),
  });

  if (!response.ok) {
    throw new Error('添加播客失败');
  }

  return response.json();
}

/**
 * 从收藏中删除播客
 */
export async function removePodcastFromSaved(podcastTitle: string) {
  const response = await authenticatedApiRequest(`/api/user/saved-podcasts/${encodeURIComponent(podcastTitle)}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error('删除播客失败');
  }

  return response.json();
}
</file>

<file path="src/components/AudioPlayerComponent.tsx">
import {
  Box,
  Slider,
  IconButton,
  Typography,
  Stack,
  Popper,
  ClickAwayListener,
  Button,
} from "@mui/material";
import {
  PlayArrow,
  Pause,
  VolumeUp,
  VolumeOff,
  Forward10,
  Replay10,
} from "@mui/icons-material";
import {
  forwardRef,
  useRef,
  useState,
  useEffect,
  useImperativeHandle,
} from "react";
import { useTheme } from "@mui/material/styles";
import WaveSurfer from "wavesurfer.js";

/** props 类型：音频地址 + 时间更新回调 */
type Props = {
  /** 要播放的音频文件 URL */
  audioSrc: string;
  /** 当前播放时间（毫秒）更新时触发，可选 */
  onTimeUpdate?: (timeMs: number) => void;
};

/** ref 暴露给父组件的控制方法 */
export type AudioPlayerHandle = {
  pause: () => void;
};


const formatTime = (time) => {
  const minutes = Math.floor(time / 60)
    .toString()
    .padStart(2, "0");
  const seconds = Math.floor(time % 60)
    .toString()
    .padStart(2, "0");
  return `${minutes}:${seconds}`;
};

const AudioPlayerComponent = forwardRef<AudioPlayerHandle, Props>(
  ({ audioSrc, onTimeUpdate }, ref) => {
  const theme = useTheme();
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const waveformRef = useRef<HTMLDivElement | null>(null);
  const wavesurfer = useRef<WaveSurfer | null>(null); // 指定 WaveSurfer 类型

  const [playing, setPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [volumeAnchorEl, setVolumeAnchorEl] = useState(null);
  const [speedAnchorEl, setSpeedAnchorEl] = useState(null);
  const [waveformLoading, setWaveformLoading] = useState(true);
  const [showSpeedMenu, setShowSpeedMenu] = useState(false);
  const [audioError, setAudioError] = useState<string | null>(null);

  // 创建代理音频URL的函数
  const createProxyAudioUrl = (originalUrl: string) => {
    // 如果已经是代理URL，直接返回
    if (originalUrl.includes('/api/transcriptions/audio-proxy')) {
      return originalUrl;
    }
    // 创建代理URL
    return `http://localhost:3000/api/transcriptions/audio-proxy?url=${encodeURIComponent(originalUrl)}`;
  };

  // 初始化 wavesurfer
  useEffect(() => {
    if (!waveformRef.current) return;
    if (wavesurfer.current) {
      wavesurfer.current.destroy();
    }
    
    setWaveformLoading(true);
    setAudioError(null);
    
    // 使用代理URL
    const proxyAudioSrc = createProxyAudioUrl(audioSrc);
    
    wavesurfer.current = WaveSurfer.create({
      container: waveformRef.current,
      waveColor: "#b3c7f9",
      progressColor: "#1976d2",
      height: 50,
      // responsive: true,
      barWidth: 2,
      barRadius: 2,
      cursorColor: "#1976d2",
    });
    
    wavesurfer.current.load(proxyAudioSrc);

    wavesurfer.current.on("ready", () => {
      setDuration(wavesurfer.current.getDuration());
      setWaveformLoading(false);
      setAudioError(null);
    });

    wavesurfer.current.on("error", (error) => {
      console.error('WaveSurfer error:', error);
      setAudioError('音频加载失败，请检查网络连接或音频文件是否有效');
      setWaveformLoading(false);
    });

    wavesurfer.current.on("audioprocess", () => {
      const t = wavesurfer.current.getCurrentTime();
      setCurrentTime(t);
      if (onTimeUpdate) {
        onTimeUpdate(t * 1000);
      }
    });

    wavesurfer.current.on("interaction", () => { 
      const t = wavesurfer.current.getCurrentTime();
      setCurrentTime(t);
      if (onTimeUpdate) {
        onTimeUpdate(t * 1000);
      }
    });

    wavesurfer.current.on("play", () => setPlaying(true));
    wavesurfer.current.on("pause", () => setPlaying(false));

    // 保持音量和倍速同步
    wavesurfer.current.setVolume(volume);
    wavesurfer.current.setPlaybackRate(playbackRate);

    return () => {
      wavesurfer.current && wavesurfer.current.destroy();
    };
    // eslint-disable-next-line
  }, [audioSrc]);

  // 音量和倍速变化时同步到 wavesurfer
  useEffect(() => {
    if (wavesurfer.current) {
      wavesurfer.current.setVolume(volume);
    }
  }, [volume]);
  useEffect(() => {
    if (wavesurfer.current) {
      wavesurfer.current.setPlaybackRate(playbackRate);
    }
  }, [playbackRate]);

  useImperativeHandle(ref, () => ({
    pause: () => {
      wavesurfer.current && wavesurfer.current.pause();
      setPlaying(false);
    },
  }));

  // 控制
  const togglePlay = () => {
    if (wavesurfer.current) {
      wavesurfer.current.playPause();
    }
  };

  const handleSliderChange = (_, value) => {
    if (wavesurfer.current) {
      wavesurfer.current.seekTo(value / duration);
      setCurrentTime(value);
    }
  };

  const handleVolumeChange = (_, value) => {
    setVolume(value);
  };

  const handleSpeedChange = (rate) => {
    setPlaybackRate(rate);
    setSpeedAnchorEl(null);
  };

  const handleForward = () => {
    if (wavesurfer.current) {
      const t = Math.min(currentTime + 10, duration);
      wavesurfer.current.seekTo(t / duration);
      setCurrentTime(t);
    }
  };
  const handleReplay = () => {
    if (wavesurfer.current) {
      const t = Math.max(currentTime - 10, 0);
      wavesurfer.current.seekTo(t / duration);
      setCurrentTime(t);
    }
  };

  return (
    <Box
      sx={{
        borderRadius: 10,
        px: 6,
        py: 2,
        bgcolor: "#fff",
        boxShadow: 1,
        width: "100%",
        gap: 2,
      }}
    >
      {/* 时间 + 波形图 */}
      <Box sx={{ display: "flex", alignItems: "center", width: "100%", mb: 1 }}>
        <Typography variant="caption" sx={{ minWidth: 40 }}>
          {formatTime(0)}
        </Typography>
        <Box sx={{ flexGrow: 1, position: "relative" }}>
          <div ref={waveformRef} style={{ width: "100%" }} />
          {waveformLoading && (
            <Box
              sx={{
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                bgcolor: "rgba(255,255,255,0.7)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 1,
              }}
            >
              <Typography variant="caption" color="text.secondary">
                Loading...
              </Typography>
            </Box>
          )}
          {audioError && (
            <Box
              sx={{
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                bgcolor: "rgba(255,255,255,0.9)",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 2,
                p: 2,
              }}
            >
              <Typography variant="caption" color="error" sx={{ mb: 1 }}>
                {audioError}
              </Typography>
              <Button 
                size="small" 
                variant="outlined" 
                onClick={() => {
                  setAudioError(null);
                  if (wavesurfer.current) {
                    wavesurfer.current.load(createProxyAudioUrl(audioSrc));
                  }
                }}
              >
                重试
              </Button>
            </Box>
          )}
        </Box>
        <Typography variant="caption" sx={{ minWidth: 40, textAlign: "right" }}>
          {formatTime(duration)}
        </Typography>
      </Box>

      {/* 控制条 */}
      <Stack
        direction="row"
        spacing={2}
        alignItems="center"
        justifyContent="center"
      >
        <IconButton onClick={handleReplay} sx={{ color: "#485D92" }}>
          <Replay10 />
        </IconButton>

        <IconButton onClick={togglePlay} color="primary">
          {playing ? <Pause /> : <PlayArrow />}
        </IconButton>

        <IconButton onClick={handleForward} sx={{ color: "#485D92" }}>
          <Forward10 />
        </IconButton>

        <Box
          sx={{
            position: "relative",
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <Button
            variant="text"
            size="small"
            onClick={function() {
              setShowSpeedMenu(!showSpeedMenu);
            }}
            sx={{
              minWidth: "auto",
              px: 1,
              color: "text.secondary",
              "&:hover": {
                backgroundColor: "action.hover",
              },
            }}
          >
            {playbackRate}x
          </Button>
          {showSpeedMenu && (
            <Box
              sx={{
                position: "absolute",
                bottom: "100%",
                left: "50%",
                transform: "translateX(-50%)",
                backgroundColor: "background.paper",
                borderRadius: 1,
                boxShadow: 3,
                p: 1,
                zIndex: 1400,
                mb: 1,
                minWidth: 100,
              }}
            >
              {[0.5, 0.75, 1, 1.25, 1.5, 2].map(function(speed) {
                return (
                  <Button
                    key={speed}
                    fullWidth
                    size="small"
                    onClick={function() {
                      handleSpeedChange(speed);
                      setShowSpeedMenu(false);
                    }}
                    sx={{
                      justifyContent: "flex-start",
                      color: speed === playbackRate ? "primary.main" : "text.primary",
                      "&:hover": {
                        backgroundColor: "action.hover",
                      },
                    }}
                  >
                    {speed}x
                  </Button>
                );
              })}
            </Box>
          )}
        </Box>

        <Box
          sx={{
            position: "relative",
            display: "flex",
            alignItems: "center",
          }}
        >
          <IconButton
            onClick={function(e) {
              setVolumeAnchorEl(volumeAnchorEl ? null : e.currentTarget);
            }}
            sx={{ color: "#485D92" }}
          >
            {volume > 0 ? <VolumeUp /> : <VolumeOff />}
          </IconButton>
          {Boolean(volumeAnchorEl) && (
            <Box
              sx={{
                position: "absolute",
                bottom: "100%",
                left: "50%",
                transform: "translateX(-50%)",
                backgroundColor: "background.paper",
                borderRadius: 1,
                boxShadow: 3,
                p: 2,
                zIndex: 1400,
                mb: 1,
                minWidth: 120,
              }}
            >
              <Slider
                value={volume}
                onChange={handleVolumeChange}
                min={0}
                max={1}
                step={0.01}
                orientation="vertical"
                sx={{
                  height: 100,
                  '& .MuiSlider-thumb': {
                    width: 12,
                    height: 12,
                  },
                  '& .MuiSlider-track': {
                    width: 4,
                  },
                  '& .MuiSlider-rail': {
                    width: 4,
                  }
                }}
              />
            </Box>
          )}
        </Box>
      </Stack>
    </Box>
  );
});

export default AudioPlayerComponent;
</file>

<file path="src/components/CollapseBox.tsx">
import React from "react";
import "../styles/CollapseBox.css";

// [fix] 定义 props 和 state 的类型
type Props = {
  title: string;          // 标题文字
  children?: React.ReactNode; // 折叠内容
};

type State = {
  open: boolean;          // 是否展开
};

class CollapseBox extends React.Component<Props, State> { // 泛型参数
  constructor(props: Props) { // 给 constructor 指定 props 类型
    super(props);
    this.state = { open: false };
    this.toggleBox = this.toggleBox.bind(this);
  }

  toggleBox() {
    this.setState(function (prevState) {
      return { open: !prevState.open };
    });
  }

  render() {
    return (
      <div className="collapse-box">
        <button className="collapse-toggle-btn" onClick={this.toggleBox}>
          <span className={"collapse-arrow" + (this.state.open ? " open" : "")}></span>
          {this.props.title}
        </button>
        <div
          className="collapse-content"
          style={{ display: this.state.open ? "block" : "none" }}
        >
          {this.props.children}
        </div>
      </div>
    );
  }
}

export { CollapseBox };
</file>

<file path="src/components/DiscoveryCard.tsx">
// src/components/DiscoveryCard.tsx

import React from 'react';
import {
  Card,
  CardActionArea,
  CardContent,
  CardMedia,
  Typography,
  Stack,
  Chip,
  Box,
} from '@mui/material';

type PodcastItem = {
  id?: string | number;
  title?: string;
  name?: string;
  description?: string;
  summary?: string;
  content?: string;
  author?: string;
  publisher?: string;
  artist?: string;
  owner?: string;
  image?: string;
  artwork?: string;
  cover?: string;
  thumbnail?: string;
  url?: string;
  categories?: string[];
  genre?: string[];
  tags?: string[];
};

type Props = {
  item: PodcastItem;
  onSelect: (item: PodcastItem) => void;
};

function stripHtml(input: string = '') {
  return input.replace(/<\/?[^>]+(>|$)/g, '').replace(/\s+/g, ' ').trim();
}
function pickImage(item: PodcastItem) {
  return item.image || item.artwork || item.cover || item.thumbnail || '';
}
function pickAuthor(item: PodcastItem) {
  return item.author || item.publisher || item.artist || item.owner || '';
}
function pickDescription(item: PodcastItem) {
  const raw = item.description || item.summary || item.content || '';
  return stripHtml(raw);
}

export default function DiscoveryCard({ item, onSelect }: Props) {
  const title = item.title || item.name || 'Untitled';
  const author = pickAuthor(item);
  const description = pickDescription(item);
  const cover = pickImage(item);
  const tagList = item.categories || item.genre || item.tags || [];

  return (
    <Card
      elevation={2}
      sx={{
        borderRadius: 2.4,
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        transition: 'transform 0.25s ease, box-shadow 0.25s ease',
        transformOrigin: 'center center',
        '&:hover': {
          transform: 'scale(1.01)',
          boxShadow: 2,
        },
      }}
    >
      <CardActionArea
        onClick={() => onSelect(item)}
        sx={{
          display: 'flex',
          flexDirection: 'column',
          flexGrow: 1,
          height: '100%',
        }}
      >
        {/* 封面保持方形 */}
        <Box
          sx={{
            width: '100%',
            aspectRatio: '1 / 1',
            overflow: 'hidden',
            flexShrink: 0,
            borderTopLeftRadius: 4,
            borderTopRightRadius: 4,
          }}
        >
          {cover ? (
            <CardMedia
              component="img"
              image={cover}
              alt={title}
              sx={{
                width: '100%',
                height: '100%',
                objectFit: 'cover',
                objectPosition: 'center',
                transition: 'transform 0.3s ease',
                '&:hover': { transform: 'scale(1.05)' },
              }}
              loading="lazy"
            />
          ) : (
            <Box sx={{ width: '100%', height: '100%', bgcolor: 'action.hover' }} />
          )}
        </Box>

        {/* ✅ 文字内容更紧凑 */}
        <CardContent
          sx={{
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'space-between',
            flexGrow: 1,
            width: '100%',
            p: 1.8, // 原来2.5，减少间距
          }}
        >
          <Box sx={{ flexGrow: 1 }}>
            <Typography
              variant="subtitle1"
              component="h3"
              sx={{
                fontWeight: 700,
                display: '-webkit-box',
                WebkitLineClamp: 2,
                WebkitBoxOrient: 'vertical',
                overflow: 'hidden',
                mb: 0.3,
              }}
            >
              {title}
            </Typography>

            {author && (
              <Typography
                variant="body2"
                color="text.secondary"
                sx={{
                  mb: 0.6,
                  lineHeight: 1.2,
                  whiteSpace: 'nowrap',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                }}
              >
                {author}
              </Typography>
            )}

            {description && (
              <Typography
                variant="body2"
                sx={{
                  color: 'text.primary',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  display: '-webkit-box',
                  WebkitBoxOrient: 'vertical',
                  WebkitLineClamp: 3, 
                  lineHeight: 1.4,
                  minHeight: '4.2em', // 约三行高度，确保底部齐平
                }}
                title={description}
              >
                {description}
              </Typography>
            )}
          </Box>

          {/* 标签贴底浅蓝 */}
          {tagList.length > 0 && (
            <Stack
              direction="row"
              spacing={1}
              useFlexGap
              flexWrap="wrap"
              sx={{ mt: 1 }}
            >
              {tagList.slice(0, 6).map((tag, idx) => (
                <Chip
                  key={`${tag}-${idx}`}
                  label={tag}
                  size="small"
                  sx={{
                    borderRadius: '9999px',
                    backgroundColor: 'rgba(33,150,243,0.15)', // 浅蓝底
                    color: 'rgb(25,118,210)', // 主色
                    border: 'none',
                    fontWeight: 500,
                    fontSize: '0.75rem',
                  }}
                />
              ))}
            </Stack>
          )}
        </CardContent>
      </CardActionArea>
    </Card>
  );
}
</file>

<file path="src/components/RecommendationRow.tsx">
import React from "react";
import { Chip } from "@mui/material";

type Item = {
  id?: string;
  url?: string;            // RSS
  title: string;
  author?: string;
  image?: string;
  description?: string;
  categories?: string[];
  episodesCount?: number;
  lastUpdated?: string;    // ISO
};

// ✅ 新增：去除 HTML 标签的函数
function stripHtml(input: string = ""): string {
  return input.replace(/<\/?[^>]+(>|$)/g, "").replace(/\s+/g, " ").trim();
}

export default function RecommendationRow({
  items,
  onSelect,
  isLoading = false,
}: {
  items: Item[];
  onSelect: (p: Item) => void;
  isLoading?: boolean;
}) {
  // 两行截断样式
  const twoLine = {
    display: "-webkit-box",
    WebkitBoxOrient: "vertical" as const,
    WebkitLineClamp: 2,
    overflow: "hidden",
  };

  const rows = isLoading
    ? (Array.from({ length: 4 }).map((_, i) => ({ id: `sk-${i}`, title: "" })) as any[])
    : (items || []).slice(0, 4);

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 20, width: "100%" }}>
      {rows.map((p: Item, i: number) => {
        const cleanTitle = stripHtml(p.title || "");
        const cleanDesc = stripHtml(p.description || "");

        return (
          <div
            key={(p && (p.id || p.url)) || `row-${i}`}
            onClick={() => !isLoading && onSelect(p)}
            style={{
              display: "flex",
              alignItems: "stretch",
              gap: 20,
              padding: 20,
              borderRadius: 16,
              backgroundColor: "#fff",
              boxShadow: "0 2px 6px rgba(0,0,0,0.05)",
              cursor: isLoading ? "default" : "pointer",
              opacity: isLoading ? 0.7 : 1,
              transition: "transform 0.25s ease, box-shadow 0.25s ease",
            }}
          >
            {/* 左侧封面 */}
            <div
              style={{
                width: 140,
                height: 140,
                borderRadius: 12,
                overflow: "hidden",
                flexShrink: 0,
                background: "#eee",
              }}
            >
              {isLoading ? (
                <div style={{ width: "100%", height: "100%", background: "#e5e7eb" }} />
              ) : p.image ? (
                <img
                  src={p.image}
                  alt={cleanTitle}
                  style={{
                    width: "100%",
                    height: "100%",
                    objectFit: "cover",
                    display: "block",
                  }}
                  loading="lazy"
                  decoding="async"
                />
              ) : null}
            </div>

            {/* 右侧信息 */}
            <div style={{ flex: 1, minWidth: 0, display: "flex", flexDirection: "column" }}>
              <div
                title={cleanTitle}
                style={{ ...twoLine, fontWeight: 700, fontSize: 18, marginBottom: 6 }}
              >
                {isLoading ? "\u00A0" : cleanTitle}
              </div>

              {p.author && (
                <div style={{ color: "#6b7280", marginBottom: 8, fontSize: 14 }}>
                  by {p.author}
                </div>
              )}

              <div style={{ ...twoLine, color: "#4b5563", fontSize: 15, marginBottom: 10 }}>
                {isLoading ? "\u00A0\u00A0\u00A0" : cleanDesc}
              </div>

              {!!p.categories?.length && (
                <div style={{ display: "flex", flexWrap: "wrap", gap: 6, marginTop: "auto" }}>
                  {p.categories.map((tag, idx) => (
                    <Chip
                      key={`${tag}-${idx}`}
                      label={tag}
                      size="small"
                      sx={{
                        borderRadius: "9999px",
                        backgroundColor: "rgba(33,150,243,0.15)",
                        color: "rgb(25,118,210)",
                        border: "none",
                        fontWeight: 500,
                        fontSize: "0.75rem",
                      }}
                    />
                  ))}
                </div>
              )}

              {/* 元信息 */}
              <div
                style={{
                  display: "flex",
                  gap: 8,
                  flexWrap: "wrap",
                  fontSize: 13,
                  color: "#6b7280",
                  marginTop: 6,
                }}
              >
                {!isLoading && (
                  <>
                    {typeof p.episodesCount === "number" && (
                      <span>Episodes: {p.episodesCount}</span>
                    )}
                    {p.lastUpdated && (
                      <span>• Updated: {new Date(p.lastUpdated).toLocaleDateString()}</span>
                    )}
                  </>
                )}
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/TopNav.tsx">
import '../styles/TopNav.css';
import { observer } from "mobx-react-lite";
import loginModel from "../loginModel";
import { useNavigate, Link } from "react-router-dom";
import { useState } from "react";

// 定义 props 类型
type Props = {
  hideLogo?: boolean; // 控制是否隐藏 logo
};


// TopNav component - View layer in MVP architecture
export const TopNav = observer(function TopNav({ hideLogo }: Props) {
  const user = loginModel.getUser();
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  function handleLoginMenuClick(e) {
    // e.preventDefault();
    navigate("/login");
  }

  return (
    <nav className="top-nav">
      <div className="nav-container">
        {!hideLogo ? (
          <Link to="/" className="brand-link">Listenary</Link>
        ) : (
          <span className="slogan-text">Learn English with Podcasts</span>
        )}

        <div className="nav-links">
          <Link to="/search" className="nav-link">Discover</Link>
          <Link to="/wordlist" className="nav-link">Wordlist</Link>
          {user ? (
            <span className="nav-link" onClick={handleLoginMenuClick} style={{ cursor: 'pointer' }}>
              {user.displayName || user.email}
            </span>
          ) : (
            <span className="nav-link" onClick={handleLoginMenuClick} style={{ cursor: 'pointer' }}>
              {isLoading ? 'Logging in...' : 'Login'}
            </span>
          )}
        </div>
      </div>
    </nav>
  );
});
</file>

<file path="src/config/apiConfig.ts">
// src/config/apiConfig.ts
// 统一的API配置

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';

export { API_BASE_URL };

// 获取认证token的通用函数
export async function getAuthToken(): Promise<string> {
  const { getAuth } = await import('firebase/auth');
  const auth = getAuth();
  const user = auth.currentUser;
  if (!user) {
    throw new Error('User not authenticated');
  }
  return await user.getIdToken();
}

// 通用的API请求函数
export async function apiRequest(
  endpoint: string,
  options: RequestInit = {}
): Promise<Response> {
  const url = endpoint.startsWith('http') ? endpoint : `${API_BASE_URL}${endpoint}`;
  
  const defaultHeaders = {
    'Content-Type': 'application/json',
  };

  const config: RequestInit = {
    ...options,
    headers: {
      ...defaultHeaders,
      ...options.headers,
    },
  };

  return fetch(url, config);
}

// 带认证的API请求函数
export async function authenticatedApiRequest(
  endpoint: string,
  options: RequestInit = {}
): Promise<Response> {
  const token = await getAuthToken();
  
  const config: RequestInit = {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`,
    },
  };

  return apiRequest(endpoint, config);
}
</file>

<file path="src/hooks/useAudioPlayback.tsx">
import { useEffect, useState } from "react";

/**
 * 监听 audio 元素播放时间变化，返回当前播放时间（以毫秒为单位）
 * @param {React.RefObject<HTMLAudioElement>} audioRef - 指向 AudioPlayer 组件的 ref
 * @returns {number} currentTime 当前播放时间（ms）
 */
export function useAudioPlayback(audioRef) {
  const [currentTime, setCurrentTime] = useState(0);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const updateTime = () => setCurrentTime(audio.currentTime * 1000);

    audio.addEventListener("timeupdate", updateTime);

    return () => {
      audio.removeEventListener("timeupdate", updateTime);
    };
  }, [audioRef]);

  return currentTime;
}

  // // Monitor audio playback time for text highlighting
  // useEffect(function setupAudioTimeListener() {
  //   const audio = audioRef.current;
  //   if (!audio) return;

  //   function updateTime() {
  //     setCurrentTime(audio.currentTime * 1000);
  //   }
  //   audio.addEventListener("timeupdate", updateTime);
  //   return function cleanup() {
  //     audio.removeEventListener("timeupdate", updateTime);
  //   };
  // }, []);

  // useEffect(() => {}, [currentTime]);
  // function handleTimeUpdate(time) {
  //   setCurrentTime(time);
  // }
</file>

<file path="src/hooks/useInfinitePodcastSearch.ts">
import { useCallback, useRef, useState } from "react";

export type PodcastItem = {
  id?: string;
  title: string;
  author?: string;
  image?: string;
  url?: string;           // RSS
  description?: string;
  categories?: string[];
  lastUpdated?: string;   // ISO 时间字符串
  episodesCount?: number;
};

type PageResp = {
  items: PodcastItem[];
  total?: number;
  hasMore?: boolean; // 后端若返回就用它；否则用长度推断
};

const PAGE_SIZE = 20;

export default function useInfinitePodcastSearch() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<PodcastItem[]>([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 取消上一次请求，避免竞态
  const abortRef = useRef<AbortController | null>(null);

  const fetchPage = useCallback(async (q: string, p: number, append: boolean) => {
    if (!q.trim()) return;
    abortRef.current?.abort();
    const ac = new AbortController();
    abortRef.current = ac;

    append ? setIsLoadingMore(true) : setIsLoading(true);
    setError(null);

    try {
      // 假设后端支持 page/limit；若不支持，见本文末“无分页后端的降级方案”
      const url = `/api/podcasts/search?q=${encodeURIComponent(q)}&page=${p}&limit=${PAGE_SIZE}`;
      const res = await fetch(url, { signal: ac.signal });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const data: PageResp | PodcastItem[] = await res.json();

      // 兼容两种返回结构
      const items = Array.isArray(data) ? data : data.items;
      const nextHasMore = Array.isArray(data)
        ? items.length === PAGE_SIZE
        : Boolean(data.hasMore ?? items.length === PAGE_SIZE);

      setResults(prev => (append ? [...prev, ...items] : items));
      setHasMore(nextHasMore);
      setPage(p);
    } catch (e: any) {
      if (e?.name !== "AbortError") setError(e?.message || "Search failed");
    } finally {
      setIsLoading(false);
      setIsLoadingMore(false);
    }
  }, []);

  const startSearch = useCallback(async (q: string) => {
    setQuery(q);
    setResults([]);
    setPage(1);
    setHasMore(false);
    await fetchPage(q, 1, false);
  }, [fetchPage]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading || isLoadingMore) return;
    await fetchPage(query, page + 1, true);
  }, [fetchPage, hasMore, isLoading, isLoadingMore, page, query]);

  return {
    query, setQuery,
    results, isLoading, isLoadingMore, error, hasMore,
    startSearch, loadMore,
  };
}
</file>

<file path="src/hooks/useRSSInput.ts">
import { useNavigate } from "react-router-dom";

export function useRSSInput() {
  const navigate = useNavigate();

  const handleRSSSubmit = (rssUrl) => {
    // Later we'll add RSS parsing logic here
    // For now, just navigate to podcast channel page
    navigate('/podcast-channel');
  };

  return handleRSSSubmit;
}
</file>

<file path="src/hooks/useTranscriptionManager.ts">
import { useCallback, useEffect, useRef } from "react";
import { runInAction } from "mobx";

const TRANSCRIPTION_WS_PATH = "/ws/transcriptions";

type Phrase = {
  text: string;
  offsetMilliseconds: number;
  endOffsetMilliseconds?: number;
};

type WsSentencePayload = {
  text?: string;
  start?: number;
  end?: number;
  offsetMilliseconds?: number;
  endOffsetMilliseconds?: number;
};

type WsMessage = {
  type?: string;
  data?: any;
  message?: string;
};

function buildWebSocketUrl(path: string) {
  if (path.startsWith("ws://") || path.startsWith("wss://")) {
    return path;
  }
  const protocol = window.location.protocol === "https:" ? "wss" : "ws";
  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
  return `${protocol}://${window.location.host}${normalizedPath}`;
}

function isFiniteNumber(value: unknown): value is number {
  return typeof value === "number" && Number.isFinite(value);
}

function convertToPhrase(sentence?: WsSentencePayload | null): Phrase | null {
  if (!sentence) {
    return null;
  }

  // 后端已经统一处理了数据格式，直接使用
  const start = sentence.offsetMilliseconds || 0;
  const end = sentence.endOffsetMilliseconds;
  const text = sentence.text?.trim() ?? "";

  return {
    text,
    offsetMilliseconds: start,
    endOffsetMilliseconds: end,
  };
}

export function useTranscriptionManager({
  model,
  episode,
  setIsTranscribing,
  setIsLoading,
}) {
  const socketRef = useRef<WebSocket | null>(null);
  const phrasesRef = useRef<Phrase[]>([]);
  const hasCompletedRef = useRef(false);

  useEffect(() => {
    return () => {
      if (socketRef.current) {
        socketRef.current.close(1000, "cleanup");
        socketRef.current = null;
      }
    };
  }, []);

  const handleWsMessage = useCallback(
    (message: WsMessage, episodeGuid: string) => {
      if (!message || !message.type) {
        return;
      }

      if (message.type === "sentence") {
        const phrase = convertToPhrase(message.data as WsSentencePayload);
        if (!phrase) {
          return;
        }
        phrasesRef.current = [...phrasesRef.current, phrase];
        model.setResults(phrasesRef.current.slice());
        return;
      }

      if (message.type === "complete" || message.type === "existing") {
        const sentences = Array.isArray(message.data?.sentences)
          ? (message.data.sentences as WsSentencePayload[])
          : [];
        const finalPhrases = sentences
          .map((sentence) => convertToPhrase(sentence))
          .filter(Boolean) as Phrase[];
        phrasesRef.current = finalPhrases;
        model.setResults(finalPhrases);

        runInAction(() => {
          model.transcripResultsPromiseState.error = null;
          model.transcripResultsPromiseState.data = {
            guid: episodeGuid,
            phrases: finalPhrases,
            status: "complete",
            fullText:
              typeof message.data?.fullText === "string"
                ? message.data.fullText
                : undefined,
          };
        });

        hasCompletedRef.current = true;
        if (setIsTranscribing) setIsTranscribing(false);
        if (setIsLoading) setIsLoading(false);
        return;
      }

      if (message.type === "error") {
        hasCompletedRef.current = true;
        const errorMessage = message.message || "Transcription failed.";
        runInAction(() => {
          model.transcripResultsPromiseState.error = new Error(errorMessage);
        });
        if (setIsTranscribing) setIsTranscribing(false);
        if (setIsLoading) setIsLoading(false);
        alert(errorMessage);
        return;
      }
    },
    [model, setIsLoading, setIsTranscribing]
  );

  const startStreaming = useCallback(() => {
    const episodeGuid = model.currentEpisode?.guid || episode?.guid;
    const audioUrl = model.audioUrl;

    if (!audioUrl || !episodeGuid) {
      throw new Error("Missing audio URL or episode GUID for transcription");
    }

    if (socketRef.current) {
      socketRef.current.close(1000, "restart-transcription");
    }

    phrasesRef.current = [];
    hasCompletedRef.current = false;
    model.setResults([]);
    runInAction(() => {
      model.transcripResultsPromiseState.error = null;
      model.transcripResultsPromiseState.data = null;
    });

    const ws = new WebSocket(buildWebSocketUrl(TRANSCRIPTION_WS_PATH));
    socketRef.current = ws;

    const startPayload = {
      action: "start",
      audioUrl,
      episodeId: episodeGuid,
      rssUrl: model.rssUrl,
    };

    ws.addEventListener("open", () => {
      ws.send(JSON.stringify(startPayload));
    });

    ws.addEventListener("message", (event) => {
      try {
        const parsed = JSON.parse(event.data);
        handleWsMessage(parsed, episodeGuid);
      } catch (err) {
        console.error("Failed to parse transcription message", err);
      }
    });

    ws.addEventListener("error", () => {
      if (!hasCompletedRef.current) {
        hasCompletedRef.current = true;
        runInAction(() => {
          model.transcripResultsPromiseState.error = new Error(
            "WebSocket connection error during transcription"
          );
        });
        if (setIsTranscribing) setIsTranscribing(false);
        if (setIsLoading) setIsLoading(false);
        alert("Transcription connection error, please try again later.");
      }
    });

    ws.addEventListener("close", () => {
      if (!hasCompletedRef.current) {
        if (setIsTranscribing) setIsTranscribing(false);
        if (setIsLoading) setIsLoading(false);
      }
      if (socketRef.current === ws) {
        socketRef.current = null;
      }
    });
  }, [episode, handleWsMessage, model, setIsLoading, setIsTranscribing]);

  const handleTranscribe = useCallback(() => {
    if (!episode || !model.audioUrl) {
      alert("Invalid episode data");
      return;
    }

    if (model.transcripResults?.length > 0) {
      alert("This episode has already been transcribed.");
      return;
    }

    if (setIsTranscribing) setIsTranscribing(true);
    if (setIsLoading) setIsLoading(true);

    const audio = new Audio(model.audioUrl);

    const handleMetadata = () => {
      const duration = audio.duration;
      model.setAudioDuration(duration);

      try {
        startStreaming();
      } catch (error: any) {
        console.error("Failed to start transcription stream:", error.message);
        alert("Transcription start failed, please try again later!");
        if (setIsTranscribing) setIsTranscribing(false);
        if (setIsLoading) setIsLoading(false);
      }
    };

    const handleAudioError = () => {
      alert("Unable to load audio metadata. Please try again later.");
      if (setIsTranscribing) setIsTranscribing(false);
      if (setIsLoading) setIsLoading(false);
    };

    audio.addEventListener("loadedmetadata", handleMetadata, { once: true });
    audio.addEventListener("error", handleAudioError, { once: true });
    audio.load();
  }, [episode, model, setIsLoading, setIsTranscribing, startStreaming]);

  return { handleTranscribe };
}
</file>

<file path="src/hooks/useTranscriptionSync.ts">
import { useEffect } from "react";
// 使用 MongoDB API 保存转录数据
import { saveTranscriptionData } from "../api/transcriptionAPI";
import loginModel from "../loginModel";

/**
 * Hook to handle transcription state change and sync with Firestore
 */
export function useTranscriptionSync({
  model,
  episode,
  data,
  error,
  setIsTranscribing,
  setIsLoading,
}) {
  useEffect(() => {
    if (data && data.guid === episode?.guid) {
      console.log("Setting transcription results:", data.phrases);
      model.setResults(data.phrases);
      setIsTranscribing(false);
      setIsLoading(false);

      const user = loginModel.getUser();
      if (user && episode?.guid) {
        // 保存到 MongoDB（无需 uid，API 自动处理）
        saveTranscriptionData(
          episode.guid,
          episode.title,
          data.phrases
        ).then(() => {
          const event = new CustomEvent("transcriptionComplete", {
            detail: { guid: episode.guid },
          });
          window.dispatchEvent(event);
        }).catch((error) => {
          console.error('Failed to save transcription:', error);
        });
      }
    }
  }, [data, error, episode]);
}

//   //address race condition
//   const guid = episode?.guid;
//   const data = props.model.transcripResultsPromiseState.data;
//   const error = props.model.transcripResultsPromiseState.error;

//   useEffect(() => {
//     console.log("useEffect triggered", { data, guid, episode });
//     if (data && data.guid === guid) {
//       console.log("Setting results:", data.phrases);
//       props.model.setResults(data.phrases);
//       setIsTranscribing(false);
//       setIsLoading(false);

//       // Save transcription data and dispatch event
//       const user = loginModel.getUser();
//       if (user && episode?.guid) {
//         saveTranscriptionData(
//           user.uid,
//           episode.guid,
//           episode.title,
//           data.phrases
//         ).then(function () {
//           console.log("Transcription saved, dispatching event...");
//           const event = new CustomEvent("transcriptionComplete", {
//             detail: { guid: episode.guid },
//           });
//           window.dispatchEvent(event);
//         });
//       }
//     }
//   }, [data, error, guid]);
</file>

<file path="src/hooks/useTranslationHandler.ts">
import TranslationAPI from "../api/TranslationAPI";

interface UseTranslationHandlerProps {
  transcriptionData: any[];
  setTargetLanguage: (lang: string) => void;
  setTranslations: (translations: any) => void;
  setTranslatingItems: (items: Set<string>) => void;
}

export function useTranslationHandler({
  transcriptionData,
  setTargetLanguage,
  setTranslations,
  setTranslatingItems
}: UseTranslationHandlerProps) {
  const handleLanguageChange = async (event) => {
    const newTargetLang = event.target.value;
    setTargetLanguage(newTargetLang);
    if (!newTargetLang) {
      setTranslations({});
      setTranslatingItems(new Set());
      return;
    }

    // 准备所有需要翻译的文本
    const textsToTranslate = transcriptionData.map(item => item.text);
    const translatingSet = new Set(textsToTranslate);
    
    setTranslatingItems(translatingSet);

    try {
      const translator = TranslationAPI({
        textToTranslate: textsToTranslate,
        targetLang: newTargetLang,
        onTranslationComplete: (response) => {
          const newTranslations = {};
          
          // 处理翻译结果
          if (response.translations) {
            response.translations.forEach((translation, index) => {
              if (textsToTranslate[index]) {
                newTranslations[textsToTranslate[index]] = translation.text;
              }
            });
          }
          
          // 处理跳过的文本
          if (response.skippedTexts) {
            response.skippedTexts.forEach(skipped => {
              newTranslations[skipped.text] = skipped.reason;
            });
          }
          
          setTranslations(newTranslations);
          setTranslatingItems(new Set());
        },
      });
      translator.translate();
    } catch (error) {
      console.error('Translation failed:', error);
      setTranslatingItems(new Set());
    }
  };

  return { handleLanguageChange };
}
</file>

<file path="src/hooks/useWordLookup.ts">
import { useState } from "react";
// MongoDB API 调用
import { saveWordToUserWordlist } from "../api/userAPI";
import loginModel from "../loginModel";

interface UseWordLookupProps {
  model: any;
}

export function useWordLookup(model: UseWordLookupProps['model']) {
  const [wordCard, setWordCard] = useState({
    word: "",
    phonetics: { uk: null, us: null },
    definition: null,
    examples: null,
    relatedTerms: null,
  });
  const [isLoading, setIsLoading] = useState(false);

  function handleWordSelect(word) {
    console.log("Looking up word:", word);
    
    setIsLoading(true);
    
    // 立即显示当前单词
    setWordCard({
      word: word,
      phonetics: { uk: null, us: null },
      definition: null,
      examples: null,
      relatedTerms: null,
    });

    model
      .lookupWord(word)
      .then((result) => {
        console.log("Dictionary API result:", result);
        if (result && result[0]) {
          setWordCard(result[0]);
        } else {
          console.log("No dictionary data found for word:", word);
          setWordCard({
            word: word,
            phonetics: { uk: null, us: null },
            definition: null,
            examples: null,
            relatedTerms: null,
          });
        }
      })
      .catch((error) => {
        console.error("Error looking up word:", error);
        setWordCard({
          word: word,
          phonetics: { uk: null, us: null },
          definition: null,
          examples: null,
          relatedTerms: null,
        });
      })
      .finally(() => {
        setIsLoading(false);
      });
  }

  async function handleAddToWordlist(wordData) {
    try {
      await saveWordToUserWordlist(wordData);
      return {
        success: true,
        message: "Added to the default wordlist",
        type: "success",
      };
    } catch (error) {
      console.error("Error saving word to wordlist:", error);
      
      // 根据后端返回的错误信息处理
      if (error.message && error.message.includes("Authentication")) {
        return { success: false, message: "Please Login First", type: "warning" };
      }
      
      return { success: false, message: error.message || "Failed to save word", type: "error" };
    }
  }

  return { wordCard, handleWordSelect, handleAddToWordlist, isLoading };
}

//   const [wordCard, setWordCard] = useState({
//     word: "",
//     phonetics: { uk: null, us: null },
//     definition: null,
//     examples: null,
//     relatedTerms: null,
//   });

//   /**
//    * Handle word selection and lookup
//    * @param {string} word - The selected word to look up
//    */
//   function handleWordSelect(word) {
//     const cleanWord = word.replace(/[^\w'-]/g, "");
//     console.log("Looking up word:", cleanWord);
//     props.model
//       .lookupWord(cleanWord)

//       .then((result) => {
//         console.log("Dictionary API result:", result);
//         if (result && result[0]) {
//           setWordCard(result[0]);
//         } else {
//           console.log("No dictionary data found for word:", cleanWord);
//           setWordCard({
//             word: cleanWord,
//             phonetic: null,
//             phonetics: [],
//             meanings: [],
//           });
//         }
//       })
//       .catch((error) => {
//         console.error("Error looking up word:", error);
//         setWordCard({
//           word: cleanWord,
//           phonetic: null,
//           phonetics: [],
//           meanings: [],
//         });
//       });
//   }

//   /**
//    * Handle adding word to user's wordlist
//    * First checks if user is logged in, then saves the word to Firestore
//    * @param {Object} wordData - The word data to save
//    * @returns {Object} - Result with success status and message
//    */
//   async function handleAddToWordlist(wordData) {
//     // Check if user is logged in
//     const user = loginModel.getUser();

//     if (!user) {
//       // User is not logged in, show message
//       return { success: false, message: "Please Login First", type: "warning" };
//     }

//     try {
//       // Save word to Firestore
//       await saveWordToUserWordlist(user.uid, wordData);
//       return {
//         success: true,
//         message: "Added to the default wordlist",
//         type: "success",
//       };
//     } catch (error) {
//       console.error("Error saving word to wordlist:", error);
//       return { success: false, message: "Failed to save word", type: "error" };
//     }
//   }
</file>

<file path="src/presenter/HomePagePresenter.tsx">
// src/presenter/HomePagePresenter.tsx (修正后的完整代码)

import { HomePageView } from "../views/HomePageView";
import { observer } from "mobx-react-lite";
import { useNavigate } from "react-router-dom";
import RecommendationRow from "../components/RecommendationRow";
import React, { useEffect, useState } from "react";
import { apiRequest } from "../config/apiConfig"; 
import { setPrefetch } from "../utils/prefetchCache";

type Props = { model: any };

const HomePagePresenter = observer(function HomePagePresenter(props: Props) {
  const navigate = useNavigate();
  const savedPodcasts = props.model.savedPodcasts;
  const [errorMsg, setErrorMsg] = useState("");
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [homeInput, setHomeInput] = useState("");

  // --- 新增：用于存储推荐播客的状态 ---
  const [recommendedItems, setRecommendedItems] = useState<any[]>([]);
  const [isRecLoading, setIsRecLoading] = useState(true);

  // --- 修正：使用一个独立的、简化的 useEffect 来获取推荐数据 ---
  useEffect(() => {
    let isMounted = true; // 防止组件卸载后继续更新状态

    async function loadRecommendations() {
      setIsRecLoading(true);
      try {
        // 1. 请求正确的后端 API 地址，并限制数量
        const response = await apiRequest('/api/podcasts/discover?sort=trending&max=8');
        if (!response.ok) {
          throw new Error('Failed to fetch trending podcasts');
        }
        const data = await response.json();
        if (isMounted) {
          setRecommendedItems(data);
          // setPrefetch("discover:trending:all:en", data);// 预取结果写入缓存，供 /search 首屏命中
        }
      } catch (error) {
        console.error("Could not load recommendations:", error);
        if (isMounted) {
          setRecommendedItems([]); // 失败时设置为空数组
        }
      } finally {
        if (isMounted) {
          setIsRecLoading(false);
        }
      }
    }

    loadRecommendations();

    return () => {
      isMounted = false; // 组件卸载时设置标志
    };
  }, []); // 空依赖数组，确保只在组件首次加载时运行一次


  // --- 输入框和导航逻辑 ---
  function inputHandlerACB(event: React.ChangeEvent<HTMLInputElement>) {
    setHomeInput(event.target.value);
    setErrorMsg("");
  }

  function handleGoClick() {
    const url = homeInput?.trim();
    if (!url) { 
      setErrorMsg("Please enter a search term or a RSS link"); 
      return; 
    }

    // 简单的URL格式检查，具体RSS验证交给后端
    try {
      new URL(url);
      // 看起来像URL -> 尝试作为RSS链接处理
      setErrorMsg("");
      props.model.setRssUrl(url); 
      props.model.loadRssData()
         .then(() => navigate("/podcast-channel"))
         .catch((error: any) => {
            // 如果RSS解析失败，作为搜索词处理
            console.log("RSS parsing failed, treating as search term:", error);
            navigate(`/search?q=${encodeURIComponent(url)}`);
         });
    } catch (e) {
      // 不是有效URL -> 作为关键词跳转到搜索页
      navigate(`/search?q=${encodeURIComponent(url)}`);
    }
  }

  function handleSavedPodcastClick(podcast: any) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.rssUrl } });
  }

  function handleSelectRecommendation(podcast: any) {
    if (podcast?.url) {
      navigate("/podcast-channel", { state: { rssUrl: podcast.url } });
    }
  }
  const handleSelectPodcast = (podcast: { url?: string }) => {
  if (podcast?.url) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.url } });
  } else {
    console.warn("Selected podcast is missing url (rssUrl).", podcast);
  }
  };

  return (
    <>
      <HomePageView
        url={homeInput} 
        onInputChange={inputHandlerACB}
        onParseClick={handleGoClick} // 使用统一的处理函数
        savedPodcasts={savedPodcasts}
        onSavedPodcastClick={handleSavedPodcastClick}
        errorMsg={errorMsg}
        snackbarOpen={snackbarOpen}
        onSnackbarClose={() => setSnackbarOpen(false)}
        recommendedItems={recommendedItems}
        isRecLoading={isRecLoading}
        onSelectPodcast={handleSelectPodcast}
      />
      <div style={{ maxWidth: 1200, margin: "16px auto", padding: "0 0px" }}>
      <RecommendationRow
        items={recommendedItems} // 直接使用新的 state
        onSelect={handleSelectRecommendation}
        isLoading={isRecLoading} // 传递加载状态
      />
      </div>
    </>
  );
});

export default HomePagePresenter;
</file>

<file path="src/presenter/loginPagePresenter.tsx">
import { useState, useEffect } from "react"
import loginModel from "../loginModel"
import LoginView from "../views/loginPageView"
// MongoDB API 调用
import { getUserProfile } from "../api/userAPI"
import { model } from "../Model"
import { useNavigate } from "react-router-dom";

type Props = { model: any }; // [fix]

function LoginPresenter(props:Props) {
  // Local state to manage view updates
  const [modelState, setModelState] = useState({
    isLoading: loginModel.getIsLoading(),
    user: loginModel.getUser()
  })

  const navigate = useNavigate();

  // Set up auth state listener without automatically triggering login popup
  useEffect(function effectCallback() {
    // Only responsible for synchronizing user status
    function onAuthChange() {
      updateViewState();
    }
    const unsubscribe = loginModel.setupAuthStateListener(onAuthChange);
    return function cleanup() {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Helper function to update view state from model
  function updateViewState() {
    setModelState({
      isLoading: loginModel.getIsLoading(),
      user: loginModel.getUser()
    });
  }

  function handleGoogleLogin(e) {
    e.preventDefault();
    setModelState(function(prev) { return {...prev, isLoading: true}; });

    loginModel.googleLogin()
      .then(function(result) {
        const user = "user" in result ? result.user : loginModel.getUser(); // [fix]
        // Load user data from MongoDB
        return getUserProfile().then(function(userData) {
          if (userData && userData.savedPodcasts) {
            model.savedPodcasts = userData.savedPodcasts;
          }
          // Navigate after successful login
          navigate("/");
        }).catch(function(error) {
          // 如果用户不存在于 MongoDB，这是首次登录，忽略错误
          console.log('First time login, user will be created on first data save');
          navigate("/");
        });
      })
      .catch(function(error) {
        alert("Login failed: " + error.message);
      })
      .finally(function() {
        setModelState(function(prev) {
          return {...prev, isLoading: false};
        });
      });
  }

  function handleLogout() {
    loginModel.logout()
      .then(function() {
        console.log("Logout successful");
        updateViewState();
        // Stay on the current page after logout
      })
      .catch(function(error) {
        console.error("Logout failed:", error.message);
        alert("Logout failed: " + error.message);
      });
  }

  // Pass data and event handlers to the view
  return (
    <LoginView
      isLoading={modelState.isLoading}
      user={modelState.user}
      onGoogleLogin={handleGoogleLogin}
      onLogout={handleLogout}
    />
  )
}
export default LoginPresenter
</file>

<file path="src/presenter/PodcastChannelPresenter.tsx">
import { observer } from "mobx-react-lite";
import { PodcastChannelView } from "../views/PodcastChannelView";
import { useState, useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
// 使用 MongoDB API 获取转录列表
import { getUserTranscriptions } from "../api/transcriptionAPI";
import loginModel from "../loginModel"; // Import login model to check user status


// 给 props 一个可用类型（后续再细化到真实 Model）
type Props = { model: any };                                               // [fix]

// Presenter component for podcast channel page
// Handles all business logic and state management
const PodcastChannelPresenter = observer(function PodcastChannelPresenter(
  props: Props                                                              // [fix]
) {
  const navigate = useNavigate();
  const location = useLocation();
  const rssUrl = location.state?.rssUrl || props.model.rssUrl;
  const model = props.model;
  const channelInfo = props.model.podcastChannelInfo;
  const episodes = props.model.podcastEpisodes as any[];                    // [fix]（最小：假定为数组）

  // State management
  const [user, setUser] = useState<any>(null);                               // [fix]
  const [isSaved, setIsSaved] = useState<boolean>(false);                    // [fix]
  const [transcribedGuids, setTranscribedGuids] = useState<string[]>([]);    // [fix]
  const [savedEpisodes, setSavedEpisodes] = useState<any[]>([]);             // [fix]
  const [filterType, setFilterType] = useState<"all" | "transcribed" | "untranscribed">("all"); // [fix]
  const [visibleCount, setVisibleCount] = useState<number>(10);              // [fix]
  const [snackbarState, setSnackbarState] = useState<{                      // [fix]
    open: boolean;
    message: string;
    severity: "success" | "warning" | "error" | "info";
  }>({
    open: false,
    message: "",
    severity: "success",
  });

  // Initialize user state
  useEffect(function initUser() {
    const currentUser = loginModel.getUser();
    setUser(currentUser);
  }, []);

  // Add auth state listener
  useEffect(function setupAuthListener() {
    const unsubscribe = loginModel.setupAuthStateListener(function(user) {
      setUser(user);
    });
    return function cleanup() {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Load RSS data and transcription data
  useEffect(function loadData() {
    if (rssUrl) {
      model.setRssUrl(rssUrl);
      model.loadRssData();
    }

    loadTranscriptionData();
  }, [rssUrl, user]);

  // Function to load transcription data
  function loadTranscriptionData() {
    if (user) {
      // 从 MongoDB 获取转录列表（无需 uid）
      getUserTranscriptions().then(function handleTranscriptions(transcriptions) {
        const guids = transcriptions.map(function getEpisodeId(t) {
          return t.episodeId.trim();
        });
        setTranscribedGuids(guids);
      }).catch(function(error) {
        console.error("Error loading transcription data:", error);
      });
    }
  }

  // Check if podcast is saved
  useEffect(function checkSavedStatus() {
    if (channelInfo) {
      function isPodcastSaved(podcast) {
        return podcast.title === channelInfo.title;
      }
      const saved = model.savedPodcasts.find(isPodcastSaved);
      setIsSaved(!!saved);
    }
  }, [model.savedPodcasts, channelInfo]);

  // Mark transcribed episodes
  useEffect(function markTranscribedEpisodes() {
    if (episodes.length > 0) {
      function markIfTranscribed(episode) {
        const hasTranscript = transcribedGuids.includes(episode.guid.trim());
        return { ...episode, isTranscribed: hasTranscript };
      }
      const markedEpisodes = episodes.map(markIfTranscribed);
      setSavedEpisodes(markedEpisodes);
    }
  }, [episodes, transcribedGuids]);

  // Handle scroll loading
  useEffect(function handleScrollLoading() {
    function handleScroll() {
      if (
        window.innerHeight + window.scrollY >= document.body.offsetHeight - 100 &&
        visibleCount < episodes.length
      ) {
        setVisibleCount(function incrementCount(prev) {
          return prev + 5;
        });
      }
    }
    window.addEventListener("scroll", handleScroll);
    return function cleanup() {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [visibleCount, episodes.length]);

  // Show snackbar notification
  function showSnackbar(message: string, severity: "success" | "warning" | "error" | "info" = "success") { // [fix]
    setSnackbarState({
      open: true,
      message: message,
      severity: severity,
    });
  }

  // Handle snackbar close
  function handleSnackbarClose(event, reason) {
    if (reason === "clickaway") return;
    setSnackbarState(function updateState(prev) {
      return { ...prev, open: false };
    });
  }

  // Handle episode play
  function handlePlay(episode) {
    if (!episode) {
      alert("Episode not found");
      return;
    }

    if (episode.enclosure.url) {
      model.setAudioUrl(episode.enclosure.url);
    } else {
      console.error("Episode does not have a valid audio URL:", episode);
    }

    model.setCurrentEpisode(episode);
    model.setAudioUrl(episode.enclosure.url);
    navigate("/podcast-play");
  }

  // Add event listener for transcription completion
  useEffect(function setupTranscriptionListener() {
    function handleTranscriptionComplete(event) {
      loadTranscriptionData();
    }
    
    window.addEventListener("transcriptionComplete", handleTranscriptionComplete);
    
    return function cleanup() {
      window.removeEventListener("transcriptionComplete", handleTranscriptionComplete);
    };
  }, [user]);

  // Handle podcast save
  function savePodcastHandler(podcast) {
    const currentUser = loginModel.getUser();
    if (!currentUser) {
      return { success: false, message: "Please Login First", type: "warning" };
    }
    if (!podcast.rssUrl) {
      podcast.rssUrl = rssUrl;
    }
    model.addToSaved(podcast);
    setIsSaved(true);
    return { success: true, message: "Podcast saved successfully", type: "success" };
  }

  // Handle podcast remove
  function removePodcastHandler(podcast) {
    const currentUser = loginModel.getUser();
    if (!currentUser) {
      return { success: false, message: "Please Login First", type: "warning" };
    }
    model.removeFromSaved(podcast);
    setIsSaved(false);
    return { success: true, message: "Podcast removed from saved list", type: "success" };
  }

  // Handle filter change
  function handleFilterChange(event, newFilter) {
    if (newFilter !== null) {
      setFilterType(newFilter);
    }
  }

  // Filter episodes based on type
  function filterEpisodes(ep) {
    if (filterType === "transcribed") return ep.isTranscribed;
    if (filterType === "untranscribed") return !ep.isTranscribed;
    return true;
  }

  const filteredEpisodes = savedEpisodes.filter(filterEpisodes);

  if (!channelInfo || episodes.length === 0) {
    return (
      <PodcastChannelView
        channelInfo={{}}                 // 不给真实内容
        episodes={Array.from({ length: 8 }, () => ({}))} // 固定数量占位项
        isSaved={false}
        onSavePodcast={() => ({ success: false, message: "", type: "info" })} // 占位回调
        onRemovePodcast={() => ({ success: false, message: "", type: "info" })}
        onPlay={() => {}}
        filterType="all"
        onFilterChange={() => {}}
        snackbarState={{ open: false, message: "", severity: "success" }}
        onSnackbarClose={() => {}}
        loading={true}                   // ← 关键
      />
    );
  }

  return (
    <PodcastChannelView
      channelInfo={channelInfo}
      episodes={filteredEpisodes.slice(0, visibleCount)}
      isSaved={isSaved}
      onSavePodcast={savePodcastHandler}
      onRemovePodcast={removePodcastHandler}
      onPlay={handlePlay}
      filterType={filterType}
      onFilterChange={handleFilterChange}
      snackbarState={snackbarState}
      onSnackbarClose={handleSnackbarClose}
    />
  );
});

export default PodcastChannelPresenter;
</file>

<file path="src/presenter/PodcastPlayPresenter.tsx">
import { observer } from "mobx-react-lite";
import { PodcastPlayView } from "../views/PodcastView/PodcastPlayView";
import { useCallback, useEffect, useState } from "react";
import { useTranscriptionSync } from "../hooks/useTranscriptionSync";
import { useWordLookup } from "../hooks/useWordLookup";
import { useNavigate } from "react-router-dom";
// 使用 MongoDB API 加载转录数据
import { getTranscriptionData, checkTranscriptionExists } from "../api/transcriptionAPI";
import loginModel from "../loginModel"; // Import login model to check user status
import { useTranscriptionManager } from "../hooks/useTranscriptionManager";
import { runInAction } from "mobx";

type Props = { model: any };                               

const PodcastPlayPresenter = observer(function PodcastPlayPresenter(
  props: Props                                                              // [fix: annotate props with Props]
) {
  const navigate = useNavigate();
  const episode =
    props.model.currentEpisode ||
    JSON.parse(localStorage.getItem("currentEpisode"));
  const [isLoading, setIsLoading] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const { handleTranscribe } = useTranscriptionManager({
    model: props.model,
    episode,
    setIsTranscribing,
    setIsLoading,
  });
  const processedTranscriptionData = processTranscriptionData();
  const data = props.model.transcripResultsPromiseState.data;
  const error = props.model.transcripResultsPromiseState.error;
  const { wordCard, handleWordSelect, handleAddToWordlist } = useWordLookup(props.model);

  // set current episode from localStorage
  useEffect(() => {
    if (!props.model.currentEpisode) {
      const localEpisode = JSON.parse(localStorage.getItem("currentEpisode"));
      if (localEpisode) {
        props.model.setCurrentEpisode(localEpisode);
      }
    }
  }, []);


  // Save current episode to localStorage
  useEffect(
    function saveCurrentEpisode() {
      if (episode) {
        localStorage.setItem("currentEpisode", JSON.stringify(episode));
      }
    },
    [episode]
  );

  useEffect(() => {
    // clear transcription results
    runInAction(() => {
      props.model.transcripResultsPromiseState.error = null;
      props.model.transcripResultsPromiseState.data = null;
    });

    if (!episode) return;
    console.log("Episode changed to:", episode.title);
    props.model.setResults([]);
    props.model.setAudioDuration(0);
    props.model.setAudioFile(null);

    async function fetchTranscriptFromMongoDB() {
      const user = loginModel.getUser();
      if (user && episode?.guid) {
        try {
          // 先检查转录数据是否存在，避免404错误
          const exists = await checkTranscriptionExists(episode.guid);
          if (exists) {
            // 如果存在，则获取转录数据
            const phrases = await getTranscriptionData(episode.guid);
            if (phrases && phrases.length > 0) {
              console.log(`找到转录数据 - Episode: ${episode.guid}, 短语数量: ${phrases.length}`);
              props.model.setResults(phrases);
            }
          }
          // 如果不存在，静默处理，不发起请求
        } catch (error) {
          console.log(`获取转录数据失败 - Episode: ${episode.guid}`, error);
        }
      }
    }
    fetchTranscriptFromMongoDB();
  }, [props.model.currentEpisode]);

  function getTimestamp(phrase: any) {
    const totalMilliseconds = phrase.offsetMilliseconds || 0;
    const totalSeconds = Math.floor(totalMilliseconds / 1000);
    const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
    const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(
      2,
      "0"
    );
    const seconds = String(totalSeconds % 60).padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  }

  // Extract the transcribed text
  function getSentence(phrase: any) {
    return phrase.text || "No text available";
  }

  function processTranscriptionData() {
    const results = [];
    for (let i = 0; i < props.model.transcripResults.length; i++) {
      const phrase = props.model.transcripResults[i];
      results.push({
        timestamp: getTimestamp(phrase),
        text: getSentence(phrase),
        offsetMilliseconds: phrase.offsetMilliseconds || 0,
      });
    }
    return results;
  }

  const handleTimeUpdate = useCallback((timeMs: number) => {
    setCurrentTime(timeMs);
  }, []);

  useTranscriptionSync({
    model: props.model,
    episode,
    data,
    error,
    setIsTranscribing,
    setIsLoading,
  });

  //back to channel page
  function handleBack() {
    navigate("/podcast-channel");
  }
  if (!episode) {
    return (
      <div style={{ padding: "2rem" }}>
        {" "}
        <p>No episode data</p> <button onClick={handleBack}>← Back</button>{" "}
      </div>
    );
  }

  function getPodcastData() {
    // Handle case where image might be an array
    const getCoverImage = () => {
      if (!episode.image) return "";
      if (Array.isArray(episode.image)) {
        return episode.image[0] || "";
      }
      return episode.image;
    };

    return {
      title: episode.title,
      description: episode.description,
      audioUrl: props.model.audioUrl,
      duration: episode.duration,
      source: props.model?.podcastChannelInfo?.title || "Podcast",
      coverImage: getCoverImage(),
    };
  }

  return (
    <PodcastPlayView
      podcastData={getPodcastData()}
      onTimeUpdate={handleTimeUpdate}
      // audioDuration={props.model.audioDuration}
      transcriptionData={processedTranscriptionData}
      wordCard={wordCard}
      // AudioPlayerComponent={AudioPlayer}
      // audioSrc={props.model.audioUrl}
      onWordSelect={handleWordSelect}
      onTranscribe={handleTranscribe}
      // isLoading={isLoading}
      isTranscribing={isTranscribing}
      currentTime={currentTime}
      // onTimeUpdate={handleTimeUpdate}
      onAddToWordlist={handleAddToWordlist} // Pass wordlist handler to View
    />
  );
});

export default PodcastPlayPresenter;
</file>

<file path="src/presenter/PodcastSearchPresenter.tsx">
// src/presenter/PodcastSearchPresenter.tsx

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { observer } from 'mobx-react-lite';
import { useNavigate, useLocation } from 'react-router-dom';
import { PodcastSearchView } from '../views/PodcastSearchView';
import { apiRequest } from '../config/apiConfig';
import { getPrefetch, setPrefetch } from '../utils/prefetchCache';

type Props = { model: any };

const DEFAULT_LANG = 'en';
const PREFETCH_KEY = 'discover:trending:all:en' as const;

const PodcastSearchPresenter = observer(function PodcastSearchPresenter({ model }: Props) {
  const navigate = useNavigate();
  const location = useLocation();

  // --- State ---
  const [searchTerm, setSearchTerm] = useState('');
  const [displayMode, setDisplayMode] = useState<'discover' | 'search'>('discover');
  const [sortOrder, setSortOrder] = useState<'trending' | 'recent'>('trending');
  const [categories, setCategories] = useState<{ id: string; name: string }[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<string | false>('all');
  const [podcasts, setPodcasts] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [displayTitle, setDisplayTitle] = useState('Trending Podcasts');
  const [error, setError] = useState<string | null>(null);

  const sentinelRef = useRef(null);

  // NEW: 请求序号，防止旧请求覆盖新请求
  const requestIdRef = useRef(0);

  // --- Fetchers ---

  // NEW: 包一层，自动做竞态检查
  const safeSetData = useCallback((reqId: number, updater: () => void) => {
    if (requestIdRef.current === reqId) updater();
  }, []);

  const fetchDiscoverData = useCallback(
    async (
      category: string,
      sort: 'trending' | 'recent',
      lang: string = DEFAULT_LANG,
      options: { silent?: boolean } = {}
    ) => {
      const { silent = false } = options;
      const myReqId = ++requestIdRef.current; // NEW: 本次请求序号

      if (!silent) setIsLoading(true);
      setError(null);

      const params = new URLSearchParams({ lang, sort });
      if (category && category !== 'all') params.append('category', category);

      try {
        const response = await apiRequest(`/api/podcasts/discover?${params.toString()}`);
        if (!response.ok) throw new Error('Failed to fetch discovery data. Please try again later.');
        const data = await response.json();

        // NEW: 仅当仍是最新请求时才写入
        safeSetData(myReqId, () => {
          setPodcasts(data);
          if (category === 'all' && sort === 'trending' && lang === DEFAULT_LANG) {
            setPrefetch(PREFETCH_KEY, data);
          }
        });
      } catch (err: any) {
        console.error('Failed to fetch discover data:', err);
        safeSetData(myReqId, () => {
          setError(err.message);
          setPodcasts([]);
        });
      } finally {
        safeSetData(myReqId, () => {
          if (!silent) setIsLoading(false);
        });
      }
    },
    [safeSetData]
  );

  const fetchSearchResults = useCallback(async (term: string) => {
    if (!term.trim()) return;
    const myReqId = ++requestIdRef.current; // NEW
    setIsLoading(true);
    setError(null);
    try {
      const response = await apiRequest(`/api/podcasts/search?q=${encodeURIComponent(term)}`);
      if (!response.ok) throw new Error('Failed to fetch search results. Please try again later.');
      const data = await response.json();
      safeSetData(myReqId, () => setPodcasts(data));
    } catch (err: any) {
      console.error('Failed to fetch search results:', err);
      safeSetData(myReqId, () => {
        setError(err.message);
        setPodcasts([]);
      });
    } finally {
      safeSetData(myReqId, () => setIsLoading(false));
    }
  }, [safeSetData]);

  // --- Effects ---

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const res = await apiRequest('/api/podcasts/categories');
        if (!res.ok) throw new Error('Failed to load categories');
        const data = await res.json();
        if (mounted) setCategories(data);
      } catch (err) {
        console.error(err);
        if (mounted) {
          setError('Could not load podcast categories. Some features may be unavailable.');
        }
      }
    })();
    return () => {
      mounted = false;
    };
  }, []);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const queryFromUrl = params.get('q');
    const categoryFromUrl = (params.get('category') || 'all').toLowerCase();
    const sortFromUrl = ((params.get('sort') as 'trending' | 'recent') || 'trending') as
      | 'trending'
      | 'recent';

    if (queryFromUrl) {
      // 搜索模式
      setDisplayMode('search');
      setSearchTerm(queryFromUrl);
      setSelectedCategory(false);
      setSortOrder('trending');
      setDisplayTitle(`Search Results for "${queryFromUrl}"`);

      setPodcasts([]);             // NEW: 切换模式先清屏
      setIsLoading(true);          // NEW: 仅显示骨架
      fetchSearchResults(queryFromUrl);
      return;
    }

    // 发现模式
    setDisplayMode('discover');
    setSearchTerm('');
    setSelectedCategory(categoryFromUrl);
    setSortOrder(sortFromUrl);

    const catObj = categories.find((c) => c.name === categoryFromUrl);
    const catName = categoryFromUrl === 'all' ? 'All Categories' : catObj?.name || categoryFromUrl;
    const sortName = sortFromUrl.charAt(0).toUpperCase() + sortFromUrl.slice(1);
    setDisplayTitle(`${sortName} in ${catName}`);

    // NEW: 切换 tab/排序 => 清屏 + 骨架
    setPodcasts([]);
    setIsLoading(true);

    // 命中缓存（仅默认组合）
    if (categoryFromUrl === 'all' && sortFromUrl === 'trending') {
      const cached = getPrefetch(PREFETCH_KEY);
      if (cached && cached.length) {
        setPodcasts(cached);     // 秒开
        setIsLoading(false);     // 结束首屏 loading
        fetchDiscoverData('all', 'trending', DEFAULT_LANG, { silent: true }); // 静默校准
        return;
      }
    }

    // 常规拉取
    if (categories.length > 0 || categoryFromUrl === 'all') {
      fetchDiscoverData(categoryFromUrl, sortFromUrl, DEFAULT_LANG);
    }
  }, [location.search, categories, fetchDiscoverData, fetchSearchResults]);

  // --- Handlers ---
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => setSearchTerm(e.target.value);

  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    navigate(`/search?q=${encodeURIComponent(searchTerm)}`);
  };

  const handleSortChange = (e: React.MouseEvent<HTMLElement>, newSortOrder: string | null) => {
    if (newSortOrder && (newSortOrder === 'trending' || newSortOrder === 'recent')) {
      const params = new URLSearchParams(location.search);
      params.set('sort', newSortOrder);
      params.delete('q');
      navigate(`/search?${params.toString()}`);
    }
  };

  const handleCategoryChange = (e: React.SyntheticEvent, newCategory: string) => {
    const params = new URLSearchParams();
    if (newCategory && newCategory !== 'all') params.set('category', newCategory);
    params.set('sort', sortOrder);
    navigate(`/search?${params.toString()}`);
  };

  const handlePodcastSelect = (podcast: any) => {
    if (podcast?.url) {
      navigate('/podcast-channel', { state: { rssUrl: podcast.url } });
    } else {
      setError('This podcast does not have a valid RSS feed URL.');
      console.error('Podcast does not have a valid RSS feed URL.', podcast);
    }
  };

  // NEW: 列表 key，切换 tab/排序强制重挂，避免过渡残影
  const listKey = `discover-${sortOrder}-${selectedCategory || 'none'}`;

  return (
    <PodcastSearchView
      key={listKey}                 // NEW: 强制 remount 列表容器
      searchTerm={searchTerm}
      onSearchTermChange={handleSearchChange}
      onSearchSubmit={handleSearchSubmit}
      sortOrder={sortOrder}
      onSortChange={handleSortChange}
      categories={categories}
      selectedCategory={selectedCategory}
      onCategoryChange={handleCategoryChange}
      displayTitle={displayTitle}
      podcasts={podcasts}
      onPodcastSelect={handlePodcastSelect}
      isLoading={isLoading}
      error={error}
      sentinelRef={sentinelRef}
      hasMore={false}
      isLoadingMore={false}
    />
  );
});

export default PodcastSearchPresenter;
</file>

<file path="src/presenter/SavedPodcastsPresenter.tsx">
import { observer } from "mobx-react-lite";
import { SavedPodcastsView } from "../views/SavedPodcastsView";

// 新增：给 props 一个最小类型 
type Props = { model: any };   

var SavedPodcastsPresenter = observer(function SavedPodcastsPresenter(
  props: Props                            
) {
  return (
    <SavedPodcastsView savedPodcasts={props.model.savedPodcasts} />
  );
});

export default SavedPodcastsPresenter;
</file>

<file path="src/presenter/WordlistPresenter.tsx">
import { observer } from "mobx-react-lite";
import { WordlistView } from "../views/WordlistView";
import { useState, useEffect } from "react";
// MongoDB API 调用
import { getUserWordlist, deleteWordFromUserWordlist } from "../api/userAPI";
import loginModel from "../loginModel";

/**
 * Wordlist Presenter Component - Part of the Presenter layer in MVP
 * Manages the retrieval and display of user's saved words
 */

// 新增：给 props 一个最小类型 
type Props = { model: any };   

const WordlistPresenter = observer(function WordlistPresenter(
  props: Props 
) {
  // State for handling wordlist display and selection
  const [userWords, setUserWords] = useState<any[]>([]); // [fix] 最小类型，防止 TS 推成 never[]
  const [selectedWordIndex, setSelectedWordIndex] = useState<number>(-1); // [fix]
  const [isLoading, setIsLoading] = useState<boolean>(true); // [fix]
  const [error, setError] = useState<string | null>(null); // [fix]
  
  // Fetch user words when component mounts or login state changes
  useEffect(() => {
    async function fetchUserWords() {
      setIsLoading(true);
      setError(null);
      
      const user = loginModel.getUser();
      if (user) {
        try {
          const words = await getUserWordlist();
          setUserWords(words);
          // Select first word if available
          if (words.length > 0) {
            setSelectedWordIndex(0);
          }
        } catch (err) {
          console.error("Error fetching wordlist:", err);
          setError("Failed to load wordlist. Please try again later.");
        }
      } else {
        setUserWords([]);
        setSelectedWordIndex(-1);
      }
      
      setIsLoading(false);
    }
    
    fetchUserWords();
  }, [loginModel.getUser()]); // Re-fetch when user login state changes
  
  /**
   * Handle selection of a word from the wordlist
   * @param {number} index - The index of the selected word
   */
  const handleWordSelect = (index) => {
    setSelectedWordIndex(index);
  };
  
  // Get the currently selected word for display in the details panel
  const selectedWord = selectedWordIndex >= 0 && selectedWordIndex < userWords.length 
    ? userWords[selectedWordIndex] 
    : null;
    
  const handleDeleteWord = async (index: number) => {
  const user = loginModel.getUser();
  if (!user) return;

  const wordToDelete = userWords[index];
  if (!wordToDelete) return;

  // 计算删除后的选中索引（在 setState 之前先算好）
  const newLength = userWords.length - 1;
  let nextSelected = selectedWordIndex;

  if (index === selectedWordIndex) {
    nextSelected = newLength === 0 ? -1 : Math.min(index, newLength - 1);
  } else if (index < selectedWordIndex) {
    nextSelected = selectedWordIndex - 1;
  }

  // 乐观更新本地状态
  setUserWords((prev) => prev.filter((_, i) => i !== index));
  setSelectedWordIndex(nextSelected);

  // 同步远端
  try {
    await deleteWordFromUserWordlist(wordToDelete.word);
  } catch (error) {
    // 失败时回滚为服务器最新（简单起见，重新拉取）
    try {
      const words = await getUserWordlist();
      setUserWords(words);
      setSelectedWordIndex(words.length ? 0 : -1);
      setError("Failed to delete word (server). Refreshed your list.");
    } catch (e) {
      setError("Failed to delete and refresh wordlist.");
    }
  }
};

  return (
    <WordlistView 
      words={userWords}
      selectedWordIndex={selectedWordIndex}
      selectedWord={selectedWord}
      onWordSelect={handleWordSelect}
      isLoading={isLoading}
      error={error}
      isLoggedIn={!!loginModel.getUser()}
      onDeleteWord={handleDeleteWord}
    />
  );
}); 
export default WordlistPresenter;
</file>

<file path="src/styles/AudioPlayer.css">
.audio-player-container {
  width: 100%;
  padding: 10px;
}

.audio-player {
  width: 100%;
}
</file>

<file path="src/styles/CollapseBox.css">
.collapse-box {
  background: transparent;
  border: none;
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.collapse-toggle-btn {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background: transparent;
  border: none;
  color: #4285f4;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 500;
  cursor: pointer;
  padding: 0 0 0 0;
  outline: none;
  transition: color 0.2s;
}
.collapse-toggle-btn:hover {
  color: #2a65c4;
}
.collapse-arrow {
  display: inline-block;
  margin-right: 8px;
  border: solid #4285f4;
  border-width: 0 2px 2px 0;
  padding: 4px;
  transform: rotate(45deg);
  transition: transform 0.2s;
}
.collapse-arrow.open {
  transform: rotate(225deg);
}
.collapse-content {
  background: transparent;
  border: none;
  padding: 16px 0 0 0;
  width: 100%;
}
.rss-guide-list {
  text-align: left;
  font-size: 16px;
  line-height: 1.7;
  margin: 0 0 0 18px;
  padding: 0;
}
.rss-guide-list li {
  margin-bottom: 8px;
}
.rss-guide-bottom {
  font-size: 14px;
  color: #666;
  margin-top: 10px;
  text-align: left;
}
@media (max-width: 700px) {
  .collapse-box {
    max-width: 98vw;
  }
}
</file>

<file path="src/styles/HomePage.css">
.homepage-container {
  display: flex;
  flex-direction: column;
  padding: 20px 20px 40px;
  min-height: auto;
  align-items: center;
  background-color: #ffffff;
  position: relative;
}


.center-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 100px 20px 40px;
  justify-content: center; 
}

.logo-container {
  margin: 0 auto;
}

/* .top-nav {
  position: absolute;
  top: 10px;
  right: 20px;
  z-index: 100;
  background: none;
  border: none;
} */

.nav-links {
  display: flex;
  gap: 20px;
}

.nav-link {
  color: #333;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.nav-link:hover {
  background-color: #f5f5f5;
  color: #4285f4;
}

.logo-container {
  margin-top: 40px;
  margin-bottom: 40px;
}

.logo {
  height: 50px;
}

.search-container {
  width: 100%;
  max-width: 600px;
  margin-bottom: 30px;
  position: relative;
  display: flex;
  gap: 8px;
  margin: 0 auto;
  max-width: 600px;
}

/* .search-input {
  flex: 1;
  padding: 15px 20px;
  border-radius: 25px;
  border: 1px solid #e0e0e0;
  background-color: #f5f5f5;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  outline: none;
  transition: all 0.3s ease;
} */

.search-input:focus {
  border-color: #4285f4;
  box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.1);
}

.search-button {
  background: #4285f4;
  border: none;
  border-radius: 25px;
  padding: 0 28px;
  height: 48px;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 2px rgba(60, 60, 60, 0.03);
  transition: all 0.2s;
  margin-left: 8px;
}

.search-button:hover {
  background: #2a65c4;
  color: #fff;
  transform: scale(1.05);
  border: none;
}

/* .search-icon {
  font-size: 20px;
  color: #D8E3FF;
} */

.help-link {
  color: #4285f4;
  text-decoration: none;
  margin-bottom: 40px;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

.example-rss-link {
  color: #006BFE;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

.help-link-wrapper {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  padding: 0;
  height: auto;
  margin-top: 20px;
}

.collapse-box {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.collapse-toggle-btn {
  justify-content: center;
}

.collapse-content {
  width: 100%;
}

.rss-guide-list,
.rss-guide-bottom {
  text-align: left;
}

.saved-section {
  width: 100%;
  max-width: 1200px;
}

.saved-header {
  display: flex;
  align-items: center;
  margin-bottom: 24px;
  margin-top: 24px;
}

.saved-title {
  font-family: 'Candal', sans-serif;
  font-weight: 400;
  font-size: 20px;
  line-height: 32px;
  letter-spacing: 0px;
  text-align: center;
  color: #106EFF;
}

.saved-icon {
  color: #106EFF;
  margin-right: 10px;
  vertical-align: middle;
}

.saved-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  width: 100%;
}

.saved-item {
  /* background-color: #f5f5f5; */
  border-radius: 40px;
  padding: 20px;
  min-height: 150px;
  display: flex;
  flex-direction: column;
  justify-content: left;
  align-items: center;
  position: relative;
}

.saved-item-image-wrapper {
  width: 100%;
  aspect-ratio: 8/5;
  /* background: #eee; */
  border-radius: 20px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 15px;
  margin-top: 2px;
}

.saved-item-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  border-radius: 20px;
}

.saved-item-title {
  font-size: 20px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  margin: 0.5rem 0;
}

.saved-item-description {
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #6b7280;
  margin-bottom: 0.5rem;
  max-height: 2.8em;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
}

.no-saved-container {
  grid-column: 1 / -1;
  background-color: #f7f7f749;
  border-radius: 12px;
  border: 2px solid #e0e0e0;
  padding: 24px;
  width: 100%;
  box-sizing: border-box;
  text-align: center;
}

.no-saved-podcasts {
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #4472ce;
  text-align: center;
  width: 100%;
  margin-bottom: 20px;
}

.no-saved-image {
  width: 160px;
  height: 150px;
  margin-bottom: 0px;
}

.item-number {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.1);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #666;
}

.show-more {
  color: #4285f4;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  margin-top: 20px;
  text-align: right;
  display: block;
  padding: 0px 30px;
}

.show-more:hover {
  text-decoration: underline;
}

.top-nav .logo {
  display: non
  e;
}
</file>

<file path="src/styles/LoginPage.css">
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Inter", sans-serif;
  background-color: #ffffff;
  min-height: 100vh;
}

.login-wrapper {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #ffffff;
}

.login-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 400px;
  padding: 20px;
  text-align: center;
}

.login-title {
  color: #0066ff;
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 48px;
}

.google-sign-in-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: #ffffff;
  border: 1px solid #dadce0;
  border-radius: 4px;
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.25px;
  height: 40px;
  transition: all 0.2s ease;
  padding: 0;
  margin: 0 auto;
  color: #3c4043;
  min-width: 220px;
}

.google-sign-in-button:hover {
  background-color: #f8f9fa;
  border-color: #dadce0;
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.google-sign-in-button:active {
  background-color: #f1f3f4;
  border-color: #dadce0;
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
}

.google-sign-in-content {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 0 24px;
  height: 100%;
}

.google-icon {
  width: 18px;
  height: 18px;
}

.terms-text {
  margin-top: 24px;
  font-size: 12px;
  color: #5f6368;
}

.terms-link {
  color: #0066ff;
  text-decoration: none;
}

.terms-link:hover {
  text-decoration: underline;
}

.welcome-container {
  background-color: #f1f3f4;
  padding: 24px;
  border-radius: 8px;
  width: 100%;
  border: 1px solid #dadce0;
}

.welcome-text {
  color: #202124;
  margin-bottom: 16px;
  font-size: 14px;
}

.min-h-screen {
  min-height: 100vh;
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.bg-white {
  background-color: #ffffff;
}

.p-4 {
  padding: 1rem;
}

.mb-8 {
  margin-bottom: 2rem;
}

.w-10 {
  width: 2.5rem;
}

.h-10 {
  height: 2.5rem;
}

.bg-\[\#0066ff\] {
  background-color: #0066ff;
}

.mr-3 {
  margin-right: 0.75rem;
}

.text-4xl {
  font-size: 2.25rem;
}

.font-bold {
  font-weight: 700;
}

.text-\[\#0066ff\] {
  color: #0066ff;
}

.w-full {
  width: 100%;
}

.max-w-md {
  max-width: 28rem;
}

.space-y-4 > * + * {
  margin-top: 1rem;
}

.space-y-1 > * + * {
  margin-top: 0.25rem;
}

.text-sm {
  font-size: 0.875rem;
}

.text-gray-600 {
  color: #4b5563;
}

.relative {
  position: relative;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}

.border {
  border: 1px solid #e5e7eb;
}

.rounded-md {
  border-radius: 0.375rem;
}

.focus\:outline-none:focus {
  outline: none;
}

.focus\:ring-2:focus {
  box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);
}

.focus\:ring-\[\#0066ff\]:focus {
  box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);
}

.absolute {
  position: absolute;
}

.right-3 {
  right: 0.75rem;
}

.top-1\/2 {
  top: 50%;
}

.-translate-y-1\/2 {
  transform: translateY(-50%);
}

.text-gray-400 {
  color: #9ca3af;
}

.hover\:text-gray-600:hover {
  color: #4b5563;
}

.bg-\[\#4d8bff\] {
  background-color: #4d8bff;
}

.text-white {
  color: #ffffff;
}

.rounded-full {
  border-radius: 9999px;
}

.font-medium {
  font-weight: 500;
}

.hover\:bg-\[\#0055dd\]:hover {
  background-color: #0055dd;
}

.transition-colors {
  transition-property: color, background-color, border-color;
  transition-duration: 150ms;
}

.hover\:bg-\[\#3d7bff\]:hover {
  background-color: #3d7bff;
}

.space-y-3 > * + * {
  margin-top: 0.75rem;
}

.pt-2 {
  padding-top: 0.5rem;
}

.bg-\[\#f1f3f4\] {
  background-color: #f1f3f4;
}

.text-black {
  color: #000000;
}

.hover\:bg-\[\#e8eaed\]:hover {
  background-color: #e8eaed;
}

.mr-2 {
  margin-right: 0.5rem;
}

.login-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background-color: #fff;
}

.login-logo {
  margin-bottom: 4rem;
}

.login-logo-text {
  font-size: 2.5rem;
  font-weight: 700;
  color: #0066ff;
}

.login-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  background-color: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  transition: all 0.2s ease;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.login-button:hover {
  background-color: #f9fafb;
}

.login-button-icon {
  width: 1.25rem;
  height: 1.25rem;
  margin-right: 0.75rem;
}

.login-button-text {
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}

.login-terms {
  margin-top: 2rem;
  font-size: 0.75rem;
  color: #9ca3af;
  text-align: center;
  max-width: 16rem;
}

.login-terms-link {
  color: #6b7280;
  text-decoration: none;
}

.login-terms-link:hover {
  text-decoration: underline;
}
</file>

<file path="src/styles/PodcastChannel.css">
.podcast-channel-page {
  min-height: 100vh;
  background-color: #fff;
}

/* Navigation Bar */
/* .top-nav {
  width: 100%;
  padding: 1rem 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #fff;
  position: sticky;
  top: 0;
  z-index: 100;
} */

/* .nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1400px;
  margin: 0 auto;
}

.brand-link {
  font-size: 1.5rem;
  font-weight: 700;
  color: #111827;
  text-decoration: none;
  transition: color 0.2s ease;
} */

/* .brand-link:hover {
  color: #1a56db;
} */

/* .nav-links {
  display: flex;
  justify-content: flex-end;
  gap: 1.5rem;
}

.nav-link {
  color: #4b5563;
  text-decoration: none;
  font-size: 0.875rem;
  font-weight: 500;
  transition: color 0.2s ease;
} */

/* .nav-link:hover {
  color: #1a56db;
} */

/* Main Content */
.podcast-channel {
  max-width: 1200px;
  margin: 2rem auto 0;
  padding: 0 2rem;
}

/* Channel Header */
.channel-header {
  display: flex;
  gap: 2rem;
  margin-bottom: 3rem;
}

.channel-cover {
  flex-shrink: 0;
  width: 200px;
  height: 200px;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.channel-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.channel-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
}

.channel-title {
  font-size: 2rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
}

.channel-description {
  font-size: 1rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
}

.save-button {
  align-self: flex-start;
  padding: 0.5rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  color: #fff;
  background-color: #0066ff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.save-button:hover {
  background-color: #0052cc;
}

.save-button.saved {
  background-color: #059669;
}

.save-button.saved:hover {
  background-color: #047857;
}

/* Episodes Section */
.episodes-container {
  margin-top: 2rem;
}

.episodes-title {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 2rem;
}

.episodes-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.episode-card {
  display: flex;
  gap: 1.5rem;
  padding: 1.5rem;
  background-color: #fff;
  transition: background-color 0.2s ease;
}

.episode-card:hover {
  background-color: #f9fafb;
}

.episode-cover {
  flex-shrink: 0;
  width: 100px;
  height: 100px;
  border-radius: 20px;
  overflow: hidden;
}

.episode-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.episode-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.episode-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1rem;
}

.episode-title {
  font-size: 1rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.play-button {
  flex-shrink: 0;
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  color: #fff;
  background-color: #0066ff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.play-button:hover {
  background-color: #0052cc;
}

.play-button.saved {
  background-color: #059669;
}

.play-button.saved:hover {
  background-color: #047857;
}

.episode-description {
  font-size: 0.95rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
}

.episode-meta {
  display: flex;
  gap: 1rem;
  font-size: 0.875rem;
  color: #6b7280;
}

.episode-duration::before {
  content: "🎧";
  margin-right: 0.25rem;
}

.episode-date::before {
  content: "📅";
  margin-right: 0.25rem;
}
</file>

<file path="src/styles/PodcastPlay.css">
.podcast-play-page {
  min-height: 100vh;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

/* PodcastPlay.css */
.typography-scrollable::-webkit-scrollbar {
  width: 6px;
}
.typography-scrollable::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}
.typography-scrollable {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
}



/* Podcast Info Header */
/* .podcast-info-header {
  padding: 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #f9fafb;
  display: flex;
  align-items: flex-start;
  gap: 2rem;
} */

/* .episode-cover-image {
  width: 160px;
  height: 160px;
  border-radius: 8px;
  object-fit: cover;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
} */

/* .episode-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1rem;
} */

/* .channel-info {
  margin-bottom: 0.5rem;
} */

/* .channel-title {
  font-size: 1rem;
  color: #6b7280;
  font-weight: 500;
} */

/* .episode-title {
  font-size: 2.5rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 1rem;
  line-height: 1.2;
} */

/* .episode-description {
  font-size: 1rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
} */
/* 
.episode-meta {
  display: flex;
  gap: 1rem;
  color: #6b7280;
  font-size: 0.875rem;
} */

/* Main Content */
/* .podcast-play-content {
  padding: 2rem;
  flex: 1;
  transition: opacity 0.2s ease;
  position: relative;
} */

/* .podcast-play-content.dimmed {
  opacity: 0.7;
  pointer-events: none;
} */

/* Transcript Container */
/* .transcript-container {
  background-color: #fff;
  border-radius: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  width: 60%;
} */

/* Transcript Header */
/* .transcript-header {
  display: flex;
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 16px;
} */

/* .transcript-header {
  display: flex;
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 16px;
} */


/* .language-select-container {
  display: flex;
  align-items: center;
} */

/* .language-select {
  padding: 10px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: white;
  font-size: 16px;
  color: #333;
  cursor: pointer;
  outline: none;
  min-width: 120px;
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 8px center;
  background-size: 16px;
} */

/* .language-select:hover {
  border-color: #666;
} */

/* .language-select:focus {
  border-color: #1976d2;
  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
} */

/* Transcript Content */
.transcript-content {
  /* max-height: 1000px; */
  height: 100%;
  width: 100%;
  padding: 0rem 0.5rem;
  overflow-y: auto;
  scroll-behavior: smooth;
  position: relative; 
}

.transcript-row {
  display: flex;
  align-items: flex-start;
  margin-bottom: 8px;
  grid-template-columns: 0.8fr 2fr 1.2fr;
  gap: 1rem;
  padding: 0.5rem 0rem;
  border-bottom: 1px solid #f3f4f6;
  transition: background-color 0.2s ease;
}

.transcript-row:hover {
  background-color: #f9fafb;
}

.transcript-row:last-child {
  border-bottom: none;
}

.timestamp-column {
  width: 80px;
  font-size: 0.8rem;
  color: #888;
  flex-shrink: 0;
}

.transcription-cell {
  word-break: break-word; 
  overflow-wrap: break-word;
  white-space: pre-wrap; 
}

.translation-cell {
  line-height: 1.5;
  display: flex;
  align-items: center;
}

.timestamp-cell {
  color: #6b7280;
}

.timestamp-inline {
  font-size: 0.8rem;
  color: #888;
  /* margin-right: 8px; */
}

.translation-cell {
  color: #111827;
}

.translation-text {
  font-size: 0.95rem;
  color: #555;
  margin-top: 4px;
}

/* Dictionary Overlay */
.dictionary-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  z-index: 150;
  display: flex;
  justify-content: center;
  align-items: flex-start;
}

/* Dictionary Mask */
.dictionary-mask {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.1);
  z-index: 1000;
}

/* Dictionary Card */
.dictionary-card {
  position: fixed;
  width: 400px;
  min-width: 400px;
  max-width: 400px;
  height: auto;
  max-height: 400px;
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1001;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  bottom: 32px;
}

/* 词典卡片内容区域，滚动 */
.dictionary-card-content {
  flex: 1 1 auto;
  overflow-y: auto;
  margin-bottom: 1rem;
}

/* 固定底部按钮 */
.add-to-wordlist-btn {
  width: 100%;
  padding: 0.75rem;
  margin-top: 1.5rem;
  background-color: #2563eb;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: absolute;
  left: 0;
  bottom: 0;
  border-radius: 0 0 8px 8px;
  margin: 0;
}

.add-to-wordlist-btn:hover {
  background-color: #1d4ed8;
}

.add-to-wordlist-btn:active {
  background-color: #1e40af;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.word-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #e5e7eb;
}

.word-text {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.word-level {
  padding: 0.25rem 0.5rem;
  background-color: #e0f2fe;
  color: #0369a1;
  font-weight: 500;
  border-radius: 9999px;
  font-size: 0.75rem;
}

.word-phonetics {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.phonetic {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.phonetic-label {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  min-width: 30px;
}

.phonetic-text {
  color: #111827;
  font-family: monospace;
}

.phonetic-audio {
  height: 24px;
  margin-left: auto;
}

.meaning-section {
  margin-bottom: 1.5rem;
}

.part-of-speech {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
  font-style: italic;
}

.definition-item {
  margin-bottom: 1rem;
}

.definition-text {
  color: #374151;
  font-size: 0.875rem;
  line-height: 1.5;
  margin-bottom: 0.5rem;
}

.example-text {
  color: #4b5563;
  font-size: 0.875rem;
  line-height: 1.5;
  font-style: italic;
  padding-left: 1rem;
  border-left: 2px solid #e5e7eb;
}

.word-synonyms,
.word-antonyms {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #e5e7eb;
}

.word-synonyms h4,
.word-antonyms h4 {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
}

.synonyms-list,
.antonyms-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.synonym-tag,
.antonym-tag {
  padding: 0.25rem 0.75rem;
  background-color: #f3f4f6;
  color: #4b5563;
  border-radius: 9999px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.synonym-tag:hover,
.antonym-tag:hover {
  background-color: #e5e7eb;
}

/* Transcribe Button */
.transcribe-button {
  padding: 0.5rem 1.5rem;
  background-color: #006BFE;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.transcribe-button:hover {
  background-color: #4338CA;
  transform: translateY(-1px);
}

.transcribe-button:active {
  background-color: #3730A3;
  transform: translateY(0);
}

.transcript-row.active-row {
  background-color: #f1f5ff00;
  transition: background-color 0.3s ease;
}

.word-hover {
  cursor: pointer;
  padding: 0 0.2px; 
  transition: background-color 0.2s ease, color 0.2s ease;
}

.word-hover:hover {
  background-color: rgba(0, 26, 255, 0.753); 
  /* box-shadow: 0 0 0 4px rgba(0, 47, 255, 0.822); */
  color: white;
  padding: 2 0px; 
  /* border-radius: 6px;  */
}

.active-word {
  background-color: transparent; 
  color: #0400ff; 
  /* font-weight: bold;  */
}

.podcast-main-layout {
  display: flex;
  margin: 0 auto;
  gap: 2rem;
  padding-bottom: 90px; /* Adjust if player height changes */
}

.left-panel {
  flex: 0 0 45%; 
  display: flex;
  flex-direction: column;
}

.right-panel {
  width: 60%;
}

/* Notification Toast */
.notification-toast {
  position: fixed;
  bottom: 110px; /* 90px for player + 20px margin */
  left: 50%;
  transform: translateX(-50%);
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  color: white;
  z-index: 2000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  animation: fadeInUp 0.3s ease, fadeOutDown 0.3s ease 2.7s;
}

.notification-toast.info {
  background-color: #3498db;
}

.notification-toast.success {
  background-color: #2ecc71;
}

.notification-toast.warning {
  background-color: #f39c12;
}

.notification-toast.error {
  background-color: #e74c3c;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

@keyframes fadeOutDown {
  from {
    opacity: 1;
    transform: translate(-50%, 0);
  }
  to {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
}

/* Fixed bottom audio player */
.bottom-audio-player {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100vw;
  background: #fff;
  z-index: 2001;
  box-shadow: 0 -2px 8px rgba(0,0,0,0.08);
  padding: 0.5rem 0;
}
</file>

<file path="src/styles/Skeleton.css">
/* 图片骨架（即使没有 img.src 也会生效） */
.skeletonize .channel-cover::before,
.skeletonize .episode-cover::before {
  content: "";
  position: absolute; inset: 0;
  border-radius: 20px;
  background: #eee;
  animation: skel-shimmer 1.2s infinite;
  background-image: linear-gradient(90deg,transparent,rgba(255,255,255,.55),transparent);
}

/* 文本骨架：把占位的空格涂成条 */
.skeletonize .channel-title,
.skeletonize .channel-description,
.skeletonize .episode-title,
.skeletonize .episode-description,
.skeletonize .episode-meta span {
  color: transparent;
  background: #eee;
  border-radius: 8px;
}
</file>

<file path="src/styles/theme.ts">
// theme.js
import { createTheme } from "@mui/material/styles";

// Material Design 3 示例主色调：蓝色
const theme = createTheme({
  palette: {
    mode: "light", // 可切换为 "dark" 实现暗色模式
    primary: {
      main: "#0066ff",       // 主按钮、链接、操作颜色
      contrastText: "#ffffff",
    },
    secondary: {
      main: "#e0e0e0",       // 用于中性背景、分隔线等
    },
    background: {
      default: "#f9f9f9",    // 页面背景
      paper: "#ffffff",      // 卡片背景（Surface）
    },
    text: {
      primary: "#111827",    // 主文本
      secondary: "#4b5563",  // 副文本
    },
  },
  shape: {
    borderRadius: 12,        // 更圆的外观，符合 M3
  },
  typography: {
    fontFamily: "Roboto, sans-serif",
    button: {
      textTransform: "none", // 按钮不全大写，M3 推荐
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      defaultProps: {
        disableElevation: true, // M3 风格通常不使用阴影
      },
      styleOverrides: {
        root: {
          borderRadius: "999px", // Pill-style 按钮，视觉上圆润
          padding: "8px 20px",
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          boxShadow: "0px 2px 4px rgba(0, 0, 0, 0.08)",
        },
      },
    },
    MuiTypography: {
      styleOverrides: {
        h1: { fontSize: "2.5rem", fontWeight: 700 },
        h2: { fontSize: "2rem", fontWeight: 700 },
        h3: { fontSize: "1.75rem", fontWeight: 600 },
        body1: { fontSize: "1rem" },
        body2: { fontSize: "0.95rem" },
      },
    },
  },
});


export default theme;
</file>

<file path="src/styles/TopNav.css">
.top-nav {
  width: 100%;
  padding: 1rem 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #fff;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1400px;
  margin: 0 auto;
}

.brand-link {
  font-size: 1.5rem;
  font-family: 'Candal', sans-serif;
  font-weight: 700;
  color: #2f71ff !important;
  text-decoration: none;
  transition: color 0.2s ease;
}

.brand-link:hover {
  color: #0e42b1 !important;
}

.nav-links {
  display: flex;
  justify-content: flex-end;
  gap: 1.5rem;
  margin-left: auto; 
}

.nav-link {
  color: #4b5563;
  text-decoration: none;
  font-size: 0.875rem;
  font-weight: 500;
  transition: color 0.2s ease;
}

.nav-link:hover {
  color: #1a56db;
} 

.slogan-text {
  font-size: 18px;
  font-weight: 700;
  color: #106EFF;
  margin-left: 12px;
}
</file>

<file path="src/styles/Wordlist.css">
.page-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: #f9fafb;
}

.wordlist-container {
  flex: 1;
  display: flex;
  padding: 2rem;
  gap: 2rem;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

/* Sidebar Navigation */
.wordlist-sidebar {
  width: 300px;
  background-color: #fff;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  height: fit-content;
  max-height: 80vh;
  overflow-y: auto;
}

.sidebar-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
}

.wordlist-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  max-height: 60vh;
  overflow-y: auto;
}

.wordlist-item {
  padding: 0.75rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f9fafb;
}

.wordlist-item:hover {
  background-color: #f3f4f6;
}

.wordlist-item.selected {
  background-color: #eff6ff;
  border-left: 3px solid #3b82f6;
  color: #1d4ed8;
}

.wordlist-name {
  font-size: 0.95rem;
  font-weight: 500;
}

.wordlist-count {
  font-size: 0.75rem;
  color: #6b7280;
  background-color: #f3f4f6;
  padding: 0.25rem 0.5rem;
  border-radius: 999px;
  font-style: italic;
}

/* Main Content Area */
.wordlist-content {
  flex: 1;
  background-color: #fff;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  max-height: 80vh;
  overflow-y: auto;
}

.content-title {
  font-size: 2rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
}

/* Status Messages */
.login-prompt, 
.loading-state, 
.error-state, 
.empty-state,
.no-selection {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f9fafb;
  text-align: center;
  color: #4b5563;
  margin-top: 1rem;
}

.login-prompt {
  background-color: #eff6ff;
  border: 1px dashed #93c5fd;
}

.error-state {
  background-color: #fee2e2;
  border: 1px dashed #fca5a5;
  color: #b91c1c;
}

.loading-state {
  background-color: #f3f4f6;
  border: 1px dashed #d1d5db;
}

.empty-state {
  background-color: #f3f4f6;
  border: 1px dashed #d1d5db;
}

.no-selection {
  background-color: #f3f4f6;
  font-style: italic;
  padding: 3rem;
  text-align: center;
}

/* Word Details Styling */
.word-details {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.phonetics-section {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.phonetic-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.5rem;
  background-color: #f9fafb;
  border-radius: 6px;
}

.phonetic-text {
  font-family: monospace;
  font-size: 0.95rem;
  color: #4b5563;
}

.phonetic-audio-btn {
  background-color: #e0f2fe;
  border: none;
  color: #0369a1;
  padding: 0.35rem 0.75rem;
  border-radius: 4px;
  font-size: 0.875rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  transition: all 0.2s ease;
}

.phonetic-audio-btn:hover {
  background-color: #bae6fd;
}

.meaning-section {
  margin-bottom: 2rem;
  padding: 1rem;
  background-color: #f9fafb;
  border-radius: 8px;
  border-left: 4px solid #e5e7eb;
}

.part-of-speech {
  font-size: 1.1rem;
  font-weight: 500;
  color: #4b5563;
  font-style: italic;
  margin-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 0.5rem;
}

.definition-item {
  margin-bottom: 1.25rem;
  padding-left: 0.5rem;
  border-left: 2px solid #e5e7eb;
}

.definition-text {
  font-size: 1rem;
  line-height: 1.6;
  color: #111827;
  margin-bottom: 0.5rem;
}

.example-text {
  font-size: 0.95rem;
  line-height: 1.5;
  color: #6b7280;
  font-style: italic;
  padding-left: 1rem;
  margin-top: 0.5rem;
}

/* Synonyms and Antonyms */
.word-synonyms, .word-antonyms {
  margin-top: 1rem;
  padding-top: 0.75rem;
  border-top: 1px dashed #e5e7eb;
}

.word-synonyms h4, .word-antonyms h4 {
  font-size: 0.95rem;
  color: #4b5563;
  margin-bottom: 0.75rem;
}

.synonyms-list, .antonyms-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.synonym-tag, .antonym-tag {
  background-color: #f3f4f6;
  color: #4b5563;
  font-size: 0.875rem;
  padding: 0.35rem 0.75rem;
  border-radius: 999px;
  transition: all 0.2s ease;
}

.synonym-tag:hover, .antonym-tag:hover {
  background-color: #e5e7eb;
}

.word-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1rem;
}

.word-item {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f9fafb;
  border: 1px solid #e5e7eb;
  transition: all 0.2s ease;
}

.word-item:hover {
  background-color: #fff;
  border-color: #bfdbfe;
}

.word-text {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 0.75rem;
}

.word-phonetics {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid #e5e7eb;
}

.phonetic {
  font-size: 0.875rem;
  color: #6b7280;
  font-family: monospace;
  background-color: #fff;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  border: 1px solid #e5e7eb;
} 

.wordlist-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.wordlist-name {
  flex: 1 1 auto;
}

.wordlist-delete-btn {
  margin-left: 0.5rem;
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 9999px;
  background: transparent;
  color: #6b7280;
  display: inline-grid;
  place-items: center;
  cursor: pointer;

  /* 动效与显隐 */
  opacity: 0;
  transition: opacity .18s ease, background-color .18s ease, transform .12s ease, color .18s ease;
}

/* 悬停/选中时显现 */
.wordlist-item:hover .wordlist-delete-btn,
.wordlist-delete-btn:focus-visible {
   opacity: 1;
}

/* 悬停反馈：轻微高亮，引导用户“删除” */
.wordlist-delete-btn:hover {
  background-color: #f3f4f6;
  color: #1366d3;        
  transform: scale(1.06);
}
</file>

<file path="src/test/TestPresenter.tsx">
import { useState } from "react";
import { DictionaryAPI } from "../api/dictionaryAPI";

function TestPresenter() {
    const [word, setWord] = useState(""); 

    function testDictionaryAPI() {
        DictionaryAPI.getWord('Test')
            .then(data => {
                setWord(data);
            })
            .catch(error => {
                console.error('Query Failed:', error);
            });
    }

    testDictionaryAPI();

    return (
        <div>
            <h1>{JSON.stringify(word)}</h1>
        </div>
    )
}

export default TestPresenter;
</file>

<file path="src/utils/phoneticFormat.ts">
export function formatPhonetic(raw?: string): string {
  if (!raw) return "";
  let s = raw;

  // 1) 将星号当作音节点：*  -> ·
  // 连续多个 * 合并成一个
  s = s.replace(/\*+/g, "·");

  // 2) 如果有少见的中点替代符也统一一下（可选）
  s = s.replace(/[•∙⋅·]{2,}/g, "·"); // 合并重复音节点

  // 3) 音节点两侧留空格更易读（可选）
  s = s.replace(/\s*·\s*/g, " · ");

  // 4) 去掉多余空格
  s = s.replace(/\s{2,}/g, " ").trim();

  return s;
}
</file>

<file path="src/utils/prefetchCache.ts">
// 简易内存 + localStorage 双层缓存（5 分钟失效）
type Key = "discover:trending:all:en";
const LS_KEY = "listenary.prefetch.v1";

type CacheShape = {
  [key in Key]?: { ts: number; data: any[] }
}

const mem: CacheShape = {};

function readLS(): CacheShape {
  try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); } catch { return {}; }
}
function writeLS(obj: CacheShape) {
  try { localStorage.setItem(LS_KEY, JSON.stringify(obj)); } catch {}
}
export function getPrefetch(key: Key, maxAgeMs = 5 * 60 * 1000) {
  const now = Date.now();
  const inMem = mem[key];
  if (inMem && now - inMem.ts < maxAgeMs) return inMem.data;

  const ls = readLS()[key];
  if (ls && now - ls.ts < maxAgeMs) {
    mem[key] = ls; // 回灌内存
    return ls.data;
  }
  return null;
}
export function setPrefetch(key: Key, data: any[]) {
  const entry = { ts: Date.now(), data };
  mem[key] = entry;
  const ls = readLS();
  ls[key] = entry;
  writeLS(ls);
}
</file>

<file path="src/views/PodcastView/DictionaryCard.tsx">
import { useRef } from "react";
import { formatPhonetic } from "../../utils/phoneticFormat";

export function DictionaryCard({ wordCard, onClose, onAddToWordlist }) {
  const phoneticAudioRef = useRef(null);

  const playPhoneticAudio = (url) => {
    if (!url) return;
    if (phoneticAudioRef.current) {
      phoneticAudioRef.current.src = url;
      phoneticAudioRef.current.play();
    }
  };

  return (
    <>
      <div className="dictionary-mask" onClick={onClose} />
      <div
        className="dictionary-card"
        style={{
          top: `${wordCard.position?.top || 0}px`,
          left: `${wordCard.position?.left || 0}px`,
          zIndex: 1300,
        }}
      >
        <div className="dictionary-card-content">
          <div className="word-header">
            <h3 className="word-text">{wordCard?.word || "..."}</h3>
            <span className="word-level">
              {wordCard?.meanings?.[0]?.partOfSpeech || "N/A"}
            </span>
          </div>
          <div className="word-phonetics">
            <div className="phonetic">
              <span className="phonetic-label">Phonetic</span>
              {/* <span className="phonetic-text">
                {wordCard?.phonetic || "N/A"}
              </span> */}
              <span className="phonetic-text">
                {formatPhonetic(wordCard?.phonetic) || "N/A"}
              </span>
              {wordCard?.phonetics?.[0]?.audio && (
                <>
                  <button
                    className="phonetic-audio-btn"
                    onClick={() =>
                      playPhoneticAudio(wordCard.phonetics[0].audio)
                    }
                    title="Play pronunciation"
                  >
                    🔊
                  </button>
                  <audio ref={phoneticAudioRef} style={{ display: "none" }} />
                </>
              )}
            </div>
          </div>
          <div className="word-definition">
            {wordCard?.meanings?.map((meaning, index) => (
              <div key={index} className="meaning-section">
                <p className="part-of-speech">{meaning.partOfSpeech}</p>
                {meaning.definitions?.map((def, defIndex) => (
                  <div key={defIndex} className="definition-item">
                    <p className="definition-text">{def.definition}</p>
                    {def.example && (
                      <p className="example-text">"{def.example}"</p>
                    )}
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>
        <button className="add-to-wordlist-btn" onClick={onAddToWordlist}>
          Add to Wordlist
        </button>
      </div>
    </>
  );
}
</file>

<file path="src/views/PodcastView/PodcastInfoCard.tsx">
import {
  Box,
  Card,
  CardContent,
  CardMedia,
  Typography,
  Button,
  Tooltip,
} from "@mui/material";
import GraphicEqIcon from "@mui/icons-material/GraphicEq";

export function PodcastInfoCard({ podcastData, isTranscribing, onTranscribe }) {
  return (
    <Box
      className="left-panel"
      sx={{
        flexShrink: 0,
        width: { xs: "100%", md: 400 },
        height: "95%",
        display: "flex",
        flexDirection: "column"
      }}
    >
      <Card
        elevation={1}
        sx={{
          width: "100%",
          borderRadius: 6,
          display: "flex",
          flexDirection: "column",
          height: "100%"
        }}
      >
        <CardContent
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            flexShrink: 0,
            px: 3,
            py: 1.5
          }}
        >
          <Tooltip title={podcastData.source || "Name of Podcast"} arrow>
            <Typography
              variant="subtitle1"
              fontWeight={600}
              fontSize={20}
              lineHeight={1.3}
              sx={{
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
                maxWidth: "100%",
                cursor: "default"
              }}
            >
              {podcastData.source || "Name of Podcast"}
            </Typography>
          </Tooltip>
          <Box sx={{ flexGrow: 1 }}></Box>
        </CardContent>

        <CardMedia
          component="img"
          sx={{
            width: "100%",
            height: "auto",
            objectFit: "cover",
            maxHeight: { xs: 120, sm: 140, md: 160, lg: 220 },
            flexShrink: 1,
          }}
          image={podcastData.coverImage}
          alt="Podcast Cover"
        />

        <CardContent 
          sx={{ 
            display: "flex",
            flexDirection: "column",
            justifyContent: "space-between",  // 保证内容和按钮分开
            flexGrow: 1,
            minHeight: 0, // 避免无限撑高
            overflow: "hidden",
            p: 2
          }}
        >
          <Tooltip title={podcastData.title || "Episode Name"} arrow>
            <Typography
              variant="subtitle1"
              fontWeight={600}
              fontSize={22}
              gutterBottom
              noWrap
              sx={{
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
                cursor: "default",
                flexShrink: 0,
                maxWidth: "100%",
              }}
            >
              {podcastData.title || "Episode Name"}
            </Typography>
          </Tooltip>

          <Typography
            variant="body2"
            color="text.secondary"
            mt={1}
            className="typography-scrollable"
            sx={{
              lineHeight: 1.5,
              overflowY: "auto",
              pr: 1,
              flex: "1 1 auto",
              maxHeight: "none"
            }}
          >
            {podcastData.description || "Description..."}
          </Typography>
          <Box mt={2}>
            <Tooltip title="Only English podcasts are supported for now" arrow>
              <Button
                variant="contained"
                startIcon={<GraphicEqIcon />}
                size="small"
                onClick={onTranscribe}
                disabled={isTranscribing}
                sx={{
                  borderRadius: "100px",
                  textTransform: "none",
                  fontWeight: 600,
                  px: 2,
                  py: 0.5,
                  backgroundColor: "#006BFE",
                  color: "#fff",
                  boxShadow: 1,
                  width: "100%", // 宽度适配小屏
                  "&:hover": {
                    backgroundColor: "primary.dark",
                    boxShadow: 4
                  },
                  "&:disabled": {
                    backgroundColor: "grey.400",
                    color: "white"
                  }
                }}
              >
                {isTranscribing ? "Transcribing..." : "Transcribe"}
              </Button>
            </Tooltip>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
}
</file>

<file path="src/views/PodcastView/PodcastPlayView.tsx">
// import "../styles/PodcastPlay.css";
import { useNavigate } from "react-router-dom";
import { useState, useCallback, useRef, useEffect } from "react";
import { TopNav } from "@/components/TopNav.jsx";
import AudioPlayerComponent, {
  type AudioPlayerHandle,
} from "@/components/AudioPlayerComponent.jsx";
import { useTranslationHandler } from "@/hooks/useTranslationHandler";
import { Box, ThemeProvider, createTheme, Typography } from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import GraphicEqIcon from "@mui/icons-material/GraphicEq";
import { PodcastInfoCard } from "./PodcastInfoCard.jsx";
import { TranscriptList } from "./TranscriptList";
import { DictionaryCard } from "./DictionaryCard";

const theme = createTheme();

export function PodcastPlayView({
  podcastData,
  onTimeUpdate,
  transcriptionData = [],
  onWordSelect,
  onTranscribe,
  isTranscribing,
  currentTime,
  wordCard,
  onAddToWordlist,
}) {
  const [showDictionary, setShowDictionary] = useState(false);
  const [dictionaryPosition, setDictionaryPosition] = useState(null);
  const [targetLanguage, setTargetLanguage] = useState("");
  const [translations, setTranslations] = useState({});
  const [translatingItems, setTranslatingItems] = useState(new Set());
  const [notification, setNotification] = useState({
    show: false,
    message: "",
    type: "info",
  });

  const rowRefs = useRef([]);
  const phoneticAudioRef = useRef(null);
  const internalAudioRef = useRef<AudioPlayerHandle | null>(null); // [fix]

  useEffect(() => {
    return () => {
      if (internalAudioRef.current && internalAudioRef.current.pause) {
        internalAudioRef.current.pause();
        (internalAudioRef.current as any).currentTime = 0;
      }
    };
  }, []);

  useEffect(
    function setupAutoScroll() {
      if (!transcriptionData.length) return;

      function findCurrentIndex() {
        return transcriptionData
          .map(function (item, i) {
            return { ...item, i };
          })
          .filter(function (item) {
            return item.offsetMilliseconds <= currentTime;
          })
          .pop()?.i;
      }

      const index = findCurrentIndex();
      if (index !== undefined && rowRefs.current[index]) {
        rowRefs.current[index].scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest",
        });
      }
    },
    [currentTime, transcriptionData]
  );

  const languages = [
    { code: "", name: "Translation Language" },
    { code: "ZH-HANS", name: "中文" },
    { code: "DE", name: "Deutsch" },
    { code: "SV", name: "Svenska" },
    { code: "FR", name: "Français" },
    { code: "NL", name: "Nederlands" },
  ];

  const { handleLanguageChange } = useTranslationHandler({
    transcriptionData,
    setTargetLanguage,
    setTranslations,
    setTranslatingItems,
  });

  const handleWordClick = (word, event) => {
    const CARD_WIDTH = 400;
    const CARD_HEIGHT = 320;
    const CARD_MARGIN = 10;
    const PLAYER_HEIGHT = 90;
    const CARD_BOTTOM_SAFE = PLAYER_HEIGHT + 48;
    const rect = event.target.getBoundingClientRect();
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let left = rect.right + CARD_MARGIN;
    if (left + CARD_WIDTH > windowWidth) {
      left = rect.left - CARD_WIDTH - CARD_MARGIN;
      if (left < 10) left = 10;
    }

    let top;
    const spaceBelow = windowHeight - rect.bottom - CARD_BOTTOM_SAFE;
    if (spaceBelow >= CARD_HEIGHT) {
      top = rect.bottom + CARD_MARGIN;
    } else {
      top = rect.top - CARD_HEIGHT - CARD_MARGIN;
      if (top < 10) top = 10;
    }

    setDictionaryPosition({ top, left });
    setShowDictionary(true);
    onWordSelect(word);
  };

  const handleAddToWordlist = useCallback(async () => {
    const result = await onAddToWordlist(wordCard);
    // Show specific notification based on login and save status
    if (result.type === "warning") {
      showNotification("Please login first to save your wordlist", "warning");
    } else if (result.type === "success") {
      showNotification("saved to the default wordlist", "success");
    } else {
      showNotification(result.message, result.type || "info");
    }
    setShowDictionary(false);
  }, [wordCard, onAddToWordlist]);

  const showNotification = (message, type = "info") => {
    setNotification({ show: true, message, type });
    setTimeout(
      () => setNotification({ show: false, message: "", type: "info" }),
      3000
    );
  };

  const playPhoneticAudio = (url) => {
    if (!url) return;
    if (phoneticAudioRef.current) {
      phoneticAudioRef.current.src = url;
      phoneticAudioRef.current.play();
    }
  };

  return (
    <ThemeProvider theme={theme}>
      <div
        className="podcast-page"
        style={{ display: "flex", flexDirection: "column", height: "100vh" }}
      >
        <TopNav />
        <Box
          sx={{
            flex: "1 1 auto",
            display: "flex",
            flexDirection: { xs: "column", md: "row" },
            maxWidth: 1400,
            mx: "auto",
            px: 1,
            pt: 0,
            pb: 0,
            gap: 2.5,
            width: "85%",
            overflow: "hidden",
            // height: "calc(100vh - 64px - 75px)",
            mt: "24px",
            mb: "90px",
          }}
        >
          {/* Left panel with podcast info */}
          <PodcastInfoCard
            podcastData={podcastData}
            isTranscribing={isTranscribing}
            onTranscribe={onTranscribe}
          />

          {/* Right panel with transcription */}
          <Box
            className="right-panel"
            sx={{
              flexGrow: 1,
              minWidth: 0,
              height: "95%",
              width: "100%",
              display: "flex",
              flexDirection: "column",
            }}
          >
            {/* Fixed header */}
            <Box
              sx={{
                display: "flex",
                width: "100%",
                justifyContent: "space-between",
                alignItems: "center",
                minWidth: "500px",
                position: "sticky",
                top: 0,
                zIndex: 1,
                px: 1,
                py: 1,
              }}
            >
              <Typography variant="h6" fontWeight="bold">
                Transcription
              </Typography>

              {/* Translation language selector, only shown when transcription exists */}
              {transcriptionData.length > 0 && (
                <Box sx={{ minWidth: 200 }}>
                  <select
                    value={targetLanguage}
                    onChange={handleLanguageChange}
                    style={{
                      width: "100%",
                      padding: "8px 12px",
                      borderRadius: "8px",
                      border: "1px solid #ccc",
                      fontSize: "14px",
                      backgroundColor: "#fff",
                      cursor: "pointer",
                      outline: "none",
                      transition: "border-color 0.2s",
                    }}
                  >
                    {languages.map(function (lang) {
                      return (
                        <option key={lang.code} value={lang.code}>
                          {lang.name}
                        </option>
                      );
                    })}
                  </select>
                </Box>
              )}
            </Box>

            {/* Scrollable transcript content */}
            <TranscriptList
              transcriptionData={transcriptionData}
              currentTime={currentTime}
              targetLanguage={targetLanguage}
              translations={translations}
              translatingItems={translatingItems}
              onWordClick={handleWordClick}
            />
            {/* Fixed bottom player area */}
            <Box
              sx={{
                position: "fixed",
                left: 0,
                bottom: 0,
                width: "100%",
                height: "aoto",
                zIndex: 1200,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <Box
                sx={{
                  width: "100%",
                  maxWidth: 1400,
                  px: 2,
                }}
              >
                <AudioPlayerComponent
                  ref={internalAudioRef}
                  audioSrc={podcastData.audioUrl}
                  onTimeUpdate={onTimeUpdate}
                />
              </Box>
            </Box>

            {/* Dictionary card */}
            {showDictionary && (
              <DictionaryCard
                wordCard={{ ...wordCard, position: dictionaryPosition }}
                onClose={() => setShowDictionary(false)}
                onAddToWordlist={handleAddToWordlist}
              />
            )}

            {notification.show && (
              <div className={`notification-toast ${notification.type}`}>
                {notification.message}
              </div>
            )}
          </Box>
        </Box>
      </div>
    </ThemeProvider>
  );
}
</file>

<file path="src/views/PodcastView/TranscriptList.tsx">
import { useEffect, useRef } from "react";
import { Box, Typography } from "@mui/material";
import "../../styles/PodcastPlay.css";


export function TranscriptList({
  transcriptionData,
  currentTime,
  targetLanguage,
  translations,
  translatingItems,
  onWordClick
}) {
  const rowRefs = useRef([]);

  // 自动滚动到当前时间点对应的行
  useEffect(() => {
    if (!transcriptionData.length) return;

    const index = transcriptionData
      .map((item, i) => ({ ...item, i }))
      .filter(item => item.offsetMilliseconds <= currentTime)
      .pop()?.i;

    if (index !== undefined && rowRefs.current[index]) {
      rowRefs.current[index].scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest"
      });
    }
  }, [currentTime, transcriptionData]);

  if (!transcriptionData.length) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Click "Transcribe" to get the transcription of this podcast
      </Typography>
    );
  }

  return (
    <Box className="transcript-content" sx={{ flex: "1 1 auto", overflowY: "auto", pr: 1 }}>
      <div className="transcription-container">
        {transcriptionData.map((item, index) => {
          const start = item.offsetMilliseconds;
          const end =
            index + 1 < transcriptionData.length
              ? transcriptionData[index + 1].offsetMilliseconds
              : Infinity;
          const isActive = currentTime >= start && currentTime < end;

          return (
            <div
              key={"row-" + index}
              ref={el => rowRefs.current[index] = el}
              className={"transcript-row " + (isActive ? "active-row" : "")}
            >
              <div className="timestamp-column">{item.timestamp}</div>
              <div className="content-column">
                <div className="transcription-text">
                  {item.text.split(/(\s+)/).map((part, wordIndex) => {
                    if (/\s+/.test(part)) return part;
                    return (
                      <span
                        key={"word-" + wordIndex}
                        className={"word-hover " + (isActive ? "active-word" : "")}
                        onClick={e => onWordClick(part, e)}
                      >
                        {part}
                      </span>
                    );
                  })}
                </div>
                {targetLanguage && (
                  <div className="translation-text">
                    {translatingItems.has(item.text)
                      ? "Loading..."
                      : translations[item.text]}
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </Box>
  );
}
</file>

<file path="src/views/_suspenseView.tsx">
+export function SuspenseView() {
+  return null;
+}
</file>

<file path="src/views/HomePageView.tsx">
import "../styles/HomePage.css";
// import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { TopNav } from "../components/TopNav";
import TextField from "@mui/material/TextField";
import FavoriteIcon from "@mui/icons-material/Favorite";
import SearchIcon from "@mui/icons-material/TravelExploreOutlined";
import InputAdornment from "@mui/material/InputAdornment";
import PodcastsIcon from "@mui/icons-material/Podcasts";
import { CollapseBox } from "../components/CollapseBox";
import Snackbar from "@mui/material/Snackbar";
import {
  Grid,
  Box,
  Card,
  CardMedia,
  CardContent,
  Typography,
} from "@mui/material";

import Logo from "/asset/LOGO.svg";

// 你的 RecommendationRow 路径按项目实际调整（这行保持不变）
import RecommendationRow from "../components/RecommendationRow";

// 辅助函数：标准化图片URL
function normalizeImageUrl(imageData: any): string {
  const defaultImage =
    "https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea";

  if (!imageData) return defaultImage;

  if (typeof imageData === "string" && imageData.startsWith("http")) {
    return imageData;
  }
  if (Array.isArray(imageData) && imageData.length > 0) {
    return normalizeImageUrl(imageData[0]);
  }
  if (typeof imageData === "object" && imageData !== null) {
    if (imageData.url && typeof imageData.url === "string") return imageData.url;
    if (imageData.href && typeof imageData.href === "string") return imageData.href;
    if (imageData.$ && imageData.$.href && typeof imageData.$.href === "string")
      return imageData.$.href;
  }
  return defaultImage;
}

export function HomePageView({
  // 解析 & 搜索
  url,
  onInputChange,
  onParseClick,

  // Saved
  savedPodcasts,
  onSavedPodcastClick,

  // 通用
  errorMsg,
  snackbarOpen,
  onSnackbarClose,

  // 新增：推荐区从 Presenter 传入
  recommendedItems = [],
  isRecLoading = false,
  onSelectPodcast,
}) {
  const navigate = useNavigate();

  function handleRssLinkClick(e, rssUrl) {
    e.preventDefault();
    onInputChange({ target: { value: rssUrl } });
  }

  return (
    <div className="homepage-container">
      <TopNav hideLogo />

      <div className="center-content">
        <div className="logo-container">
          <img src={Logo} alt="Listenary" className="logo" width={200} height={50} />
        </div>

        <div className="search-container" style={{ width: "600px", display: "flex" }}>
          <TextField
            variant="outlined"
            placeholder="Search podcasts by title, author, catergory or RSS link"
            value={url}
            onChange={onInputChange}
            inputProps={{
              autoComplete: "off",
              name: "search_" + Math.random().toString(36).slice(2),
              inputMode: "search",
            }}
            onKeyDown={(e) => {
              if (e.key === "Enter") onParseClick();
            }}
            sx={{
              width: "486px",
              minWidth: "486px",
              maxWidth: "486px",
              "& .MuiOutlinedInput-root": {
                borderRadius: "30px",
                backgroundColor: "#F5F9FF", // 小修正：补上井号，避免无效色值
                paddingLeft: "16px",
              },
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "#E0E0E0" },
              "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "#C0C0C0" },
              "& .MuiOutlinedInput-input": { paddingLeft: "4px", fontSize: "0.9rem" },
              "& .MuiInputAdornment-root": { marginRight: "8px" },
              "& .MuiOutlinedInput-input::placeholder": { opacity: 1, color: "#757575" },
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <PodcastsIcon color="action" />
                </InputAdornment>
              ),
            }}
          />
          <button
            type="button"
            className="search-button"
            style={{ width: "90px", minWidth: "90px", maxWidth: "90px", height: "52px", marginLeft: "8px" }}
            onClick={onParseClick}
          >
            Search
          </button>
        </div>

        {errorMsg && (
          <div
            style={{
              color: "red",
              marginTop: "0px",
              marginLeft: "8px",
              fontSize: "14px",
              textAlign: "left",
              width: "100%",
              maxWidth: "600px",
            }}
          >
            {errorMsg}
          </div>
        )}
      </div>

      {/* Saved 区域 */}
      <div className="saved-section">
        <div className="saved-header">
          <h2 className="saved-title">
            <FavoriteIcon className="saved-icon" />
            Saved Podcasts
          </h2>
        </div>

        {savedPodcasts && savedPodcasts.length > 0 ? (
          <Box
            sx={{
              maxWidth: 1200,
              mx: "auto",
              display: "grid",
              gridTemplateColumns: "repeat(auto-fill, minmax(260px, 1fr))", 
              gap: 2.5,
            }}
          >
            {savedPodcasts.slice(0, 8).map((podcast, index) => (
              <Card
                key={index}
                onClick={() => onSavedPodcastClick(podcast)}
                elevation={2}
                sx={{
                  borderRadius: 3,
                  overflow: "hidden",
                  cursor: "pointer",
                  transition: "transform .25s ease, box-shadow .25s ease",
                  "&:hover": { transform: "translateY(-2px)", boxShadow: 6 },
                  display: "flex",
                  flexDirection: "column",
                  height: "100%",
                }}
              >
                <Box sx={{ width: "100%", aspectRatio: "1 / 0.5", overflow: "hidden", flexShrink: 0 }}>
                  <CardMedia
                    component="img"
                    image={normalizeImageUrl(podcast.coverImage)}
                    alt={podcast.title}
                    sx={{
                      width: "100%",
                      height: "100%",
                      objectFit: "cover",
                      objectPosition: "center",
                      display: "block",
                    }}
                    loading="lazy"
                    decoding="async"
                  />
                </Box>

                <CardContent sx={{ display: "flex", flexDirection: "column", gap: 0.5 }}>
                  <Typography
                    variant="subtitle1"
                    sx={{
                      fontWeight: 700,
                      display: "-webkit-box",
                      WebkitLineClamp: 2,
                      WebkitBoxOrient: "vertical",
                      overflow: "hidden",
                    }}
                    title={podcast.title}
                  >
                    {podcast.title}
                  </Typography>

                  {podcast.author && (
                    <Typography
                      variant="body2"
                      color="text.secondary"
                      sx={{
                        whiteSpace: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                      }}
                      title={podcast.author}
                    >
                      {podcast.author}
                    </Typography>
                  )}

                  <Typography
                    variant="body2"
                    sx={{
                      color: "text.primary",
                      display: "-webkit-box",
                      WebkitBoxOrient: "vertical",
                      WebkitLineClamp: 3,
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      lineHeight: 1.4,
                      minHeight: "4.2em", // 约三行高度，使卡片高度更整齐
                      mt: 0.5,
                    }}
                    title={podcast.description}
                  >
                    {podcast.description}
                  </Typography>
                </CardContent>
              </Card>
            ))}
          </Box>
        ) : (
          /* 原有空状态保持不变 */
          <Box display="flex" flexDirection="column" alignItems="center" justifyContent="center" sx={{ mt: 4 }}>
            <img
              src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea"
              alt="No saved podcasts"
              style={{ width: "160px", marginBottom: "16px" }}
            />
            <Typography variant="body1" color="text.secondary">
              No saved podcasts yet.
            </Typography>
          </Box>
        )}


        {savedPodcasts && savedPodcasts.length > 4 && (
          <a
            href="#"
            className="show-more"
            onClick={function (e) {
              e.preventDefault();
              navigate("/saved-podcasts");
            }}
          >
            Show more
          </a>
        )}

        <Snackbar open={snackbarOpen} autoHideDuration={4000} onClose={onSnackbarClose} message={errorMsg} />
        
        <div
          className="saved-header"
          style={{
            marginTop: "48px",  // 上方间距大
            marginBottom: "-24px", // 下方间距小
          }}
        >
          <h2 className="saved-title">
            <SearchIcon className="saved-icon" />
            Today's Pick
          </h2>
        </div>

      </div>
    </div>
  );
}
</file>

<file path="src/views/loginPageView.tsx">
import '../styles/LoginPage.css';
import { TopNav } from '../components/TopNav';

function LoginView({
    isLoading,
    user,
    onGoogleLogin,
    onLogout
}) {
    return (
        <div className="page-container">
            <TopNav />
            <div className="login-wrapper">
                <div className="login-content">
                <div className="logo-container">
          <img
            src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/LOGO.svg?alt=media&token=a57cbd8b-9976-4ad4-8416-e42c08bf628f"
            alt="Listenary"
            className="logo"
          />
        </div>

                    {!user ? (
                        // Login form for unauthenticated users
                        <>
                            <button 
                                id="authButton"
                                   onClick={onGoogleLogin} 
                                disabled={isLoading}
                                className="google-sign-in-button"
                            >
                                <div className="google-sign-in-content">
                                    <img 
                                        src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" 
                                        alt="Google" 
                                        className="google-icon"
                                    />
                                    <span>{isLoading ? 'Signing in...' : 'Sign in with Google'}</span>
                                </div>
                            </button>

                            <p className="terms-text">
                                By continuing, you agree to our{' '}
                                <a href="#" className="terms-link">Terms</a> and{' '}
                                <a href="#" className="terms-link">Privacy</a>
                            </p>
                        </>
                    ) : (
                        // Welcome screen for authenticated users
                        <div className="welcome-container">
                            <p className="welcome-text">Welcome, {user.displayName || user.email}</p>
                            <button 
                                onClick={onLogout}
                                className="google-sign-in-button"
                            >
                                Logout
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

export default LoginView;
</file>

<file path="src/views/PodcastChannelView.tsx">
// src/views/PodcastChannelView.tsx (最终布局修正版)

import {
  Box,
  Typography,
  Button,
  Card,
  CardMedia,
  CardContent,
  Link,
  ToggleButton,
  ToggleButtonGroup,
  Snackbar,
  Alert,
  Skeleton,
} from "@mui/material";
import { TopNav } from "../components/TopNav";
import React, { useState } from "react";
import FavoriteIcon from "@mui/icons-material/Favorite";

// 辅助函数：确保图片URL是字符串类型
function normalizeImageUrl(imageData: any): string {
  const defaultImage = "https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea";
  
  if (!imageData) return defaultImage;
  
  // 如果是数组，取第一个元素
  if (Array.isArray(imageData)) {
    return imageData[0] || defaultImage;
  }
  
  // 如果是字符串且是有效的URL，直接使用
  if (typeof imageData === 'string' && imageData.startsWith('http')) {
    return imageData;
  }
  
  // 否则返回默认图片
  return defaultImage;
}

// ==== EpisodeCard 子组件 (无需修改) ====
function EpisodeCard({
  episode,
  onPlay,
  showSnackbar,
  loading = false,
}: {
  episode: any;
  onPlay: (ep: any) => void;
  showSnackbar?: (msg: string, sev?: "success" | "info" | "warning" | "error") => void;
  loading?: boolean;
}) {
  const [expanded, setExpanded] = useState(false);
  const isClamped = episode?.description?.length > 180;

  function handlePlay() {
    if (!episode?.enclosure?.url) {
      showSnackbar?.("This episode has no playable audio file", "warning");
      return;
    }
    onPlay(episode);
  }

  return (
    <Card sx={{ p: 2, width: "100%", borderRadius: 3, transition: "background-color 0.3s", "&:hover": { backgroundColor: "#f5f5f5" }, maxWidth: "100%" }} elevation={1}>
      <Box sx={{ display: "flex", flexDirection: { xs: "column", sm: "row" }, justifyContent: "space-between", width: "100%", gap: 2 }}>
        <Box sx={{ display: "flex", gap: 2, flex: 1, minWidth: 0 }}>
          {loading ? ( <Skeleton variant="rectangular" width={100} height={100} sx={{ borderRadius: 2 }} /> ) : (
            <CardMedia component="img" image={normalizeImageUrl(episode.image)} alt={episode.title} sx={{ width: 100, height: 100, borderRadius: 2 }} referrerPolicy="no-referrer" />
          )}
          <CardContent sx={{ p: 0, flex: 1, minWidth: 0 }}>
            {loading ? ( <Skeleton variant="text" height={28} width="70%" /> ) : ( <Typography variant="h6" sx={{ display: "-webkit-box", WebkitBoxOrient: "vertical", WebkitLineClamp: 2, overflow: "hidden", textOverflow: "ellipsis", wordBreak: "break-word", lineHeight: 1.4 }}>{episode.title}</Typography> )}
            {loading ? ( <><Skeleton variant="text" height={20} width="95%" sx={{ mt: 1 }} /><Skeleton variant="text" height={20} width="85%" /></> ) : ( <Typography variant="body2" color="text.secondary" mt={1} sx={{ ...(expanded ? {} : { display: "-webkit-box", overflow: "hidden", WebkitBoxOrient: "vertical", WebkitLineClamp: 2 }), overflowWrap: "break-word", wordBreak: "break-word", lineHeight: 1.4 }}>{episode.description}</Typography> )}
            {!loading && isClamped && ( <Link component="button" variant="body2" onClick={() => setExpanded(!expanded)} sx={{ mt: 0.5, pl: 0, textTransform: "none" }}>{expanded ? "Show less" : "Show more"}</Link> )}
            {loading ? ( <Skeleton variant="text" height={16} width={120} sx={{ mt: 1 }} /> ) : ( <Typography variant="caption" color="text.secondary" mt={1} display="block">🎧 {episode.duration}</Typography> )}
          </CardContent>
        </Box>
        <Box sx={{ minWidth: 100, flexShrink: 0, display: "flex", justifyContent: "flex-end", alignItems: "flex-start" }}>
          {loading ? ( <Skeleton variant="rectangular" width={90} height={32} sx={{ borderRadius: 1 }} /> ) : ( <Button variant="contained" size="small" onClick={handlePlay} color={episode.isTranscribed ? "success" : "primary"}>{episode.isTranscribed ? "Continue" : "Learn"}</Button> )}
        </Box>
      </Box>
    </Card>
  );
}

// ==== 主视图 ====
export function PodcastChannelView({
  channelInfo,
  episodes,
  isSaved,
  onSavePodcast,
  onRemovePodcast,
  onPlay,
  filterType,
  onFilterChange,
  snackbarState,
  onSnackbarClose,
  loading = false,
}: {
  channelInfo: any;
  episodes: any[];
  isSaved?: boolean;
  onSavePodcast: (c: any) => any;
  onRemovePodcast: (c: any) => any;
  onPlay: (e: any) => void;
  filterType: string;
  onFilterChange: (e: any, v: string) => void;
  snackbarState?: any;
  onSnackbarClose?: any;
  loading?: boolean;
}) {
  const [visibleCount, setVisibleCount] = useState(10);
  const [descExpanded, setDescExpanded] = useState(false);
  const [open, setOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState<"success" | "info" | "warning" | "error">("success");

  function showSnackbar(message: string, severity: "success" | "info" | "warning" | "error" = "success") {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setOpen(true);
  }

  const descClamped = channelInfo?.description?.length > 180;

  function handleClose(event?: React.SyntheticEvent | Event, reason?: string) {
    if (reason === "clickaway") return;
    setOpen(false);
  }

  function handleSubscribe() {
    const result = isSaved ? onRemovePodcast(channelInfo) : onSavePodcast(channelInfo);
    if (result && result.type === "warning") {
      showSnackbar(result.message, result.type);
    } else {
      showSnackbar(isSaved ? "Podcast removed from saved list" : "Podcast saved successfully", "success");
    }
  }

  function handleFilterChange(event: any, newFilterType: string | null) {
    if (newFilterType !== null) onFilterChange(event, newFilterType);
  }

  const displayEpisodes = loading ? Array.from({ length: 8 }, () => ({})) : episodes;

  return (
    <Box sx={{ bgcolor: "background.default", minHeight: "100vh" }}>
      <TopNav />
      <Box sx={{ maxWidth: 1200, mx: "auto", px: 4, pt: 4 }}>
        {/* ==================== 布局修改处 ==================== */}
        <Box 
          display="flex" 
          gap={5} 
          // 使用响应式 flexDirection 代替 flexWrap
          flexDirection={{ xs: 'column', md: 'row' }} 
          alignItems="flex-start" 
          width="100%"
        >
        {/* ======================================================= */}
          <Card sx={{ width: 200, height: 200, borderRadius: 4, boxShadow: 3, position: "relative", flexShrink: 0 }}>
            {loading ? (
              <Skeleton variant="rectangular" width="100%" height="100%" sx={{ borderRadius: 4 }} />
            ) : (
              <CardMedia
                component="img"
                // 修正: 使用 'coverImage' 字段（与Model.ts中的字段名一致）
                // 添加类型保护：确保image属性始终是字符串
                image={normalizeImageUrl(channelInfo.coverImage)}
                alt={channelInfo.title}
                sx={{ width: "100%", height: "100%", objectFit: "cover" }}
                referrerPolicy="no-referrer"
              />
            )}
          </Card>
          <Box flex={1} display="flex" flexDirection="column" gap={2} justifyContent="flex-start" minWidth={0}>
            <Box display="flex" justifyContent="space-between" alignItems="center" width="100%">
              {loading ? ( <Skeleton variant="text" height={40} width="60%" /> ) : ( <Typography variant="h4" fontWeight={700} color="text.primary">{channelInfo.title}</Typography> )}
              <Box ml={2}>
                {loading ? ( <Skeleton variant="rectangular" width={120} height={36} sx={{ borderRadius: 2 }} /> ) : ( <Button variant="contained" size="small" color={isSaved ? "success" : "primary"} onClick={handleSubscribe} startIcon={<FavoriteIcon />} sx={{ borderRadius: 2 }}>{isSaved ? "Saved" : "Save"}</Button> )}
              </Box>
            </Box>
            {loading ? ( <><Skeleton variant="text" height={20} width="90%" /><Skeleton variant="text" height={20} width="70%" /></> ) : ( <Typography variant="body1" color="text.secondary" sx={ descExpanded ? {} : { display: "-webkit-box", overflow: "hidden", WebkitBoxOrient: "vertical", WebkitLineClamp: 3 } }><span dangerouslySetInnerHTML={{ __html: channelInfo.description }} /></Typography> )}
            {!loading && descClamped && ( <Link component="button" variant="body2" onClick={() => setDescExpanded(!descExpanded)} sx={{ textTransform: "none", alignSelf: "flex-start" }}>{descExpanded ? "Show less" : "Show more"}</Link> )}
          </Box>
        </Box>
        <Box mt={6}>
          <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
            {loading ? ( <Box sx={{ display: "flex", gap: 1 }}><Skeleton variant="rectangular" width={110} height={32} sx={{ borderRadius: 16 }} /><Skeleton variant="rectangular" width={140} height={32} sx={{ borderRadius: 16 }} /><Skeleton variant="rectangular" width={160} height={32} sx={{ borderRadius: 16 }} /></Box> ) : (
              <ToggleButtonGroup value={filterType} exclusive onChange={handleFilterChange} aria-label="Episode Filter" size="small">
                <ToggleButton value="all" aria-label="All">All Episodes</ToggleButton>
                <ToggleButton value="untranscribed" aria-label="Untranscribed">New Episodes</ToggleButton>
                <ToggleButton value="transcribed" aria-label="Transcribed">Learned Episodes</ToggleButton>
              </ToggleButtonGroup>
            )}
          </Box>
          <Box display="flex" flexDirection="column" gap={2}>
            {displayEpisodes.slice(0, visibleCount).map((episode: any, index: number) => (
              <EpisodeCard key={episode?.guid || index} episode={episode} onPlay={onPlay} showSnackbar={showSnackbar} loading={loading} />
            ))}
          </Box>
        </Box>
      </Box>
      <Snackbar open={open} autoHideDuration={3000} onClose={handleClose} anchorOrigin={{ vertical: "bottom", horizontal: "center" }}>
        <Alert onClose={(event) => handleClose(event, undefined)} severity={snackbarSeverity} sx={{ width: "100%" }}>{snackbarMessage}</Alert>
      </Snackbar>
    </Box>
  );
}
</file>

<file path="src/views/PodcastSearchView.tsx">
import React from 'react';
import { TopNav } from '../components/TopNav';
import DiscoveryCard from '../components/DiscoveryCard';
import {
  Box,
  Container,
  Typography,
  TextField,
  Button,
  Tabs,
  Tab,
  ToggleButtonGroup,
  ToggleButton,
  Skeleton,
  Card,
  CardContent,
  Alert
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import WhatshotIcon from '@mui/icons-material/Whatshot';
import NewReleasesIcon from '@mui/icons-material/NewReleases';
import { styled, alpha } from '@mui/material/styles'
import InputAdornment from '@mui/material/InputAdornment';
import PodcastsIcon from '@mui/icons-material/Podcasts';


//Toggle group
const Capsule = styled(ToggleButtonGroup)(({ theme }) => ({
  backgroundColor: theme.palette.action.hover,
  borderRadius: 9999,
  padding: 4, 
  gap: 0,
}));

const PillBtn = styled(ToggleButton)(({ theme }) => ({
  border: 1,
  borderRadius: 9999,
  textTransform: 'none',
  padding: '12px 24px',        // 按钮内部左右留白
  lineHeight: 1,
  height: 40,
  fontSize: '0.95rem',         
  color: theme.palette.text.secondary,
  '&:hover': {
    backgroundColor: alpha(theme.palette.primary.main, 0.06),
  },
  '&.Mui-selected': {
    backgroundColor: theme.palette.background.paper,
    color: theme.palette.primary.main,
    '&:hover': {
      backgroundColor: alpha(theme.palette.primary.main, 0.12),
    },
  },
}));

// 扩展后的 Props 类型
type Props = {
  // 用于搜索
  searchTerm: string;
  onSearchTermChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onSearchSubmit: (event: React.FormEvent) => void;
  
  // 用于发现/浏览
  sortOrder: 'trending' | 'recent';
  onSortChange: (event: React.MouseEvent<HTMLElement>, newOrder: string | null) => void;
  categories: { id: string; name: string }[];
  selectedCategory: string | false;
  onCategoryChange: (event: React.SyntheticEvent, newCategory: string) => void;
  
  // 用于展示
  displayTitle: string;
  podcasts: any[];
  onPodcastSelect: (podcast: any) => void;
  isLoading: boolean;
  error: string | null;

  // 用于无限滚动 (保持不变)
  isLoadingMore?: boolean;
  hasMore?: boolean;
  sentinelRef?: React.RefObject<HTMLDivElement>;
};

export function PodcastSearchView({
  searchTerm,
  onSearchTermChange,
  onSearchSubmit,
  sortOrder,
  onSortChange,
  categories,
  selectedCategory,
  onCategoryChange,
  displayTitle,
  podcasts,
  onPodcastSelect,
  isLoading,
  error,
  isLoadingMore = false,
  hasMore = false,
  sentinelRef,
}: Props) {
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', bgcolor: 'background.default' }}>
      <TopNav />
      <Container maxWidth="xl" sx={{ py: 4, flexGrow: 1 }}>

    {/* 搜索框（样式与首页一致；仅渲染，逻辑走 props） */}
    <Box
      component="form"
      onSubmit={onSearchSubmit}
      sx={{ display: 'flex', gap: 1, maxWidth: 600, mx: 'auto', mb: 4 }}
    >
      <TextField
        variant="outlined"
        placeholder="Search podcasts by title, author, category or RSS link"
        value={searchTerm}
        onChange={onSearchTermChange}
        onKeyDown={(e) => { if (e.key === 'Enter') {/* 交给onSearchSubmit */} }}
        autoComplete="off"
        sx={{
          width: 900, minWidth: 486, maxWidth: 486,
          '& .MuiOutlinedInput-root': {
            borderRadius: '30px',
            backgroundColor: '#F5F9FF',
            pl: '16px',
          },
          '& .MuiOutlinedInput-notchedOutline': { borderColor: '#E0E0E0' },
          '&:hover .MuiOutlinedInput-notchedOutline': { borderColor: '#C0C0C0' },
          '& .MuiOutlinedInput-input': { pl: '4px', fontSize: '0.9rem' },
          '& .MuiInputAdornment-root': { mr: '8px' },
          '& .MuiOutlinedInput-input::placeholder': { opacity: 1, color: '#757575' },
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <PodcastsIcon color="action" />
            </InputAdornment>
          ),
        }}
      />

      <Button
        type="submit"
        variant="contained"
        disabled={isLoading}
        sx={{
          width: 90, minWidth: 90, maxWidth: 90, height: 52, ml: 1,
          borderRadius: '25px', px: 0, fontWeight: 'bold',
          boxShadow: '0 1px 2px rgba(60,60,60,0.03)',
          bgcolor: '#4285f4',
          '&:hover': { bgcolor: '#2a65c4', transform: 'scale(1.05)' },
          transition: 'all .2s',
        }}
      >
        {isLoading ? 'Searching…' : 'Search'}
      </Button>
    </Box>


        <Box
          sx={{
            mb: 2,        
            display: 'flex',
            alignItems: 'center',
            gap: 1.5,
          }}
        >
          <Box
            sx={{
              display: 'inline-flex',
            }}
        >
        <Box sx={{ display: 'inline-flex' }}>
          <Capsule
            value={sortOrder}
            exclusive
            onChange={onSortChange}
            aria-label="sort order"
            size="small"
            disabled={isLoading}
          >
            <PillBtn value="trending" aria-label="trending">
              <WhatshotIcon sx={{ mr: 1 }} />
              Trending
            </PillBtn>
            <PillBtn value="recent" aria-label="recent">
              <NewReleasesIcon sx={{ mr: 1 }} />
              Recent
            </PillBtn>
          </Capsule>
        </Box>
        </Box>
        <Tabs
          value={(selectedCategory || 'all').toLowerCase()}
          onChange={onCategoryChange}
          variant="scrollable"
          scrollButtons="auto"
          allowScrollButtonsMobile
          aria-label="podcast categories"
          TabIndicatorProps={{ sx: { display: 'none' } }}
          sx={(theme) => ({
            flexGrow: 1,
            ml: 2,
            px: 0.5,
            // 滚动按钮样式（含右侧按钮垂直居中）
            '& .MuiTabs-scrollButtons': {
              alignSelf: 'center',       
              height: 40,
              width: 40,
              borderRadius: '50%',
              color: theme.palette.text.secondary,
              '&:hover': {
                backgroundColor: theme.palette.action.hover,
              },
              '&.Mui-disabled': {
                opacity: 0.3,
              },
            },
            // Tab 样式
            '& .MuiTab-root': {
              textTransform: 'none',
              minHeight: 44,
              height: 44,
              lineHeight: 1,
              borderRadius: '9999px',
              mr: 1,
              px: 1.5,
              fontSize: '0.95rem',   
              fontWeight: 500,
              color: theme.palette.text.secondary,
              transition: 'background-color .2s ease, color .2s ease',
              '&:hover': {
                backgroundColor: theme.palette.action.hover,
              },
              '&.Mui-focusVisible': {
                boxShadow: `0 0 0 3px ${theme.palette.primary.main}40`,
              },
              '&.Mui-selected': {
                color: theme.palette.primary.main,
                fontWeight: 700,
                backgroundColor: `${theme.palette.primary.main}1F`, // ~12% 透明
              },
            },
          })}
        >
          <Tab label="All" value="all" disabled={isLoading && (selectedCategory || 'all').toLowerCase() !== 'all'} />
          {categories.map((cat) => {
            const val = cat.name.toLowerCase();
            const isSelected = (selectedCategory || 'all').toLowerCase() === val;
            return (
              <Tab
                key={cat.id}
                label={cat.name}
                value={val}
                disabled={isLoading && !isSelected}
              />
            );
          })}
        </Tabs>

        </Box>
        
        {/* 状态区域 */}
        {error && <Alert severity="error" sx={{ my: 2 }}>{error}</Alert>}

        {/* 动态内容网格 */}
        <Box>
          <Typography variant="h6" fontWeight="600" gutterBottom>{displayTitle}</Typography>
          
          <Box
            sx={{
              display: 'grid',
              // gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
              gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
              gap: 2,
              alignItems: 'stretch',
            }}
          >
            {isLoading ? (
              // 加载状态：渲染骨架图
              Array.from({ length: 12 }).map((_, index) => (
                <Card sx={{ borderRadius: 3 }} key={index}>
                  <Skeleton variant="rectangular" height={160} />
                  <CardContent>
                    <Skeleton variant="text" width="80%" height={28} />
                    <Skeleton variant="text" width="60%" />
                  </CardContent>
                </Card>
              ))
            ) : podcasts.length > 0 ? (
              // 有数据：渲染真实的 DiscoveryCard
              podcasts.map((podcast) => (
                <DiscoveryCard key={podcast.id} item={podcast} onSelect={onPodcastSelect} />
              ))
            ) : (
              // 无数据状态（但需要一个 Grid 容器来保持布局一致性）
              !error && (
                <Typography sx={{ gridColumn: '1 / -1', mt: 4, textAlign: 'center', color: 'text.secondary' }}>
                  No podcasts found. Try a different search or category.
                </Typography>
              )
            )}

            {/* 无限滚动加载更多时的骨架图 */}
            {isLoadingMore && (
              Array.from({ length: 4 }).map((_, i) => (
                <Card sx={{ borderRadius: 3 }} key={`sk-more-${i}`}>
                  <Skeleton variant="rectangular" height={160} />
                  <CardContent>
                    <Skeleton variant="text" width="80%" height={28} />
                    <Skeleton variant="text" width="60%" />
                  </CardContent>
                </Card>
              ))
            )}
          </Box>
          
          {/* 无限滚动哨兵和“没有更多”提示 (保持不变) */}
          <div ref={sentinelRef} style={{ height: 1 }} />
          {!isLoading && podcasts.length > 0 && !hasMore && (
            <Typography align="center" color="text.secondary" sx={{ my: 3 }}>
              No more results.
            </Typography>
          )}
        </Box>
      </Container>
    </Box>
  );
}
</file>

<file path="src/views/SavedPodcastsView.tsx">
import "../styles/HomePage.css";
import { useNavigate } from "react-router-dom";
import { TopNav } from "../components/TopNav";
import {
  Grid,
  Box,
  Card,
  CardMedia,
  CardContent,
  Typography
} from "@mui/material";

// 辅助函数：标准化图片URL
function normalizeImageUrl(imageData: any): string {
  const defaultImage = "https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea";
  
  if (!imageData) return defaultImage;
  
  // Case 1: 本身就是 URL 字符串
  if (typeof imageData === 'string' && imageData.startsWith('http')) {
    return imageData;
  }
  
  // Case 2: 是一个数组
  if (Array.isArray(imageData) && imageData.length > 0) {
    // 递归处理数组的第一个元素，无论它是字符串还是对象
    return normalizeImageUrl(imageData[0]);
  }
  
  // Case 3: 是一个对象
  if (typeof imageData === 'object' && imageData !== null) {
    // 常见格式: { url: '...' }
    if (imageData.url && typeof imageData.url === 'string') {
      return imageData.url;
    }
    // iTunes 常见格式: { href: '...' }
    if (imageData.href && typeof imageData.href === 'string') {
      return imageData.href;
    }
    // 处理 rss-parser 解析 XML 属性时的格式: { $: { href: '...' } }
    if (imageData.$ && imageData.$.href && typeof imageData.$.href === 'string') {
      return imageData.$.href;
    }
  }
  
  // 如果所有尝试都失败，返回默认图片
  return defaultImage;
}

/**
 * View component for displaying saved podcasts
 * @param {Object} props - Component props
 * @param {Array} props.savedPodcasts - Array of saved podcast objects
 */
function SavedPodcastsView(props) {
  const savedPodcasts = props.savedPodcasts;
  const navigate = useNavigate();

  function handleViewPodcast(podcast) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.rssUrl } });
  }

  return (
    <div className="homepage-container">
      <TopNav />
<div className="saved-section">
  <div className="saved-header">
    <h2 className="saved-title">
      <img src="/saved-icon.png" alt="" className="saved-icon" />
      All Saved Podcasts
    </h2>
  </div>

  {savedPodcasts && savedPodcasts.length > 0 ? (
    <div className="saved-grid">
      {savedPodcasts.map(function (podcast, index) {
        return (
          <div
            key={index}
            className="saved-item"
            onClick={function () {
              handleViewPodcast(podcast);
            }}
          >
            <div className="saved-item-image-wrapper">
              <img
                src={normalizeImageUrl(podcast.coverImage)}
                alt={podcast.title}
                className="saved-item-image"
              />
            </div>
            <h3 className="saved-item-title">{podcast.title}</h3>
            <p className="saved-item-description">{podcast.description}</p>
          </div>
        );
      })}
      </div>
      ) : (
        <Box
          width="100%"
          display="flex"
          justifyContent="center"
          alignItems="center"
          sx={{ mt: 4 }}
        >
          <Box
            display="flex"
            flexDirection="column"
            alignItems="center"
          >
            <img
              src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea"
              alt="No saved podcasts"
              style={{ width: "160px", marginBottom: "16px" }}
            />
            <Typography variant="body1" color="text.secondary">
              No saved podcasts yet.
            </Typography>
          </Box>
        </Box>
      )}
    </div>
  </div>
  );
}

export { SavedPodcastsView };
</file>

<file path="src/views/WordlistView.tsx">
import '../styles/Wordlist.css';
import { TopNav } from '../components/TopNav';
import type { ReactElement, JSXElementConstructor, ReactNode, ReactPortal, Key } from 'react';

/**
 * WordlistView Component - Part of the View layer in MVP
 * Displays the user's wordlist and selected word details
 */
export function WordlistView({ 
  words, 
  selectedWordIndex, 
  selectedWord, 
  onWordSelect,
  isLoading,
  error,
  isLoggedIn,
  onDeleteWord,
}) {
  return (
    <div className="page-container">
      <TopNav />
      <div className="wordlist-container">
        {/* Left sidebar - Word list */}
        <div className="wordlist-sidebar">
          <h2 className="sidebar-title">My Wordlist</h2>

          {!isLoggedIn && (
            <div className="login-prompt">
              <p>Please log in to view your saved words.</p>
            </div>
          )}

          {isLoggedIn && isLoading && (
            <div className="wordlist-skeleton">
              <div className="skeleton sk-line" style={{width:'80%'}}/>
              <div className="skeleton sk-line" style={{width:'60%', marginTop:8}}/>
              <div className="skeleton sk-line" style={{width:'70%', marginTop:8}}/>
            </div>
          )}

          {isLoggedIn && error && (
            <div className="error-state">
              <p>{error}</p>
            </div>
          )}

          {isLoggedIn && !isLoading && !error && words.length === 0 && (
            <div className="empty-state">
              <p>You haven't saved any words yet.</p>
              <p>Look up words in podcast transcripts and add them to your wordlist.</p>
            </div>
          )}

          {isLoggedIn && !isLoading && words.length > 0 && (
            <div className="wordlist-list">
              {words.map((word: { word: string | number | bigint | boolean | ReactElement<unknown, string | JSXElementConstructor<any>> | Iterable<ReactNode> | ReactPortal | Promise<string | number | bigint | boolean | ReactPortal | ReactElement<unknown, string | JSXElementConstructor<any>> | Iterable<ReactNode>>; meanings: string | any[]; }, index: Key) => (
                <div
                  key={index}
                  className={`wordlist-item ${selectedWordIndex === index ? 'selected' : ''}`}
                  onClick={() => onWordSelect(index)}
                >
                  <span className="wordlist-name">{word.word}</span>
                  <span className="wordlist-count">
                    {word.meanings && word.meanings.length > 0 ? word.meanings[0].partOfSpeech : ''}
                  </span>
                  {/* 新增删除按钮 */}
                  <button
                    className="wordlist-delete-btn"
                    type="button"
                    aria-label="Delete word"
                    title="Delete"
                    onClick={(e) => {
                      e.stopPropagation();
                      onDeleteWord?.(index);
                    }}
                  >
                    <svg
                      width="18"
                      height="18"
                      viewBox="0 0 24 24"
                      fill="none"
                      aria-hidden="true"
                    >
                      <path
                        d="M4 7h16M10 11v6m4-6v6M9 7V5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2m-9 0v11a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7"
                        stroke="currentColor"
                        strokeWidth="1.6"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      />
                    </svg>
                  </button>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Right content - Word details */}
        <div className="wordlist-content">
          {selectedWord ? (
            <div className="word-details">
              <h2 className="content-title">{selectedWord.word}</h2>
              
              {/* Phonetics section - Simplified to show only one phonetic */}
              {selectedWord.phonetics && selectedWord.phonetics.length > 0 && (
                <div className="phonetics-section">
                  {(() => {
                    // Find the first phonetic with audio, or just use the first one
                    const phoneticWithAudio = selectedWord.phonetics.find((p: { audio: any; }) => p.audio) || selectedWord.phonetics[0];
                    
                    return (
                      <div className="phonetic-item">
                        <span className="phonetic-text">
                          {phoneticWithAudio.text || selectedWord.phonetic || ''}
                        </span>
                        {phoneticWithAudio.audio && (
                          <button 
                            className="phonetic-audio-btn"
                            onClick={() => {
                              const audio = new Audio(phoneticWithAudio.audio);
                              audio.play();
                            }}
                          >
                            🔊 Play
                          </button>
                        )}
                      </div>
                    );
                  })()}
                </div>
              )}
              
              {/* Meanings section */}
              {selectedWord.meanings && selectedWord.meanings.map((meaning: { partOfSpeech: string | number | bigint | boolean | ReactElement<unknown, string | JSXElementConstructor<any>> | Iterable<ReactNode> | ReactPortal | Promise<string | number | bigint | boolean | ReactPortal | ReactElement<unknown, string | JSXElementConstructor<any>> | Iterable<ReactNode>>; definitions: any[]; synonyms: any[]; antonyms: any[]; }, meaningIndex: Key) => (
                <div key={meaningIndex} className="meaning-section">
                  <h3 className="part-of-speech">{meaning.partOfSpeech}</h3>
                  
                  {meaning.definitions && meaning.definitions.map((def, defIndex) => (
                    <div key={defIndex} className="definition-item">
                      <p className="definition-text">{def.definition}</p>
                      {def.example && (
                        <p className="example-text">Example: "{def.example}"</p>
                      )}
                    </div>
                  ))}
                  
                  {/* Synonyms */}
                  {meaning.synonyms && meaning.synonyms.length > 0 && (
                    <div className="word-synonyms">
                      <h4>Synonyms:</h4>
                      <div className="synonyms-list">
                        {meaning.synonyms.map((synonym, synIndex) => (
                          <span key={synIndex} className="synonym-tag">{synonym}</span>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Antonyms */}
                  {meaning.antonyms && meaning.antonyms.length > 0 && (
                    <div className="word-antonyms">
                      <h4>Antonyms:</h4>
                      <div className="antonyms-list">
                        {meaning.antonyms.map((antonym, antIndex) => (
                          <span key={antIndex} className="antonym-tag">{antonym}</span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="no-selection">
              <p>Select a word from your wordlist to view details.</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/firebaseApp.ts">
// src/firebaseApp.ts
import { initializeApp } from "firebase/app";
// Firestore不再使用，只保留Firebase Auth
// 你项目里目前用的是 listenary-backend 里的配置
import { firebaseConfig } from "./firebaseConfig";

export const app = initializeApp(firebaseConfig);
// export const db = getFirestore(app); // Firestore不再使用
</file>

<file path="src/firebaseConfig.ts">
// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
export const firebaseConfig = {
  apiKey: "AIzaSyAa84m37fzjOZzhNDMHzNlPmOGplU78kTI",
  authDomain: "dh2642-29c50.firebaseapp.com",
  projectId: "dh2642-29c50",
  storageBucket: "dh2642-29c50.firebasestorage.app",
  messagingSenderId: "389069809164",
  appId: "1:389069809164:web:eb9eb7fba4aab24fb33029",
  measurementId: "G-JMBEQCV08T",
};
</file>

<file path="src/firestoreModel.ts">
// 这个文件现在只用于localStorage操作，Firestore操作已迁移到后端API

// Save podcast channel info to localStorage
export function savePodcastChannelInfo(channelInfo: any) {
  localStorage.setItem("podcastChannelInfo", JSON.stringify(channelInfo));
}

// Load podcast channel info from localStorage
export function loadPodcastChannelInfo() {
  const savedInfo = localStorage.getItem("podcastChannelInfo");
  return savedInfo ? JSON.parse(savedInfo) : null;
}

// Save podcast episodes to localStorage
export function savePodcastEpisodes(episodes: any) {
  localStorage.setItem("podcastEpisodes", JSON.stringify(episodes));
}

// Load podcast episodes from localStorage
export function loadPodcastEpisodes() {
  const savedEpisodes = localStorage.getItem("podcastEpisodes");
  return savedEpisodes ? JSON.parse(savedEpisodes) : [];
}

// Save RSS URL to localStorage
export function saveRssUrl(url: string) {
  localStorage.setItem("rssUrl", url);
}

// Load RSS URL from localStorage
export function loadRssUrl() {
  return localStorage.getItem("rssUrl") || "";
}

// Save audio URL to localStorage
export function saveAudioUrl(url: string) {
  localStorage.setItem("audioUrl", url);
}

// Load audio URL from localStorage
export function loadAudioUrl() {
  return localStorage.getItem("audioUrl") || "";
}
</file>

<file path="src/index.tsx">
import { observable, runInAction } from "mobx";
import React from "react";
import { createRoot } from "react-dom/client";
import { ReactRoot } from "./ReactRoot";
import { model } from "./Model";
import "./styles/LoginPage.css";
// MongoDB API 调用
import { getSavedPodcasts } from "./api/userAPI";
import loginModel from "./loginModel";


// MUI 
import { ThemeProvider, CssBaseline } from "@mui/material";
import theme from "./styles/theme"; 

// model 已经在 Model.ts 中用 observable 包装了
const myModel = model;

// Global auth state listener: sync login state and savedPodcasts from MongoDB
loginModel.setupAuthStateListener(function(user) {
  if (user) {
    // User just logged in or refreshed - load savedPodcasts from MongoDB
    getSavedPodcasts()
      .then(function(savedPodcasts) {
        runInAction(function() {
          myModel.savedPodcasts.splice(0, myModel.savedPodcasts.length, ...(savedPodcasts || []));
        });
        console.log('Saved podcasts loaded from MongoDB:', savedPodcasts.length);
      })
      .catch(function(error) {
        // First time login - user doesn't exist in MongoDB yet
        console.log('First time login or user not found in MongoDB:', error.message);
      });
  } else {
    // User logged out
    runInAction(function() {
      myModel.savedPodcasts.splice(0, myModel.savedPodcasts.length);
    });
  }
});

// 渲染：包裹 ThemeProvider 和 CssBaseline
createRoot(document.getElementById("root")).render(
  <ThemeProvider theme={theme}>
    <CssBaseline />
    <ReactRoot model={myModel} />
  </ThemeProvider>
);

//暴露到 window
declare global {
  interface Window {
    myModel: typeof myModel;
  }
}
window.myModel = myModel;
</file>

<file path="src/loginModel.ts">
import {
  getAuth,
  GoogleAuthProvider,
  signInWithPopup,
  onAuthStateChanged,
  signOut,
} from "firebase/auth";
import { app } from "./firebaseApp";
import { makeAutoObservable, runInAction } from "mobx";
import type { UserCredential } from "firebase/auth"; // [fix] 引入类型

// Pure data model for login
class LoginModel {
  // 这些是新增的字段声明，让 TS 知道它们存在  // [fix]
  private auth: import("firebase/auth").Auth;              // [fix]
  private googleProvider: import("firebase/auth").GoogleAuthProvider; // [fix]
  private isLoading: boolean = false;                      // [fix]
  private user: import("firebase/auth").User | null = null; // [fix]
  private viewUpdateCallbacks: Array<() => void> = [];     // [fix]

  constructor() {
    // Initialize Firebase Auth
    this.auth = getAuth(app);
    this.googleProvider = new GoogleAuthProvider();
    this.isLoading = false;
    this.user = null;
    this.viewUpdateCallbacks = [];
    makeAutoObservable(this);

    // Set up initial auth state
    const self = this;
    onAuthStateChanged(this.auth, function(user) {
      runInAction(function() {
        self.user = user;
      });
    });
  }

  getIsLoading() {
    return this.isLoading;
  }
  getUser() {
    return this.user;
  }

  // Firebase auth state monitoring
  setupAuthStateListener(callback) {
    if (callback) {
      this.viewUpdateCallbacks.push(callback);
    }
    const self = this;
    return onAuthStateChanged(this.auth, function(user) {
      runInAction(function() {
        self.user = user;
      });
      if (callback) callback(user);
    });
  }

  notifyViewUpdate() {
    const self = this;
    this.viewUpdateCallbacks.forEach(function(callback) {
      callback();
    });
  }

  // Authentication methods
  googleLogin(): Promise<UserCredential | { success: boolean; error?: string }> {
  const self = this;
  return new Promise(function (resolve, reject) {
      runInAction(function() {
        self.isLoading = true;
      });

      if (self.auth.currentUser) {
        signOut(self.auth)
          .then(function() {
            runInAction(function() {
              self.user = null;
              self.isLoading = false;
            });
            resolve({ success: true });
          })
          .catch(function(error) {
            runInAction(function() {
              self.isLoading = false;
            });
            reject({ success: false, error: error.message });
          });
      } else {
        signInWithPopup(self.auth, self.googleProvider)
          .then(function(result) {
            runInAction(function() {
              self.user = result.user;
              self.isLoading = false;
            });
            resolve(result);
          })
          .catch(function(error) {
            runInAction(function() {
              self.isLoading = false;
            });
            reject({ success: false, error: error.message });
          });
      }
    });
  }

  logout() {
    const self = this;
    return signOut(self.auth)
      .then(function() {
        runInAction(function() {
          self.user = null;
        });
        return { success: true };
      })
      .catch(function(error) {
        return { success: false, error: error.message };
      });
  }

  setUser(user) {
    const self = this;
    runInAction(function() {
      self.user = user;
    });
  }
}
// Create and export a singleton instance
const loginModel = new LoginModel();
export default loginModel;
</file>

<file path="src/Model.ts">
import { resolvePromise } from "./resolvePromise.js";
import { RssModel } from "./rssModel.js";
import { DictionaryAPI } from "./api/dictionaryAPI";
import { speechToText } from "./api/transcriptionAPI";
// localStorage 相关函数（客户端缓存）
import {
  savePodcastChannelInfo,
  loadPodcastChannelInfo,
  savePodcastEpisodes,
  loadPodcastEpisodes,
  saveRssUrl,
  loadRssUrl,
  saveAudioUrl,
  loadAudioUrl,
} from "./firestoreModel";

// MongoDB API 调用
import { addPodcastToSaved, removePodcastFromSaved } from "./api/userAPI";
import loginModel from "./loginModel";
import { observable, runInAction } from "mobx";

export const model = observable({
  // RSS related states
  rssUrl: loadRssUrl(),
  // Podcast channel information
  podcastChannelInfo: loadPodcastChannelInfo(),
  podcastEpisodes: loadPodcastEpisodes(),
  podcastLoadError: null,
  errorMsg: "", // Error message state

  rssModel: new RssModel(), // RssModel instance
  // Saved podcasts
  savedPodcasts: [],

  //podcast player states
  audioUrl: loadAudioUrl(),
  // Single episode information
  currentEpisode: null,
  audioFile: null, // Store audio file
  transcripResults: [],
  transcripResultsPromiseState: { data: null, error: null },

  // Dictionary lookup state
  dictionaryResult: null,
  dictionaryLookupPromiseState: {},

  setResults(results) {
    this.transcripResults.replace(results);
  },

  setAudioUrl(url) {
    this.audioUrl = url;
    saveAudioUrl(url);
  },

  setAudioFile(file) {
    this.audioFile = file;
  },

  setAudioDuration(duration) {
    this.audioDuration = duration;
  },

  setRssUrl(url) {
    this.rssUrl = url;
    saveRssUrl(url);
  },

  setCurrentEpisode(episode) {
    this.currentEpisode = episode;
  },

  async loadRssData() {
    runInAction(() => {
      this.podcastLoadError = null;
      this.podcastChannelInfo = null;
      this.podcastEpisodes = [];
    });

    try {
      const { feed, items } = await this.rssModel.loadFeed(this.rssUrl);
      runInAction(() => {
        this.podcastChannelInfo = {
          title: feed.title,
          description: feed.description,
          coverImage: feed.image,
          rssUrl: this.rssUrl,
        };
        savePodcastChannelInfo(this.podcastChannelInfo);

        this.podcastEpisodes = items;
        savePodcastEpisodes(this.podcastEpisodes);
      });
    } catch (err) {
      console.error("RSS fetch failed", err);
      runInAction(() => {
        this.podcastLoadError = err.message;
      });
      throw err;
    }
  },

  // Store ASR API result in transcription result promise state
  getTranscription(params) {
    resolvePromise(
      speechToText({
        audioUrl: params.audioUrl,
        episodeId: params.episodeId,
        rssUrl: params.rssUrl,
        duration: params.duration,
      }),
      this.transcripResultsPromiseState
    );
  },

  // Save selected podcast
  async addToSaved(podcastToAdd) {
    if (!podcastToAdd.rssUrl) {
      podcastToAdd.rssUrl = this.rssUrl;
    }

    try {
      // 调用 MongoDB API 添加播客，后端会处理重复检查
      const updatedPodcasts = await addPodcastToSaved({
        title: podcastToAdd.title,
        rssUrl: podcastToAdd.rssUrl,
        coverImage: podcastToAdd.coverImage,
        description: podcastToAdd.description,
      });
      
      runInAction(() => {
        this.savedPodcasts.splice(0, this.savedPodcasts.length, ...updatedPodcasts);
      });
      console.log("Added to savedPodcasts:", podcastToAdd.title);
    } catch (error) {
      console.error("Failed to add podcast:", error);
      // 显示后端返回的具体错误信息
      const errorMessage = error.message || "添加播客失败，请重试";
      alert(errorMessage);
    }
  },

  // Unsave selected podcast
  async removeFromSaved(podcastToRemove) {
    try {
      // 调用 MongoDB API 删除播客
      const updatedPodcasts = await removePodcastFromSaved(podcastToRemove.title);
      
      runInAction(() => {
        this.savedPodcasts.splice(0, this.savedPodcasts.length, ...updatedPodcasts);
      });
      console.log("Removed from savedPodcasts:", podcastToRemove.title);
    } catch (error) {
      console.error("Failed to remove podcast:", error);
      alert("删除播客失败，请重试");
    }
  },

  // Dictionary lookup method
async lookupWord(word) {
  try {
    // 使用统一的字典API
    const result = await DictionaryAPI.getWord(word);
    this.dictionaryResult = result;
    return result;
  } catch (error) {
    console.error("Dictionary lookup failed:", error);
    this.dictionaryResult = null;
    return null;
  }
},

  // Set error message
  setErrorMsg(message) {
    this.errorMsg = message;
  },
});
</file>

<file path="src/ReactRoot.tsx">
import { observer } from "mobx-react-lite";
import { createHashRouter, RouterProvider } from "react-router-dom";
import React, { Suspense, lazy } from "react";
// import { HomePagePresenter } from "./presenter/HomePagePresenter";
// // import { Transcription } from "./presenter/TranscrptionPresenter";
// import { WordlistPresenter } from "./presenter/WordlistPresenter";
// import PodcastChannelPresenter from "./presenter/PodcastChannelPresenter";
// import PodcastPlayPresenter from "./presenter/PodcastPlayPresenter";
import LoginPresenter from "./presenter/loginPagePresenter";
// import { RssPresenter } from "./presenter/rssPresenter"; // 测试组件，已移除
// import TestPresenter from "./test/TestPresenter";
// import SavedPodcastsPresenter from "./presenter/SavedPodcastsPresenter";
// import { PodcastSearchPresenter } from "./presenter/PodcastSearchPresenter";
const HomePagePresenter = lazy(() => import("./presenter/HomePagePresenter"));
const PodcastSearchPresenter = lazy(() => import("./presenter/PodcastSearchPresenter"));
const WordlistPresenter = lazy(() => import("./presenter/WordlistPresenter"));
const PodcastChannelPresenter = lazy(() => import("./presenter/PodcastChannelPresenter"));
const PodcastPlayPresenter = lazy(() => import("./presenter/PodcastPlayPresenter"));
// const LoginPresenter = lazy(() => import("./presenter/loginPagePresenter"));
// const RssPresenter = lazy(() => import("./presenter/rssPresenter")); // 测试组件，已移除
const TestPresenter = lazy(() => import("./test/TestPresenter"));
const SavedPodcastsPresenter = lazy(() => import("./presenter/SavedPodcastsPresenter"));


type Props = { model: any };   

// const ReactRoot = observer(function ReactRoot(props: Props) {
//   return (
//     <RouterProvider router={makeRouter(props.model)} />
//     /*RouterProvider comes from react-router-dom*/
//   );
// });

const ReactRoot = observer((props: { model: any }) => {
  return (
    <Suspense fallback={null}>   {/* ← 不再显示 loading 提示 */}
      <RouterProvider router={makeRouter(props.model)} />
    </Suspense>
  );
});

export { ReactRoot };

export function makeRouter(ReactiveModel: any) { // [fix]
  return createHashRouter([
    {
      path: "/",
      element: <HomePagePresenter model={ReactiveModel} />,
    },
    {
      path: "/search",
      element: <PodcastSearchPresenter model={ReactiveModel} />,
    },
    {
      path: "/wordlist",
      element: <WordlistPresenter model={ReactiveModel} />,
    },
    // {
    //   path: "/Transcription",
    //   element: <Transcription model={ReactiveModel} />,
    // },
    {
      path: "/login",
      element: <LoginPresenter model={ReactiveModel} />,
    },
    {
      path: "/podcast-channel",
      element: <PodcastChannelPresenter model={ReactiveModel} />,
    },
    {
      path: "/podcast-play",
      element: <PodcastPlayPresenter model={ReactiveModel} />,
    },
    // {
    //   path: "/rss-test",
    //   element: <RssPresenter model={ReactiveModel} />, // 测试路由，已移除
    // },
    {
      path: "/test",
      element: <TestPresenter />,
    },
    {
      path: "/saved-podcasts",
      element: <SavedPodcastsPresenter model={ReactiveModel} />,
    },
  ]);
}
</file>

<file path="src/resolvePromise.ts">
//TW2.2.1:

export function resolvePromise(prms, promiseState){
  promiseState.promise = prms; //record prms
  promiseState.data = null; // clear the previous data
  promiseState.error = null; // clear the previous error

  if (!prms) return; // in case of empty promise

  function successACB(result){
    if(promiseState.promise === prms)
      promiseState.data = result;
  }
  function failureACB(result){
    if(promiseState.promise === prms)
      promiseState.error = result;
  }

  prms.then(successACB).catch(failureACB);
  
}
</file>

<file path="src/rssModel.ts">
// RSS 解析改为使用本地后端 API
import { apiRequest } from './config/apiConfig';

// function formatDuration(duration) {
//   if (!duration) return "Unknown";

//   if (typeof duration === "number") {
//     const m = Math.floor(duration / 60);
//     const s = duration % 60;
//     return `${m}:${s.toString().padStart(2, "0")}`;
//   }

//   if (typeof duration === "string") {
//     if (/^\d+$/.test(duration)) {
//       // Pure number of seconds
//       return formatDuration(Number(duration));
//     }
//     if (
//       /^\d{1,2}:\d{2}$/.test(duration) ||
//       /^\d{1,2}:\d{2}:\d{2}$/.test(duration)
//     ) {
//       // Already in standard format
//       return duration;
//     }
//   }

//   return "Unknown";
// }

export class RssModel {
  
  // [fix] 明确声明成员字段类型
  feed: any = null;
  items: any[] = [];
  subscribers: Array<(model: RssModel) => void> = [];

  constructor() {
    this.feed = null;
    this.items = [];
    this.subscribers = [];
    // this.parser = new Parser({
    //   customFields: {
    //     feed: ["image", "language", "copyright"],
    //     item: [
    //       "itunes:duration",
    //       "itunes:image",
    //       "itunes:episode",
    //       "itunes:season",
    //       "itunes:summary",
    //       "enclosure",
    //     ],
    //   },
    // });
  }

  async loadFeed(url) {
    try {
      // 调用本地后端 RSS API
      const response = await apiRequest(
        `/api/rss/fetch?url=${encodeURIComponent(url)}`
      );
      if (!response.ok) {
        throw new Error(`Failed to fetch RSS feed: ${response.status}`);
      }
      const data = await response.json();

      // 后端返回 { feedMeta, items }，映射为前端需要的格式
      this.feed = data.feedMeta || data.feed;
      this.items = data.items || [];

      // this.feed = {
      //   title: data.title,
      //   description: data.description,
      //   image: data.image,
      //   link: data.link,
      // };

      // this.items = data.items.map(function(item) {
      //   return {
      //     title: item.title,
      //     description: item.contentSnippet || item.description,
      //     pubDate: item.pubDate || item.isoDate,
      //     // duration: item.itunes?.duration, // Duration cannot be displayed
      //     duration: formatDuration(item.itunes?.duration),
      //     episode: item.itunes?.episode,
      //     season: item.itunes?.season,
      //     image: item.itunes?.image || data.image,
      //     guid: item.guid,
      //     link: item.link,
      //     enclosure: item.enclosure,
      //   };
      // });

      this.notifySubscribers();

      // 返回统一的格式给上层调用者
      return { 
        feed: this.feed,   // 已经从 feedMeta 映射过了
        items: this.items 
      };
    } catch (error) {
      console.error("Error loading RSS feed:", error);
      throw error;
    }
  }

  getFeedInfo() {
    return this.feed;
  }

  getEpisodes() {
    return this.items;
  }

  subscribe(callback) {
    this.subscribers.push(callback);
    return function () {
      this.subscribers = this.subscribers.filter(function (cb) {
        return cb !== callback;
      });
    };
  }

  notifySubscribers() {
    this.subscribers.forEach(function (callback) {
      callback(this);
    });
  }
}
</file>

<file path="src/services.ts">
import { PROXY_URL } from "./apiConfig";
// Service function to fetch RSS feed data
export const fetchRssFeed = function(url, callback) {
  fetch(PROXY_URL + "?url=" + url)
    .then(function(response) {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(function(data) {
      callback(null, {
        title: data.title,
        description: data.description,
        items: data.items,
      });
    })
    .catch(function(error) {
      console.error("Error fetching RSS feed:", error);
      callback(error, null);
    });
};

// // Test function for RSS parser
// // Example usage with BBC News RSS feed
// function testRssParser() {
//   // Test with BBC News feed URL
//   const testUrl = "https://feeds.bbci.co.uk/news/rss.xml";

//   fetchRssFeed(testUrl, function(error, feedData) {
//     if (error) {
//       console.error("Test failed:", error);
//       return;
//     }
//     // Log successful test results
//     console.log("Test successful:");
//     console.log("- RSS Feed Title:", feedData.title);
//     console.log("- RSS Feed Description:", feedData.description);
//     console.log("- First Article:", feedData.items[0]);
//   });
// }

// // Run the test
// testRssParser();
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "dh2642-29c50"
  }
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Firebase local runtime & logs
functions/.runtimeconfig.json
firebase-debug.log

# Firebase Functions build output (ts-js)
functions/lib/
</file>

<file path="app-backup.json">
[
    {
        "Id": "6e3e2565a4eb7ff13fa2aa45464d119f8d0fec0431c7c8198bdcf53fe0a2062b",
        "Created": "2025-10-05T20:42:40.119529253Z",
        "Path": "docker-entrypoint.sh",
        "Args": [
            "npm",
            "start"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 633,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2025-10-17T12:37:26.145443335Z",
            "FinishedAt": "2025-10-08T21:57:52.102028171Z"
        },
        "Image": "sha256:9a295a4fb1038134b90b97ee93367f40c122533534ce840be7e698340cdefa0a",
        "ResolvConfPath": "/var/lib/docker/containers/6e3e2565a4eb7ff13fa2aa45464d119f8d0fec0431c7c8198bdcf53fe0a2062b/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/6e3e2565a4eb7ff13fa2aa45464d119f8d0fec0431c7c8198bdcf53fe0a2062b/hostname",
        "HostsPath": "/var/lib/docker/containers/6e3e2565a4eb7ff13fa2aa45464d119f8d0fec0431c7c8198bdcf53fe0a2062b/hosts",
        "LogPath": "/var/lib/docker/containers/6e3e2565a4eb7ff13fa2aa45464d119f8d0fec0431c7c8198bdcf53fe0a2062b/6e3e2565a4eb7ff13fa2aa45464d119f8d0fec0431c7c8198bdcf53fe0a2062b-json.log",
        "Name": "/listenary-backend-app-1",
        "RestartCount": 0,
        "Driver": "overlayfs",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "listenary-backend_default",
            "PortBindings": {
                "3000/tcp": [
                    {
                        "HostIp": "",
                        "HostPort": "3000"
                    }
                ]
            },
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "ConsoleSize": [
                0,
                0
            ],
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "private",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": [],
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": null,
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": null,
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": null,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/interrupts",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware",
                "/sys/devices/virtual/powercap"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": null,
            "Name": "overlayfs"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "6e3e2565a4eb",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "ExposedPorts": {
                "3000/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "MONGO_URI=mongodb://db:27017/listenary-db",
                "JWT_SECRET=your_super_secret_and_long_string_that_no_one_can_guess",
                "MATICS_API_KEY=RsQh9iKtTsQLl3ULMRdmiUK79APdpgUi",
                "NODE_ENV=development",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "NODE_VERSION=20.19.5",
                "YARN_VERSION=1.22.22"
            ],
            "Cmd": [
                "npm",
                "start"
            ],
            "Image": "listenary-backend-app",
            "Volumes": null,
            "WorkingDir": "/app",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "com.docker.compose.config-hash": "7f3641b891235ff208a80b7a2cd6adb88606daa6e7f14aca1643cb5fc63d3360",
                "com.docker.compose.container-number": "1",
                "com.docker.compose.depends_on": "db:service_started:false",
                "com.docker.compose.image": "sha256:9a295a4fb1038134b90b97ee93367f40c122533534ce840be7e698340cdefa0a",
                "com.docker.compose.oneoff": "False",
                "com.docker.compose.project": "listenary-backend",
                "com.docker.compose.project.config_files": "/Users/basinzhang/Documents/Listenary-ongoing/listenary-backend/docker-compose.yml",
                "com.docker.compose.project.working_dir": "/Users/basinzhang/Documents/Listenary-ongoing/listenary-backend",
                "com.docker.compose.service": "app",
                "com.docker.compose.version": "2.39.2"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "7a566e47ef24dda647f06c7876aee2c637690eaab002b6b10cb7428cabc0f63f",
            "SandboxKey": "/var/run/docker/netns/7a566e47ef24",
            "Ports": {
                "3000/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "3000"
                    },
                    {
                        "HostIp": "::",
                        "HostPort": "3000"
                    }
                ]
            },
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "",
            "Gateway": "",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "",
            "IPPrefixLen": 0,
            "IPv6Gateway": "",
            "MacAddress": "",
            "Networks": {
                "listenary-backend_default": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "listenary-backend-app-1",
                        "app"
                    ],
                    "MacAddress": "0e:c2:91:27:26:b5",
                    "DriverOpts": null,
                    "GwPriority": 0,
                    "NetworkID": "2555f643b10b250917d73c8ebea30db1c0fa6decb751be6b55ed34ce25fb2159",
                    "EndpointID": "2b58745b9f77b00eaa0d1afeb34df05d3fa71ed0a16f9476dbcf4a7827e6031a",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DNSNames": [
                        "listenary-backend-app-1",
                        "app",
                        "6e3e2565a4eb"
                    ]
                }
            }
        },
        "ImageManifestDescriptor": {
            "mediaType": "application/vnd.oci.image.manifest.v1+json",
            "digest": "sha256:feec64ae7183561bb6c573307e30a9317a7862d2cd8e42d12d0f788f95a7dc80",
            "size": 2002,
            "platform": {
                "architecture": "arm64",
                "os": "linux"
            }
        }
    }
]
</file>

<file path="db-backup.json">
[
    {
        "Id": "07673584d5d9e09f69ec101fba40a1df4f7e3e4d221cbf11dbe803a70d7c97ca",
        "Created": "2025-10-05T20:42:40.059226378Z",
        "Path": "docker-entrypoint.sh",
        "Args": [
            "mongod"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 713,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2025-10-17T12:37:27.042131336Z",
            "FinishedAt": "2025-10-08T21:57:51.556381213Z"
        },
        "Image": "sha256:ea783d8ac4dcac9f8a7ff236b26a52e36649fc1bdd1778ffb44ba5e4de776cda",
        "ResolvConfPath": "/var/lib/docker/containers/07673584d5d9e09f69ec101fba40a1df4f7e3e4d221cbf11dbe803a70d7c97ca/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/07673584d5d9e09f69ec101fba40a1df4f7e3e4d221cbf11dbe803a70d7c97ca/hostname",
        "HostsPath": "/var/lib/docker/containers/07673584d5d9e09f69ec101fba40a1df4f7e3e4d221cbf11dbe803a70d7c97ca/hosts",
        "LogPath": "/var/lib/docker/containers/07673584d5d9e09f69ec101fba40a1df4f7e3e4d221cbf11dbe803a70d7c97ca/07673584d5d9e09f69ec101fba40a1df4f7e3e4d221cbf11dbe803a70d7c97ca-json.log",
        "Name": "/listenary-backend-db-1",
        "RestartCount": 0,
        "Driver": "overlayfs",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": [
                "listenary-backend_mongo-data:/data/db:rw"
            ],
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "listenary-backend_default",
            "PortBindings": {
                "27017/tcp": [
                    {
                        "HostIp": "",
                        "HostPort": "27017"
                    }
                ]
            },
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "ConsoleSize": [
                0,
                0
            ],
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "private",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": [],
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": null,
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": null,
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": null,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/interrupts",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware",
                "/sys/devices/virtual/powercap"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": null,
            "Name": "overlayfs"
        },
        "Mounts": [
            {
                "Type": "volume",
                "Name": "bf7a2693985639581118de111ab2ce14d027e2398e6c6dc8d0b4d2d2fee76544",
                "Source": "/var/lib/docker/volumes/bf7a2693985639581118de111ab2ce14d027e2398e6c6dc8d0b4d2d2fee76544/_data",
                "Destination": "/data/configdb",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            },
            {
                "Type": "volume",
                "Name": "listenary-backend_mongo-data",
                "Source": "/var/lib/docker/volumes/listenary-backend_mongo-data/_data",
                "Destination": "/data/db",
                "Driver": "local",
                "Mode": "rw",
                "RW": true,
                "Propagation": ""
            }
        ],
        "Config": {
            "Hostname": "07673584d5d9",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "ExposedPorts": {
                "27017/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.19",
                "JSYAML_VERSION=3.13.1",
                "JSYAML_CHECKSUM=662e32319bdd378e91f67578e56a34954b0a2e33aca11d70ab9f4826af24b941",
                "MONGO_PACKAGE=mongodb-org",
                "MONGO_REPO=repo.mongodb.org",
                "MONGO_MAJOR=8.0",
                "MONGO_VERSION=8.0.15",
                "HOME=/data/db",
                "GLIBC_TUNABLES=glibc.pthread.rseq=0"
            ],
            "Cmd": [
                "mongod"
            ],
            "Image": "mongo:latest",
            "Volumes": {
                "/data/configdb": {},
                "/data/db": {}
            },
            "WorkingDir": "",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "com.docker.compose.config-hash": "add3deb5bb3d0a29ebdb373142c908825acacd68f6a360c0ad9338c469253cbb",
                "com.docker.compose.container-number": "1",
                "com.docker.compose.depends_on": "",
                "com.docker.compose.image": "sha256:ea783d8ac4dcac9f8a7ff236b26a52e36649fc1bdd1778ffb44ba5e4de776cda",
                "com.docker.compose.oneoff": "False",
                "com.docker.compose.project": "listenary-backend",
                "com.docker.compose.project.config_files": "/Users/basinzhang/Documents/Listenary-ongoing/listenary-backend/docker-compose.yml",
                "com.docker.compose.project.working_dir": "/Users/basinzhang/Documents/Listenary-ongoing/listenary-backend",
                "com.docker.compose.service": "db",
                "com.docker.compose.version": "2.39.2",
                "org.opencontainers.image.ref.name": "ubuntu",
                "org.opencontainers.image.version": "24.04"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "8afb53754697cbf4eba1bea3d122dbc175c8241e1cda35b0422a08628f8c6e1d",
            "SandboxKey": "/var/run/docker/netns/8afb53754697",
            "Ports": {
                "27017/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "27017"
                    },
                    {
                        "HostIp": "::",
                        "HostPort": "27017"
                    }
                ]
            },
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "",
            "Gateway": "",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "",
            "IPPrefixLen": 0,
            "IPv6Gateway": "",
            "MacAddress": "",
            "Networks": {
                "listenary-backend_default": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "listenary-backend-db-1",
                        "db"
                    ],
                    "MacAddress": "8e:86:cf:b2:12:2f",
                    "DriverOpts": null,
                    "GwPriority": 0,
                    "NetworkID": "2555f643b10b250917d73c8ebea30db1c0fa6decb751be6b55ed34ce25fb2159",
                    "EndpointID": "e5320d8c457f50043744dee5e99f486f0b5958fb22f4126c27b1cb570ceb51e4",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DNSNames": [
                        "listenary-backend-db-1",
                        "db",
                        "07673584d5d9"
                    ]
                }
            }
        },
        "ImageManifestDescriptor": {
            "mediaType": "application/vnd.oci.image.manifest.v1+json",
            "digest": "sha256:773281a4cc0c88956157c7b311f83357bf9be7ed834911bcdfe1cb01e12058da",
            "size": 2478,
            "annotations": {
                "com.docker.official-images.bashbrew.arch": "arm64v8",
                "org.opencontainers.image.base.digest": "sha256:2be8b2a98762fee2ca56f80ae354560b5b4cb40c392dd6dbb34ae52555b5549c",
                "org.opencontainers.image.base.name": "ubuntu:noble",
                "org.opencontainers.image.created": "2025-10-02T18:08:41Z",
                "org.opencontainers.image.revision": "c7ea10a79db9577890466804058872f34f21b3ab",
                "org.opencontainers.image.source": "https://github.com/docker-library/mongo.git#c7ea10a79db9577890466804058872f34f21b3ab:8.0",
                "org.opencontainers.image.url": "https://hub.docker.com/_/mongo",
                "org.opencontainers.image.version": "8.0.15-noble"
            },
            "platform": {
                "architecture": "arm64",
                "os": "linux",
                "variant": "v8"
            }
        }
    }
]
</file>

<file path="firebase.json">
{
  "hosting": {
    "public": "dist",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "/deepl/**",
        "function": "translate"
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "runtime": "nodejs20"
    },
    {
      "source": "listenary-backend",
      "codebase": "listenary-backend",
      "runtime": "nodejs20",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    }
  ]
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" href="/asset/SingleLOGO.svg" type="image/svg+xml">
    <title>Listenary - Turn every podcast into knowledge.</title>
    <meta charset="UTF-8" />
     <!-- 引入 Google Fonts 的 Candal 字体 -->
     <link href="https://fonts.googleapis.com/css2?family=Candal&display=swap" rel="stylesheet">
    </head>
  <body>
    <div id="root"></div> <!--*entry page for the app; provide the root element*-->
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "jigao-liyuans-ruopeng-yuezhe-vt25-project",
  "version": "1.0.0",
  "private": true,
  "description": "Listenary is an English language learning platform for English learners, where you can listen to podcasts, transcribe them, translate them, and build your wordlist.",
  "repository": {
    "type": "git",
    "url": "https://gits-15.sys.kth.se/iprog-students/jigao-liyuans-ruopeng-yuezhe-vt25-Project.git"
  },
  "type": "module",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@emotion/react": "^11.9.3",
    "@emotion/styled": "^11.9.3",
    "@material/web": "^2.3.0",
    "@mui/icons-material": "^7.1.0",
    "@mui/material": "^7.1.0",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "dotenv": "^17.2.2",
    "express": "^5.1.0",
    "express-rate-limit": "^8.1.0",
    "firebase": "^11.6.0",
    "helmet": "^8.1.0",
    "mobx": "^6.13.5",
    "mobx-react-lite": "^4.0.7",
    "mongoose": "^8.18.2",
    "newskit": "^7.7.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-h5-audio-player": "^3.10.0-rc.1",
    "react-router-dom": "^6.22.1",
    "react-toastify": "^11.0.5",
    "rss-parser": "^3.13.0",
    "wavesurfer.js": "^7.9.5",
    "web-vitals": "^2.1.4",
    "ws": "^8.18.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^24.7.0",
    "@types/react": "^19.1.13",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^4.3.4",
    "bcryptjs": "^3.0.2",
    "install": "^0.13.0",
    "jsonwebtoken": "^9.0.2",
    "npm": "^11.6.1",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3",
    "vite": "^6.2.6",
    "vitest": "^3.1.1"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest",
    "typecheck": "tsc --noEmit -p tsconfig.json"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "main": "vite.config.js"
}
</file>

<file path="README.md">
# Listenary – Podcast-Based Language Learning Platform

Listenary is an English language learning platform for English learners, where you can listen to podcasts, transcribe them, translate them, and build your wordlist.

You only need 3 simple steps to start your learning journey:

**Step 1**: Open the third-party tool Castos RSS Finder, search the podcast title you want to learn, and copy paste the rss link of the podcast into the Parse box above.

**Step 2**: Click on Parse, then on the podcast channel page click on the episode you want to learn.

**Step 3**: On the episode page, click on Transcibe to see the transcription result in English. You can also click Translate to get translation in your own language.

## Features

1. Load and parse podcast episodes from any public RSS feed

2. Display podcast metadata (title, publish date, description, episodes)

3. Integrated audio streaming and waveform visualization

4. Time-aligned transcription results of the podcast alongside the audio for easy navigation

5. One-click full podcast translation and vocabulary look-up
   
6. Personal vocabulary list management

## Tech Stack

1. **Frontend Framework**: React
2. **State Management**: MobX
3. **Speech to Text**: Microsoft Azure Speech-to-Text API
4. **Translation**: DeepL API
5. **Dictionary**: Dictionary API (https://dictionaryapi.dev/)
6. **Authentication**: Google OAuth 2.0 API
7. **RSS Parsing**: rss-parser (Node.js library)
8. **Languages**: JavaScript / CSS / HTML
9. **Build Tool**: Vite

## Running deployed application

https://dh2642-29c50.web.app

## Setup and Running Instructions locally

### Install Dependences

```bash
npm install
```

### Start the development server:

```bash
npm run dev
```

## Used Third-party components

1. [Audio Waveform Player](https://wavesurfer.xyz/): We use this open-source audio visualization library to build an audio player that visually represents the playing progress. With this third-party component, users can efficiently locate the sentence they are listening to, click on the waveform, and seamlessly synchronize the audio with the transcription.

2. [Material UI](https://m3.material.io/develop/web): We use this popular React component library to build modern and responsive user interfaces. With this third-party component, users can enjoy a consistent and intuitive design while interacting with various features, enhancing the overall user experience.

## Sample RSS Feeds

Feel free to use the following sample links to test podcast loading and transcription:

- https://feeds.captivate.fm/one-minute-podcast-tips/
- https://feed.podcastmachine.com/podcasts/1288/mp3.rss
- http://img.webmd.com/video_itunes/feed.xml
- https://feeds.buzzsprout.com/2295449.rss

You can also get rss links by searching podcast name from this website: https://castos.com/tools/find-podcast-rss-feed/

### Due to limitation of API usage, we recommend you to choose podcast episodes that are no longer than 30 minutes.
</file>

<file path="repomix-output-aaaaabiang-Listenary-ongoing.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebase/
  hosting.ZGlzdA.cache
asset/
  Episode-Cover.svg
  LOGO.svg
  Podcast.svg
  SingleLOGO.svg
functions/
  index.js
  package.json
listenary-backend/
  config/
    apiConfig.js
    firebaseConfig.js
  modules/
    transcription-example/
      controller.ts
      model.ts
      repository.ts
      service.ts
  .gitignore
  package.json
  server.ts
server/
  index.js
  package.json
src/
  api/
    dictionaryAPI.jsx
    TranslationAPI.jsx
  components/
    AudioPlayerComponent.jsx
    CollapseBox.jsx
    TopNav.jsx
  hooks/
    useAudioPlayback.js
    useRSSInput.js
    useTranscriptionManager
    useTranscriptionSync
    useTranslationHandler
    useWordLookup
  presenter/
    HomePagePresenter.jsx
    loginPagePresenter.jsx
    PodcastChannelPresenter.jsx
    PodcastPlayPresenter.jsx
    rssPresenter.jsx
    SavedPodcastsPresenter.jsx
    WordlistPresenter.jsx
  styles/
    AudioPlayer.css
    CollapseBox.css
    HomePage.css
    LoginPage.css
    PodcastChannel.css
    PodcastPlay.css
    theme.js
    TopNav.css
    Wordlist.css
  test/
    asrTest.jsx
    TestPresenter.jsx
  views/
    PodcastView/
      DictionaryCard.jsx
      PodcastInfoCard.jsx
      PodcastPlayView.jsx
      TranscriptList.jsx
    HomePageView.jsx
    loginPageView.jsx
    PodcastChannelView.jsx
    SavedPodcastsView.jsx
    suspenseView.jsx
    WordlistView.jsx
  firestoreModel.js
  index.jsx
  loginModel.js
  Model.js
  ReactRoot.jsx
  resolvePromise.js
  rssModel.js
  speechToText.js
.firebaserc
.gitignore
firebase.json
index.html
package.json
README.md
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".firebase/hosting.ZGlzdA.cache">
saved-icon.png,1744807418273,f1b651238a58fe290baec6c5e32f3bdb1943dd2bd582f02569231f7a757c7837
logo.png,1744807418273,f1b651238a58fe290baec6c5e32f3bdb1943dd2bd582f02569231f7a757c7837
index.html,1747682694766,bda2cd4056b9f0476b38b317696e636e0ed15a199a4f3bef9e1b0649d77a350b
assets/index-BxHg_pkS.css,1747682694767,e5a4976e17a1178a0e102b8547a678538be7d339552c1a0104323ad236494f9c
assets/SingleLOGO-S-Kjgs1i.svg,1747682694766,b6cee4df303cdbe1f887681e106b52bd3e34469e50446ecdf2d790beedd34d8b
assets/vendor-XyqgThqv.js,1747682694766,e2c8f9fd1555f8fd2901722fd5873064f361129ea1cdcab8b8407df54297a500
assets/vendor-XyqgThqv.js.map,1747682694766,07168351d1f4a888f16a01e44ddca65715bd003fb652b7ee9d4aedcbd87db6e0
assets/index-B1fHrxOB.js,1747682694767,9669a3708e2f279c4d7c59d4a14bdf2a1e7506d92e74c71966dad964fa4b4544
assets/index-B1fHrxOB.js.map,1747682694768,2feb6a1b45ca0d696f4e343f64a2bf11db439a33db551dcfc7d4c754543dc16b
</file>

<file path="asset/Episode-Cover.svg">
<svg width="160" height="160" viewBox="0 0 160 160" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="160" height="160" fill="#F5F9FF"/>
<g filter="url(#filter0_i_269_1730)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M78.2744 113.5C79.0461 113.5 79.5331 112.659 79.197 111.964C77.8 109.078 77 105.845 77 102.4C77 90.153 87.0128 80.2 99.3333 80.2C100.204 80.2 101.057 80.2701 101.905 80.374C102.512 80.4485 103.056 79.9827 103.056 79.3711V46.9C103.056 42.793 99.7056 39.5 95.6111 39.5H75.2778C74.7255 39.5 74.2778 39.9477 74.2778 40.5V64.7257C74.2778 65.4824 73.4699 65.9649 72.8036 65.6061L64.4464 61.1054C64.1504 60.9459 63.7941 60.9459 63.4981 61.1054L55.1408 65.6061C54.4746 65.9649 53.6667 65.4824 53.6667 64.7257V40.5C53.6667 39.9477 53.219 39.5 52.6667 39.5H50.9444C46.8128 39.5 43.5 42.83 43.5 46.9V106.1C43.5 110.207 46.8128 113.5 50.9444 113.5H78.2744Z" fill="#D8E3FF"/>
</g>
<g filter="url(#filter1_i_269_1730)">
<path d="M94.5034 93.242C93.1701 92.4687 91.5 93.4307 91.5 94.9721V117.028C91.5 118.569 93.1701 119.531 94.5034 118.758L113.517 107.73C114.846 106.959 114.846 105.041 113.517 104.27L94.5034 93.242Z" fill="#006BFE"/>
</g>
<g filter="url(#filter2_i_269_1730)">
<path d="M56.5 60.6667V41C56.5 40.1716 57.1716 39.5 58 39.5H70C70.8284 39.5 71.5 40.1716 71.5 41V60.6667C71.5 61.0441 71.0978 61.2855 70.7647 61.1078L64.4706 57.751C64.1765 57.5941 63.8235 57.5941 63.5294 57.751L57.2353 61.1078C56.9022 61.2855 56.5 61.0441 56.5 60.6667Z" fill="#465A8D"/>
</g>
<defs>
<filter id="filter0_i_269_1730" x="43.5" y="39.5" width="59.5557" height="74" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
<filter id="filter1_i_269_1730" x="91.5" y="92.969" width="23.0137" height="26.062" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.5 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
<filter id="filter2_i_269_1730" x="56.5" y="39.5" width="15" height="21.6672" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.139885 0 0 0 0 0.144685 0 0 0 0 0.427885 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_269_1730"/>
</filter>
</defs>
</svg>
</file>

<file path="asset/LOGO.svg">
<svg width="416" height="81" viewBox="0 0 416 81" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_244_1660)">
<path d="M40.4445 5C49.2198 5 56.3334 12.136 56.3334 20.9388V27.4592C56.3334 31.6943 54.6861 35.5428 52.0001 38.3973V20.2143C52.0001 13.8123 46.8265 8.62245 40.4445 8.62245H27.4446C21.0626 8.62245 15.889 13.8123 15.889 20.2143V38.3973C13.203 35.5428 11.5557 31.6943 11.5557 27.4592V20.9388C11.5557 12.136 18.6693 5 27.4446 5H40.4445Z" fill="#D8E3FF"/>
<path d="M41.8889 13.6938C44.681 13.6938 46.9444 15.8879 46.9444 18.5943V63.4476C46.9444 66.154 46.1254 66.8991 43.3333 66.8991H6.5C5.05556 66.8991 4.33333 68.0306 4.33333 69.0237V69.6994C4.33333 70.8593 5.30339 71.7995 6.5 71.7995H49.8333C51.03 71.7995 52 70.8593 52 69.6994V34.5331C55.9722 34.5331 52.8932 34.5331 56.3333 34.5331C56.3333 36.9834 56.3333 38.4003 56.3333 39.4336V71.0995C56.3333 73.8059 54.0699 76 51.2778 76H5.05556C2.26345 76 0 73.8059 0 71.0995V18.5943C0 18.516 0.00188737 18.438 0.00564236 18.3605C0.00771593 18.3178 0.0116124 18.2752 0.0148112 18.2327C0.0177014 18.1943 0.0201823 18.156 0.02398 18.1178C0.0273287 18.0842 0.0319233 18.0508 0.0359701 18.0173C0.0417566 17.9695 0.047112 17.9218 0.0543077 17.8744C0.0591405 17.8426 0.0650688 17.8111 0.0705295 17.7794C0.0782398 17.7348 0.0862687 17.6903 0.0952149 17.6461C0.101088 17.617 0.107153 17.5881 0.113553 17.5593C0.125659 17.5047 0.138379 17.4504 0.152344 17.3966C0.157503 17.3766 0.163156 17.3569 0.168565 17.3371C0.181777 17.2887 0.195492 17.2406 0.210178 17.1928C0.221022 17.1576 0.232395 17.1225 0.244032 17.0876C0.255402 17.0534 0.26718 17.0195 0.279297 16.9856C0.293668 16.9456 0.308323 16.9057 0.32373 16.866C0.335141 16.8367 0.347023 16.8076 0.358995 16.7785C0.375235 16.7391 0.391813 16.6998 0.409071 16.6609C0.427301 16.6198 0.446148 16.5791 0.465495 16.5386C0.478581 16.5112 0.491401 16.4836 0.504991 16.4565C0.523706 16.4192 0.543874 16.3826 0.563531 16.3458C0.632423 16.2167 0.707058 16.0911 0.787107 15.969C0.808123 15.9371 0.828837 15.9048 0.850583 15.8733C0.879248 15.8318 0.908823 15.791 0.938744 15.7503C0.951983 15.7323 0.964766 15.7141 0.978243 15.6963C1.00843 15.6564 1.03996 15.6176 1.07134 15.5787C1.08848 15.5575 1.10535 15.5361 1.12283 15.5151C1.15043 15.482 1.17899 15.4497 1.20747 15.4173C1.22943 15.3924 1.25129 15.3673 1.27376 15.3429C1.30835 15.305 1.3438 15.2681 1.37956 15.2314C1.39086 15.2198 1.40199 15.208 1.41341 15.1965C1.45123 15.1585 1.48931 15.1206 1.52837 15.0837C1.5497 15.0636 1.57157 15.044 1.59326 15.0242C1.6272 14.9933 1.66142 14.9626 1.69623 14.9327C1.71504 14.9164 1.73431 14.9007 1.75336 14.8848C1.85127 14.8028 1.95168 14.7235 2.05594 14.6489C2.06638 14.6415 2.07717 14.6345 2.08767 14.6271C2.43093 14.3854 2.80686 14.1849 3.20768 14.0323C3.22035 14.0274 3.23304 14.0226 3.24577 14.0179C3.30172 13.9971 3.35815 13.9773 3.41504 13.9584C3.42467 13.9552 3.4343 13.952 3.44395 13.9489L3.55187 13.914C3.58217 13.9048 3.613 13.8973 3.64355 13.8887C3.65691 13.885 3.67035 13.8814 3.68376 13.8777C3.74238 13.8618 3.80133 13.8466 3.86078 13.8327C3.87906 13.8283 3.89744 13.8244 3.9158 13.8203C3.97515 13.8071 4.03481 13.7946 4.09494 13.7834C4.10902 13.7808 4.12314 13.7784 4.13726 13.7759C4.43513 13.7229 4.74188 13.6938 5.05556 13.6938H41.8889Z" fill="#006BFE"/>
<path d="M29.9895 50.2806C29.9895 52.8814 27.8878 54.9898 25.295 54.9898H20.9273C18.3346 54.9898 16.2329 52.8814 16.2329 50.2806C16.2329 48.281 19.3144 46.6582 23.1112 46.6582C26.908 46.6582 29.9895 48.281 29.9895 50.2806ZM23.1112 31.8061C25.4827 31.8061 27.7571 32.7984 29.434 34.5647C31.1109 36.331 32.053 38.7266 32.053 41.2245C32.053 42.382 31.8564 43.4922 31.4953 44.5172C31.1854 45.3972 30.0863 45.5602 29.4064 44.9231C28.9363 44.4826 28.8272 43.7881 29.0144 43.1707C29.2012 42.5546 29.3016 41.8983 29.3016 41.2245C29.3016 37.602 26.5503 34.7041 23.1112 34.7041C19.672 34.7041 16.9207 37.602 16.9207 41.2245C16.9207 41.8983 17.0212 42.5546 17.208 43.1707C17.3952 43.7881 17.286 44.4826 16.8159 44.9231C16.136 45.5602 15.037 45.3972 14.7271 44.5172C14.366 43.4922 14.1694 42.382 14.1694 41.2245C14.1694 38.7266 15.1115 36.331 16.7884 34.5647C18.4653 32.7984 20.7397 31.8061 23.1112 31.8061ZM23.1112 26.0102C26.9421 26.0102 30.6161 27.6131 33.3249 30.4664C36.0338 33.3196 37.5556 37.1894 37.5556 41.2245C37.5556 43.9222 36.886 46.4556 35.7191 48.6512C35.3087 49.4232 34.2848 49.5331 33.651 48.9323C33.1552 48.4623 33.0717 47.7084 33.3855 47.1008C34.289 45.352 34.8043 43.3485 34.8043 41.2245C34.8043 37.958 33.5724 34.8253 31.3795 32.5155C29.1866 30.2058 26.2124 28.9082 23.1112 28.9082C20.01 28.9082 17.0358 30.2058 14.8429 32.5155C12.65 34.8253 11.4181 37.958 11.4181 41.2245C11.4181 43.3485 11.9334 45.352 12.8369 47.1008C13.1507 47.7084 13.0672 48.4623 12.5714 48.9323C11.9375 49.5331 10.9137 49.4232 10.5033 48.6512C9.33639 46.4556 8.66675 43.9222 8.66675 41.2245C8.66675 37.1894 10.1885 33.3196 12.8975 30.4664C15.6063 27.6131 19.2803 26.0102 23.1112 26.0102ZM23.1112 37.602C24.0233 37.602 24.898 37.9837 25.5431 38.663C26.188 39.3423 26.5503 40.2637 26.5503 41.2245C26.5503 42.1852 26.188 43.1066 25.5431 43.7859C24.898 44.4653 24.0233 44.8469 23.1112 44.8469C22.1991 44.8469 21.3243 44.4653 20.6793 43.7859C20.0344 43.1066 19.672 42.1852 19.672 41.2245C19.672 40.2637 20.0344 39.3423 20.6793 38.663C21.3243 37.9837 22.1991 37.602 23.1112 37.602Z" fill="#D8E3FF"/>
<path d="M52 29.9949C52 28.1943 53.4551 26.7347 55.25 26.7347C60.6347 26.7347 65 31.1136 65 36.5153V45.2092C65 50.6108 60.6347 54.9898 55.25 54.9898C53.4551 54.9898 52 53.5302 52 51.7296V29.9949Z" fill="#D8E3FF"/>
<path d="M52 29.9949C52 28.1943 53.4551 26.7347 55.25 26.7347C60.6347 26.7347 65 31.1136 65 36.5153V45.2092C65 50.6108 60.6347 54.9898 55.25 54.9898C53.4551 54.9898 52 53.5302 52 51.7296V29.9949Z" fill="#D8E3FF"/>
</g>
<rect x="123.541" y="18.5457" width="13.3056" height="9.31393" rx="4.65696" fill="#006BFE"/>
<path d="M88 19C88 18.4477 88.4477 18 89 18H100.971C101.523 18 101.971 18.4477 101.971 19V52.1143C101.971 52.6666 102.419 53.1143 102.971 53.1143H115.94C116.492 53.1143 116.94 53.5621 116.94 54.1143V61.0956C116.94 61.6479 116.492 62.0956 115.94 62.0956H89C88.4477 62.0956 88 61.6479 88 61.0956V19Z" fill="#006BFE"/>
<path d="M123.613 32.1081C123.613 31.5558 124.061 31.1081 124.613 31.1081H136.085C136.638 31.1081 137.085 31.5558 137.085 32.1081V61.0956C137.085 61.6479 136.638 62.0956 136.085 62.0956H124.613C124.061 62.0956 123.613 61.6479 123.613 61.0956V32.1081Z" fill="#006BFE"/>
<path d="M173.46 37.0452C173.424 37.7516 172.685 38.199 172.033 37.9262C170.421 37.2524 168.834 36.7122 167.272 36.3056C165.297 35.7651 163.561 35.4948 162.064 35.4948C160.484 35.4948 159.362 35.6507 158.696 35.9626C158.031 36.2536 157.699 36.7734 157.699 37.5218C157.699 38.1871 158.187 38.7173 159.164 39.1123C160.141 39.4865 161.576 39.9231 163.468 40.422C165.36 40.921 167.054 41.4719 168.551 42.0748C170.048 42.6778 171.316 43.4262 172.356 44.3202C173.416 45.2141 174.216 46.2848 174.757 47.5322C175.318 48.7796 175.599 50.3077 175.599 52.1164C175.599 53.738 175.287 55.2245 174.663 56.5759C174.04 57.9064 173.094 59.0499 171.825 60.0062C170.557 60.9626 168.956 61.7006 167.023 62.2204C165.089 62.7401 162.813 63 160.193 63C157.865 63 155.526 62.8233 153.177 62.4699C151.043 62.1678 148.893 61.6429 146.726 60.8952C146.329 60.7582 146.067 60.3817 146.067 59.9617V52.5531C146.067 51.8322 146.807 51.347 147.477 51.6134C149.152 52.2798 150.834 52.832 152.522 53.2703C154.684 53.8316 156.742 54.1123 158.696 54.1123C162.21 54.1123 163.967 53.3846 163.967 51.9293C163.967 51.6798 163.884 51.4511 163.717 51.2432C163.551 51.0353 163.239 50.8378 162.782 50.6507C162.345 50.4428 161.721 50.2349 160.911 50.027C160.121 49.7983 159.102 49.5281 157.854 49.2162C156.129 48.8004 154.497 48.2703 152.958 47.6258C151.441 46.9605 150.11 46.1601 148.967 45.2245C147.844 44.2682 146.95 43.1559 146.285 41.8877C145.64 40.6195 145.318 39.1746 145.318 37.553C145.318 36.0977 145.62 34.7568 146.222 33.5301C146.846 32.3035 147.771 31.2536 148.998 30.3805C150.245 29.5073 151.784 28.8316 153.613 28.3534C155.464 27.8545 157.605 27.605 160.037 27.605C161.451 27.605 162.802 27.6674 164.091 27.7921C165.401 27.9168 166.638 28.0728 167.802 28.2599C168.967 28.4262 170.048 28.6133 171.046 28.8212C171.736 28.9479 172.387 29.0698 173.001 29.187C173.49 29.2804 173.834 29.7206 173.808 30.2177L173.46 37.0452Z" fill="#006BFE"/>
<path d="M199.985 63C198.052 63 196.202 62.7609 194.435 62.2827C192.667 61.8254 191.108 61.0457 189.757 59.9439C188.426 58.8212 187.356 57.3451 186.545 55.5156C185.755 53.6653 185.36 51.368 185.36 48.6237V37.1809C185.36 36.6286 184.912 36.1809 184.36 36.1809H180.154C179.602 36.1809 179.154 35.7332 179.154 35.1809V30.3528C179.154 29.8335 179.549 29.3982 180.064 29.326C181.813 29.0806 185.629 28.3596 187.407 26.5811C189.169 24.8197 189.662 20.9812 189.799 19.1702C189.84 18.6255 190.289 18.1871 190.835 18.1871H197.832C198.384 18.1871 198.832 18.6348 198.832 19.1871V27.447C198.832 27.9993 199.279 28.447 199.832 28.447H207.591C208.222 28.447 208.695 29.0243 208.578 29.6444C208.417 30.4983 208.266 31.3569 208.125 32.2204C207.983 33.1825 207.889 34.1745 207.842 35.1964C207.818 35.7422 207.374 36.1809 206.828 36.1809H199.832C199.279 36.1809 198.832 36.6286 198.832 37.1809V48.499C198.832 49.2474 198.884 49.9751 198.988 50.6819C199.112 51.368 199.351 51.9813 199.705 52.5218C200.058 53.0416 200.568 53.4678 201.233 53.8004C201.898 54.1123 202.782 54.2682 203.884 54.2682C204.59 54.2682 205.37 54.2058 206.222 54.0811C206.742 53.9924 207.303 53.8614 207.907 53.6879C208.531 53.5088 209.18 53.9252 209.24 54.5713L209.8 60.611C209.842 61.0632 209.575 61.4892 209.142 61.6283C208.011 61.9924 206.746 62.2937 205.349 62.5322C203.665 62.8441 201.877 63 199.985 63Z" fill="#006BFE"/>
<path d="M247.293 60.0315C247.293 60.4631 247.017 60.8471 246.604 60.9751C244.846 61.521 242.965 61.9777 240.963 62.3451C238.696 62.7817 236.337 63 233.884 63C231.202 63 228.644 62.6466 226.212 61.9397C223.78 61.2328 221.638 60.131 219.788 58.6341C217.938 57.1372 216.462 55.2453 215.36 52.9584C214.279 50.6507 213.738 47.9064 213.738 44.7256C213.738 42.9168 214.019 41.2432 214.58 39.7048C215.141 38.1455 215.9 36.7318 216.857 35.4636C217.834 34.1954 218.967 33.0728 220.256 32.0956C221.565 31.1185 222.958 30.2973 224.435 29.632C225.931 28.9667 227.47 28.4678 229.05 28.1351C230.63 27.7817 232.179 27.605 233.696 27.605C236.087 27.605 238.198 27.8753 240.027 28.4158C241.857 28.9356 243.374 29.6424 244.58 30.5364C245.807 31.4304 246.732 32.4699 247.356 33.6549C247.979 34.8399 248.291 36.0977 248.291 37.4283C248.291 39.0499 248.01 40.4324 247.449 41.5759C246.909 42.7193 246.17 43.6861 245.235 44.4761C244.32 45.2453 243.249 45.8586 242.023 46.316C240.817 46.7526 239.538 47.0956 238.187 47.3451C236.836 47.5738 235.453 47.7193 234.04 47.7817C232.647 47.8441 231.316 47.8753 230.048 47.8753C229.611 47.8753 229.185 47.8753 228.769 47.8753C228.757 47.8746 228.746 47.874 228.734 47.8734C228.127 47.8424 227.654 48.3839 227.804 48.9725C227.984 49.677 228.233 50.2988 228.551 50.8378C229.05 51.6486 229.663 52.3139 230.391 52.8337C231.139 53.3326 231.992 53.6965 232.948 53.9252C233.925 54.1331 234.965 54.237 236.067 54.237C236.898 54.237 237.782 54.1746 238.717 54.0499C239.674 53.9252 240.63 53.7588 241.586 53.5509C242.563 53.3222 243.53 53.0728 244.486 52.8025C244.988 52.6531 245.479 52.5009 245.958 52.346C246.614 52.1345 247.293 52.6177 247.293 53.3061V60.0315ZM227.384 41.96C227.319 42.5406 227.803 43.0204 228.387 42.991C228.64 42.9781 228.913 42.9638 229.206 42.948C229.996 42.9064 230.827 42.8337 231.701 42.7297C232.574 42.6258 233.447 42.4802 234.32 42.2931C235.193 42.106 235.983 41.8669 236.69 41.5759C237.397 41.2848 237.969 40.921 238.405 40.4844C238.842 40.0478 239.06 39.5177 239.06 38.894C239.06 37.8337 238.634 36.9917 237.782 36.368C236.95 35.7235 235.786 35.4012 234.289 35.4012C233.603 35.4012 232.865 35.5052 232.075 35.7131C231.285 35.9002 230.547 36.2744 229.861 36.8358C229.175 37.3971 228.593 38.1767 228.114 39.1746C227.75 39.9344 227.507 40.8629 227.384 41.96Z" fill="#006BFE"/>
<path d="M256.586 29.447C256.586 28.8947 257.034 28.447 257.586 28.447H268.866C269.488 28.447 269.961 29.0087 269.876 29.6247C269.812 30.092 269.748 30.6141 269.684 31.1913C269.679 31.2358 269.674 31.2803 269.669 31.3249C269.563 32.3086 270.931 32.8036 271.674 32.1506C271.828 32.0155 271.986 31.8828 272.148 31.7526C273.229 30.8794 274.414 30.1414 275.703 29.5385C276.992 28.9148 278.353 28.4366 279.788 28.1039C281.243 27.7713 282.709 27.605 284.185 27.605C285.807 27.605 287.345 27.8545 288.8 28.3534C290.256 28.8316 291.534 29.6008 292.636 30.6611C293.738 31.7214 294.611 33.1039 295.256 34.8087C295.9 36.4927 296.222 38.5405 296.222 40.9522V61.0956C296.222 61.6479 295.775 62.0956 295.222 62.0956H283.751C283.198 62.0956 282.751 61.6479 282.751 61.0956V42.9168C282.751 41.6279 282.615 40.5572 282.345 39.7048C282.075 38.8524 281.701 38.1767 281.222 37.6778C280.744 37.1788 280.173 36.8254 279.507 36.6175C278.863 36.4096 278.156 36.3056 277.387 36.3056C276.555 36.3056 275.734 36.4511 274.923 36.7422C274.112 37.0125 273.374 37.3867 272.709 37.8649C272.044 38.343 271.472 38.9044 270.994 39.5489C270.537 40.1647 270.232 40.8184 270.079 41.5102C270.064 41.5745 270.058 41.6402 270.058 41.7061V61.0956C270.058 61.6479 269.611 62.0956 269.058 62.0956H257.586C257.034 62.0956 256.586 61.6479 256.586 61.0956V29.447Z" fill="#006BFE"/>
<path d="M313.717 63C312.387 63 311.108 62.8129 309.882 62.4387C308.676 62.0644 307.605 61.4927 306.669 60.7235C305.734 59.9543 304.985 58.9875 304.424 57.8233C303.884 56.6383 303.613 55.2453 303.613 53.6445C303.613 52.106 303.863 50.7755 304.362 49.6528C304.861 48.5094 305.526 47.5322 306.358 46.7214C307.21 45.9106 308.198 45.2453 309.32 44.7256C310.464 44.185 311.669 43.7692 312.938 43.4782C314.206 43.1663 315.505 42.9584 316.836 42.8545C318.187 42.7297 319.497 42.6674 320.765 42.6674C321.638 42.6674 322.48 42.6881 323.291 42.7297C323.688 42.7501 324.072 42.7729 324.443 42.7982C325.042 42.8389 325.558 42.3562 325.473 41.7625C325.357 40.9443 325.139 40.2376 324.819 39.6424C324.362 38.7692 323.759 38.0832 323.01 37.5842C322.262 37.0644 321.389 36.7006 320.391 36.4927C319.393 36.2848 318.343 36.1809 317.241 36.1809C316.222 36.1809 315.173 36.2536 314.091 36.3992C313.031 36.5239 311.992 36.6902 310.973 36.8981C309.954 37.0852 308.977 37.2931 308.042 37.5218C307.629 37.6251 307.237 37.724 306.866 37.8188C306.231 37.9814 305.609 37.5027 305.609 36.8464V30.2141C305.609 29.7462 305.933 29.3402 306.391 29.2432C307.181 29.0759 308.012 28.9145 308.884 28.7588C310.069 28.5301 311.295 28.3326 312.563 28.1663C313.832 28 315.121 27.8649 316.43 27.7609C317.761 27.657 319.071 27.605 320.36 27.605C321.961 27.605 323.53 27.7089 325.069 27.9168C326.628 28.1039 328.094 28.4262 329.466 28.8836C330.859 29.341 332.137 29.9543 333.301 30.7235C334.486 31.4927 335.495 32.4491 336.326 33.5925C337.179 34.7152 337.844 36.0457 338.322 37.5842C338.8 39.1227 339.04 40.9002 339.04 42.9168V61.0956C339.04 61.6479 338.592 62.0956 338.04 62.0956H327.191C326.639 62.0956 326.191 61.6479 326.191 61.0956V59.9836C326.191 59.1314 324.733 58.6853 324.102 59.2578V59.2578C323.208 60.0478 322.2 60.7235 321.077 61.2848C319.954 61.8462 318.759 62.2723 317.491 62.5634C316.222 62.8545 314.965 63 313.717 63ZM318.988 55.6715C319.57 55.6715 320.235 55.5156 320.983 55.2037C321.753 54.8711 322.47 54.3721 323.135 53.7069C323.821 53.0416 324.393 52.1996 324.85 51.1809C325.212 50.4105 325.437 49.5273 325.525 48.5311C325.574 47.9809 325.12 47.5322 324.568 47.5322H324.538C323.541 47.5322 322.511 47.6362 321.451 47.8441C320.412 48.052 319.455 48.3638 318.582 48.7796C317.709 49.1954 316.992 49.7048 316.43 50.3077C315.869 50.9106 315.588 51.6071 315.588 52.3971C315.588 53.0208 315.692 53.5405 315.9 53.9563C316.108 54.3721 316.368 54.7152 316.68 54.9854C317.012 55.2349 317.376 55.4116 317.771 55.5156C318.187 55.6195 318.593 55.6715 318.988 55.6715Z" fill="#006BFE"/>
<path d="M348.083 29.447C348.083 28.8947 348.531 28.447 349.083 28.447H359.82C360.403 28.447 360.862 28.9429 360.835 29.5248C360.824 29.7595 360.815 30.0031 360.807 30.2557C360.786 30.9002 360.775 31.5863 360.775 32.3139C360.775 33.0208 360.775 33.738 360.775 34.4657V34.4657C360.775 34.9155 361.459 35.0653 361.674 34.6701C361.896 34.2621 362.137 33.8509 362.397 33.4366C363.062 32.3555 363.842 31.3888 364.736 30.5364C365.651 29.684 366.68 28.9875 367.823 28.447C368.988 27.8857 370.287 27.605 371.721 27.605C371.992 27.605 372.283 27.6258 372.595 27.6674C372.927 27.6881 373.249 27.7297 373.561 27.7921C373.873 27.8545 374.164 27.9376 374.435 28.0416C374.499 28.0599 374.561 28.0793 374.62 28.0997C374.964 28.2184 375.133 28.5791 375.102 28.9423L374.172 39.8832C374.116 40.5445 373.442 40.9686 372.803 40.7916C372.251 40.6388 371.683 40.5156 371.098 40.422C370.058 40.2349 369.154 40.1414 368.385 40.1414C367.324 40.1414 366.389 40.2765 365.578 40.5468C364.788 40.7963 364.112 41.1289 363.551 41.5447C362.99 41.9605 362.543 42.4179 362.21 42.9168C361.925 43.3729 361.718 43.8203 361.589 44.2589C361.565 44.3407 361.555 44.4256 361.555 44.5108V61.0956C361.555 61.6479 361.107 62.0956 360.555 62.0956H349.083C348.531 62.0956 348.083 61.6479 348.083 61.0956V29.447Z" fill="#006BFE"/>
<path d="M402.408 28.6258C402.408 28.0735 402.855 27.6258 403.408 27.6258H414.879C415.432 27.6258 415.879 28.0735 415.879 28.6258V42C415.879 44.3493 415.478 48.1289 415 50C414.522 51.8711 414.019 53.1247 413.166 54.58C412.314 56.0561 411.295 57.3139 410.11 58.3534C408.946 59.4137 407.657 60.2765 406.243 60.9418C404.83 61.6279 403.322 62.1268 401.721 62.4387C400.121 62.7713 398.478 62.9376 396.794 62.9376C394.528 62.9376 392.23 62.9833 389.965 62.5946C386.771 62.0466 384.413 61.3586 382.483 60.1253C382.179 59.9313 382.023 59.5774 382.061 59.2192L382.781 52.407C382.855 51.704 383.615 51.2993 384.245 51.6192C386.074 52.5473 387.364 53.091 389 53.5C390.29 53.8226 392.5 54 394.5 54C397.5 54 399.507 53.4029 401.285 51.7754C402.715 50.466 402.994 49.1434 403.049 45.8662C403.061 45.1307 401.858 44.7319 401.285 45.1933V45.1933C400.536 45.7963 399.705 46.3056 398.79 46.7214C397.875 47.1372 396.909 47.4491 395.89 47.657C394.892 47.8649 393.915 47.9688 392.958 47.9688C391.295 47.9688 389.715 47.7193 388.218 47.2204C386.721 46.7006 385.391 45.9002 384.227 44.8191C383.083 43.7173 382.168 42.3139 381.482 40.6091C380.817 38.9044 380.484 36.8669 380.484 34.4969V28.6258C380.484 28.0735 380.932 27.6258 381.484 27.6258H391.459C392.012 27.6258 392.459 28.0735 392.459 28.6258V34.1227C392.459 35.1622 392.605 36.0665 392.896 36.8358C393.208 37.5842 393.603 38.2079 394.081 38.7069C394.58 39.185 395.141 39.5489 395.765 39.7983C396.389 40.027 397.023 40.1414 397.667 40.1414C398.27 40.1414 398.852 40.0478 399.414 39.8607C399.996 39.6528 400.505 39.3617 400.942 38.9875C401.378 38.5925 401.732 38.1143 402.002 37.553C402.272 36.9917 402.408 36.3472 402.408 35.6195V28.6258Z" fill="#006BFE"/>
<defs>
<clipPath id="clip0_244_1660">
<rect width="65" height="71" fill="white" transform="translate(0 5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="asset/Podcast.svg">
<svg width="145" height="135" viewBox="0 0 145 135" fill="none" xmlns="http://www.w3.org/2000/svg">
<g filter="url(#filter0_i_266_1702)">
<path d="M41 66V61.5C41 44.103 55.103 30 72.5 30V30C89.897 30 104 44.103 104 61.5V64.0274" stroke="#D8E3FF" stroke-width="8"/>
<path d="M36.5 61.5H42C43.3807 61.5 44.5 62.6193 44.5 64V91C44.5 92.3807 43.3807 93.5 42 93.5H36.5C27.6634 93.5 20.5 86.3366 20.5 77.5C20.5 68.6634 27.6634 61.5 36.5 61.5Z" fill="#D8E3FF" stroke="#D8E3FF"/>
<path d="M108.5 93.5L103 93.5C101.619 93.5 100.5 92.3807 100.5 91L100.5 64C100.5 62.6193 101.619 61.5 103 61.5L108.5 61.5C117.337 61.5 124.5 68.6634 124.5 77.5C124.5 86.3366 117.337 93.5 108.5 93.5Z" fill="#D8E3FF" stroke="#D8E3FF"/>
<g filter="url(#filter1_i_266_1702)">
<path d="M57 63.5L57 92.5" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter2_i_266_1702)">
<path d="M65 51L65 105" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter3_i_266_1702)">
<path d="M73 60L73 96" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter4_i_266_1702)">
<path d="M81 69.5L81 86.5" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
<g filter="url(#filter5_i_266_1702)">
<path d="M89 72L89 84" stroke="#006BFE" stroke-width="5" stroke-linecap="round"/>
</g>
</g>
<defs>
<filter id="filter0_i_266_1702" x="20" y="26" width="105" height="83.5" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="2"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.0793038 0 0 0 0 0.101942 0 0 0 0 0.350962 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter1_i_266_1702" x="54.5" y="61" width="5" height="38" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter2_i_266_1702" x="62.5" y="48.5" width="5" height="63" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter3_i_266_1702" x="70.5" y="57.5" width="5" height="45" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter4_i_266_1702" x="78.5" y="67" width="5" height="26" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
<filter id="filter5_i_266_1702" x="86.5" y="69.5" width="5" height="21" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_266_1702"/>
</filter>
</defs>
</svg>
</file>

<file path="asset/SingleLOGO.svg">
<svg width="71" height="78" viewBox="0 0 71 78" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_276_1691)">
<path d="M44.1776 0C53.7629 5.12777e-07 61.5332 7.83959 61.5332 17.5102V24.6735C61.5332 29.3261 59.7338 33.5541 56.7998 36.69V16.7143C56.7998 9.68107 51.1487 3.97959 44.1776 3.97959H29.9776C23.0065 3.97959 17.3554 9.68107 17.3554 16.7143V36.69C14.4214 33.5541 12.6221 29.3261 12.6221 24.6735V17.5102C12.6221 7.83959 20.3924 0 29.9776 0H44.1776Z" fill="#D8E3FF"/>
<path d="M45.7556 9.55103C48.8054 9.55103 51.2778 11.9614 51.2778 14.9346V64.2101C51.2778 67.1833 50.3832 68.0018 47.3333 68.0018H7.1C5.52222 68.0018 4.73333 69.2449 4.73333 70.3359V71.0782C4.73333 72.3525 5.79293 73.3854 7.1 73.3854H54.4333C55.7404 73.3854 56.8 72.3525 56.8 71.0782V32.4448C61.1389 32.4448 57.7757 32.4448 61.5333 32.4448C61.5333 35.1367 61.5333 36.6934 61.5333 37.8285V72.6164C61.5333 75.5896 59.0609 78 56.0111 78H5.52222C2.47239 78 0 75.5896 0 72.6164V14.9346C0 14.8486 0.00206159 14.7629 0.00616319 14.6778C0.00842817 14.6308 0.0126843 14.584 0.0161784 14.5374C0.0193354 14.4952 0.0220453 14.4531 0.0261936 14.4111C0.0298514 14.3742 0.0348701 14.3375 0.0392904 14.3007C0.045611 14.2482 0.0514608 14.1958 0.0593207 14.1438C0.0645997 14.1089 0.0710752 14.0742 0.0770399 14.0394C0.0854619 13.9903 0.094232 13.9415 0.104004 13.8929C0.110419 13.861 0.117044 13.8292 0.124035 13.7976C0.137259 13.7376 0.151153 13.6779 0.166407 13.6188C0.172042 13.5969 0.178216 13.5752 0.184125 13.5535C0.198556 13.5003 0.213537 13.4474 0.229579 13.395C0.241424 13.3562 0.253847 13.3177 0.266558 13.2793C0.278977 13.2418 0.291843 13.2045 0.305078 13.1674C0.320776 13.1233 0.336784 13.0795 0.353613 13.036C0.366078 13.0037 0.379056 12.9717 0.392133 12.9398C0.409872 12.8965 0.42798 12.8534 0.446831 12.8106C0.466744 12.7655 0.487331 12.7207 0.508463 12.6762C0.522757 12.6461 0.536762 12.6159 0.551606 12.5861C0.572048 12.545 0.594077 12.5048 0.615549 12.4644C0.6908 12.3227 0.772325 12.1846 0.859763 12.0505C0.882719 12.0154 0.905345 11.98 0.929098 11.9454C0.960409 11.8998 0.992714 11.8549 1.0254 11.8102C1.03986 11.7905 1.05382 11.7704 1.06854 11.7509C1.10152 11.7071 1.13595 11.6644 1.17024 11.6217C1.18895 11.5984 1.20738 11.5749 1.22648 11.5519C1.25663 11.5155 1.28782 11.48 1.31893 11.4444C1.34292 11.4171 1.3668 11.3895 1.39134 11.3626C1.42912 11.3211 1.46785 11.2805 1.5069 11.2402C1.51925 11.2274 1.53141 11.2145 1.54388 11.2018C1.58519 11.1601 1.62678 11.1184 1.66945 11.0779C1.69275 11.0558 1.71664 11.0343 1.74033 11.0126C1.77741 10.9786 1.81478 10.9449 1.85281 10.912C1.87335 10.8941 1.8944 10.8769 1.91521 10.8594C2.02216 10.7693 2.13184 10.6822 2.24571 10.6003C2.25712 10.5921 2.26891 10.5844 2.28038 10.5762C2.65532 10.3107 3.06595 10.0905 3.50378 9.9228C3.51762 9.91747 3.53148 9.91221 3.54538 9.90704C3.60649 9.8842 3.66814 9.86247 3.73028 9.84169C3.74079 9.83819 3.75131 9.83461 3.76186 9.83119L3.87973 9.7929C3.91283 9.7828 3.94651 9.77452 3.97988 9.76505C3.99448 9.76099 4.00915 9.75709 4.0238 9.75303C4.08782 9.73552 4.15222 9.7188 4.21716 9.70352C4.23713 9.69875 4.25721 9.69445 4.27726 9.68999C4.34209 9.67543 4.40725 9.66174 4.47294 9.6494C4.48831 9.64654 4.50374 9.64391 4.51917 9.64112C4.84453 9.58294 5.17959 9.55103 5.52222 9.55103H45.7556Z" fill="#006BFE"/>
<path d="M32.7578 49.7449C32.7578 52.6022 30.4621 54.9184 27.63 54.9184H22.8591C20.0271 54.9184 17.7314 52.6022 17.7314 49.7449C17.7314 47.5482 21.0973 45.7653 25.2446 45.7653C29.3918 45.7653 32.7578 47.5482 32.7578 49.7449ZM25.2446 29.449C27.835 29.449 30.3193 30.5391 32.1511 32.4795C33.9827 34.42 35.0118 37.0518 35.0118 39.7959C35.0118 41.0676 34.797 42.2873 34.4026 43.4133C34.0641 44.3801 32.8636 44.5591 32.1209 43.8592C31.6074 43.3753 31.4882 42.6123 31.6927 41.934C31.8967 41.2572 32.0065 40.5362 32.0065 39.7959C32.0065 35.8164 29.0012 32.6327 25.2446 32.6327C21.488 32.6327 18.4827 35.8164 18.4827 39.7959C18.4827 40.5362 18.5924 41.2572 18.7964 41.934C19.0009 42.6123 18.8817 43.3753 18.3682 43.8592C17.6256 44.5591 16.425 44.3801 16.0865 43.4133C15.6922 42.2873 15.4773 41.0676 15.4773 39.7959C15.4773 37.0518 16.5064 34.42 18.3381 32.4795C20.1698 30.5391 22.6542 29.449 25.2446 29.449ZM25.2446 23.0817C29.4291 23.0817 33.4422 24.8426 36.4011 27.9772C39.3601 31.1117 41.0224 35.3631 41.0224 39.7959C41.0224 42.7596 40.2909 45.5428 39.0163 47.9549C38.568 48.803 37.4496 48.9238 36.7573 48.2636C36.2157 47.7473 36.1245 46.9191 36.4673 46.2516C37.4541 44.3304 38.0171 42.1294 38.0171 39.7959C38.0171 36.2074 36.6714 32.7658 34.2761 30.2284C31.8808 27.6909 28.6321 26.2653 25.2446 26.2653C21.8571 26.2653 18.6084 27.6909 16.2131 30.2284C13.8178 32.7658 12.4721 36.2074 12.4721 39.7959C12.4721 42.1294 13.035 44.3304 14.0218 46.2516C14.3647 46.9191 14.2734 47.7473 13.7318 48.2636C13.0395 48.9238 11.9211 48.803 11.4729 47.9549C10.1983 45.5428 9.4668 42.7596 9.4668 39.7959C9.4668 35.3631 11.1291 31.1117 14.088 27.9772C17.0469 24.8426 21.0601 23.0817 25.2446 23.0817ZM25.2446 35.8164C26.2409 35.8164 27.1964 36.2356 27.9009 36.982C28.6054 37.7282 29.0012 38.7405 29.0012 39.7959C29.0012 40.8514 28.6054 41.8637 27.9009 42.6099C27.1964 43.3563 26.2409 43.7755 25.2446 43.7755C24.2483 43.7755 23.2928 43.3563 22.5882 42.6099C21.8838 41.8637 21.488 40.8514 21.488 39.7959C21.488 38.7405 21.8838 37.7282 22.5882 36.982C23.2928 36.2356 24.2483 35.8164 25.2446 35.8164Z" fill="#D8E3FF"/>
<path d="M56.7998 27.4592C56.7998 25.4811 58.3892 23.8776 60.3498 23.8776C66.2316 23.8776 70.9998 28.6883 70.9998 34.6225V44.1735C70.9998 50.1077 66.2316 54.9184 60.3498 54.9184C58.3892 54.9184 56.7998 53.3148 56.7998 51.3368V27.4592Z" fill="#D8E3FF"/>
<path d="M56.7998 27.4592C56.7998 25.4811 58.3892 23.8776 60.3498 23.8776C66.2316 23.8776 70.9998 28.6883 70.9998 34.6225V44.1735C70.9998 50.1077 66.2316 54.9184 60.3498 54.9184C58.3892 54.9184 56.7998 53.3148 56.7998 51.3368V27.4592Z" fill="#D8E3FF"/>
</g>
<defs>
<clipPath id="clip0_276_1691">
<rect width="71" height="78" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="functions/index.js">
// const functions = require("firebase-functions");
const { onRequest } = require("firebase-functions/v2/https");
const admin = require("firebase-admin");
// const cors = require("cors")({ origin: true });
const axios = require("axios");
const Parser = require("rss-parser"); // 引入 rss-parser
const AZURE_API_KEY = import.meta.env.VITE_AZURE_API_KEY;
const DEEPL_API_KEY = import.meta.env.VITE_DEEPL_API_KEY;

admin.initializeApp();

//proxy
exports.proxy = onRequest({ cors: true }, async function (req, res) {
  // cors(req, res, async () => {
  //   setCorsHeaders(res);
  //   if (req.method === "OPTIONS") {
  //     return res.status(204).send("");
  //   }

  const targetUrl = req.query.url;

  if (!targetUrl) {
    return res.status(400).send("Missing 'url' query parameter");
  }
  try {
    const axiosOptions = {
      method: req.method,
      url: targetUrl,
      headers: {
        "Content-Type": req.headers["content-type"],
        "Ocp-Apim-Subscription-Key": AZURE_API_KEY,
      },
      data: req.rawBody,
    };
    const response = await axios(axiosOptions);
    res.status(response.status).send(response.data);
  } catch (error) {
    console.error("Proxy error:", {
      message: error.message,
      code: error.code,
      config: error.config,
      responseData: error.response?.data,
      responseStatus: error.response?.status,
    });
    res.status(500).send("Failed to fetch target URL");
  }
  // });
  console.log("Incoming headers:", req.headers);
});

// Translation API Cloud Function
exports.translate = onRequest({ cors: true }, async function (req, res) {
  // Enable CORS
  // cors(req, res, async () => {
  //   // Only allow POST requests
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  try {
    // 直接使用硬编码的API密钥，与前端使用的相同
    console.log("Using API key:", DEEPL_API_KEY.substr(0, 10) + "...");

    const response = await axios.post(
      "https://api-free.deepl.com/v2/translate",
      req.body,
      {
        headers: {
          Authorization: `DeepL-Auth-Key ${DEEPL_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    //     // Return translation results
    res.json(response.data);
  } catch (error) {
    console.error("Translation error:", {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
    });

    res.status(error.response?.status || 500).json({
      error: "Translation failed",
      details: error.response?.data || error.message,
    });
  }
  // });
});

// RSS Parser
exports.parseRssFeed = onRequest({ cors: true }, async function (req, res) {
  // setCorsHeaders(res);
  // if (req.method === "OPTIONS") {
  //   return res.status(204).send("");
  // }

  const rssUrl = req.query.url;

  if (!rssUrl) {
    return res.status(400).send("Missing 'url' query parameter");
  }

  // axios
  //   .get(rssUrl, { responseType: "text" })
  //   .then(async (response) => {
  try {
    // // 使用 axios 获取 RSS 数据
    const response = await axios.get(rssUrl, {
      responseType: "text", // 确保返回的是文本数据（如 RSS XML）
    });

    // 使用 rss-parser 解析 RSS 数据
    const parser = new Parser({
      customFields: {
        feed: ["image", "language", "copyright"],
        item: [
          "itunes:duration",
          "itunes:image",
          "itunes:episode",
          "itunes:season",
          "itunes:summary",
          "enclosure",
        ],
      },
    });
    const feed = await parser.parseString(response.data);

    // 返回解析后的数据
    // res.status(200).json(
    const result = {
      feed: {
        title: feed.title,
        description: feed.description,
        image: feed.image?.url,
        link: feed.link,
      },
      items: feed.items.map(function (item) {
        return {
          title: item.title,
          description: item.contentSnippet || item.description,
          pubDate: item.pubDate || item.isoDate,
          // duration: item.itunes?.duration,//时长无法显示
          duration: formatDuration(item.itunes?.duration),
          episode: item.itunes?.episode,
          season: item.itunes?.season,
          image: item.itunes?.image || feed.image?.url,
          guid: item.guid,
          link: item.link,
          enclosure: item.enclosure,
        };
      }),
    };
    res.status(200).json(result);
  } catch (error) {
    console.error("Error parsing RSS feed:", error.message);
    // setCorsHeaders(res);
    res.status(500).send("Failed to parse RSS feed");
  }
});

function formatDuration(duration) {
  if (!duration) return "Unknown";

  if (typeof duration === "number") {
    const m = Math.floor(duration / 60);
    const s = duration % 60;
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  if (typeof duration === "string") {
    if (/^\d+$/.test(duration)) {
      // 纯数字秒数
      return formatDuration(Number(duration));
    }
    if (
      /^\d{1,2}:\d{2}$/.test(duration) ||
      /^\d{1,2}:\d{2}:\d{2}$/.test(duration)
    ) {
      // 已是标准格式
      return duration;
    }
  }

  return "Unknown";
}

// downloadAudio
exports.downloadAudio = onRequest({ cors: true }, async function (req, res) {
  const audioUrl = req.query.url;
  if (!audioUrl) return res.status(400).send("Missing audio URL");

  try {
    const response = await axios.get(audioUrl, {
      responseType: "arraybuffer",
    });

    res.set("Content-Type", response.headers["content-type"]);
    res.status(200).send(response.data);
  } catch (err) {
    console.error("Download audio failed:", err.message);
    res.status(500).send("Failed to download audio");
  }
});
</file>

<file path="functions/package.json">
{
  "dependencies": {
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "firebase-admin": "^13.3.0",
    "firebase-functions": "^6.3.2",
    "rss-parser": "^3.13.0"
  }
}
</file>

<file path="listenary-backend/config/apiConfig.js">
// Backend proxy
export const PROXY_URL = "https://proxy-7ajldlnu2q-uc.a.run.app/proxy"; // Proxy
export const PARSE_RSS_FEED_URL =
  "https://parserssfeed-7ajldlnu2q-uc.a.run.app"; // RSS Parser
// Azure Speech to Text API
export const AZURE_API_URL = "https://northeurope.api.cognitive.microsoft.com";
export const AZURE_API_KEY = import.meta.env.VITE_AZURE_API_KEY; // Azure Speech to Text API Key from .env
export const AUDIO_DOWNLOAD_URL =
  "https://downloadaudio-7ajldlnu2q-uc.a.run.app"; // Audio Download
</file>

<file path="listenary-backend/config/firebaseConfig.js">
// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
export const firebaseConfig = {
  apiKey: "AIzaSyAa84m37fzjOZzhNDMHzNlPmOGplU78kTI",
  authDomain: "dh2642-29c50.firebaseapp.com",
  projectId: "dh2642-29c50",
  storageBucket: "dh2642-29c50.firebasestorage.app",
  messagingSenderId: "389069809164",
  appId: "1:389069809164:web:eb9eb7fba4aab24fb33029",
  measurementId: "G-JMBEQCV08T",
};
</file>

<file path="listenary-backend/modules/transcription-example/controller.ts">
//  •	接收请求，解析参数。
// •	调用 Service。
// •	返回 HTTP 响应。
// •	不写业务逻辑。

// 示例代码：
// const express = require("express");
// const router = express.Router();
// const userService = require("./user.service");

// router.get("/:id", async (req, res) => {
//   try {
//     const user = await userService.getUserById(req.params.id);
//     res.json(user);
//   } catch (err) {
//     res.status(400).json({ error: err.message });
//   }
// });

// module.exports = router;
</file>

<file path="listenary-backend/modules/transcription-example/model.ts">
//•	定义数据结构。

// 示例代码
// const mongoose = require('mongoose');

// const userSchema = new mongoose.Schema({
//   name: String,
//   email: { type: String, required: true, unique: true },
//   password: String,
// });

// module.exports = mongoose.model('User', userSchema);
</file>

<file path="listenary-backend/modules/transcription-example/repository.ts">
// 数据库操作封装（CRUD）。

// user.repository.js
// const User = require('./user.model');

// exports.findById = (id) => User.findById(id);
// exports.create = (data) => User.create(data);
</file>

<file path="listenary-backend/modules/transcription-example/service.ts">
// 	•	编写业务逻辑。
//	•	调用 Repository（数据库）或其他 Service。

// 示例代码：
// const userRepository = require('./user.repository');

// exports.getUserById = async (id) => {
//   const user = await userRepository.findById(id);
//   if (!user) throw new Error('User not found');
//   return user;
// };
</file>

<file path="listenary-backend/.gitignore">
node_modules/
*.local
</file>

<file path="listenary-backend/package.json">
{
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "22"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^12.7.0",
    "firebase-functions": "^6.3.2"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}
</file>

<file path="listenary-backend/server.ts">
//add dependencies
const express = require("express");
const cors = require("cors");

//import routes/controllers
</file>

<file path="server/index.js">
// server/index.js

const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');

// 在所有代码的最顶部，加载 .env 文件中的环境变量
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3000;

// --- 中间件 ---
app.use(cors());
app.use(express.json());

// --- 从环境变量中安全地获取数据库连接字符串 ---
const MONGO_URI = process.env.MONGO_URI;
if (!MONGO_URI) {
  throw new Error('错误：.env 文件中未定义 MONGO_URI');
}

// --- 异步连接到数据库 ---
const connectDB = async () => {
  try {
    await mongoose.connect(MONGO_URI);
    console.log('成功连接到 MongoDB!');
    
    // 只有当数据库连接成功后，才启动 Express 服务器
    app.listen(port, () => {
      console.log(`后端服务器正在 http://localhost:${port} 上运行`);
    });

  } catch (error) {
    console.error('数据库连接失败:', error.message);
    process.exit(1); // 如果连接失败，则退出进程
  }
};

// --- API 路由 ---
app.get('/api', (req, res) => {
  res.json({ message: '你好！后端已连接到数据库！' });
});

// --- 调用函数来连接数据库并启动服务器 ---
connectDB();
</file>

<file path="server/package.json">
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.1.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}
</file>

<file path="src/api/dictionaryAPI.jsx">
export const DictionaryAPI = {
    async getWord(word) {
        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
        const data = await response.json();
        return data;
    }
}
</file>

<file path="src/api/TranslationAPI.jsx">
import { useState } from "react";

export default function TranslationAPI({ textToTranslate, targetLang, onTranslationComplete }){
    const apiKey = '8dd9ce8e-032f-42ed-af73-c2de472febbf:fx';
    const API_URL = '/deepl/v2/translate';
    // Check if in production environment
    const isProduction = window.location.hostname !== 'localhost';

    const translate = async function() {
        if (!textToTranslate || !targetLang) return '';
        
        try {
            // In production, requests are rewritten by Firebase to cloud functions, so no API key needed
            const headers = isProduction 
                ? { 'Content-Type': 'application/json' }
                : {
                    'Authorization': `DeepL-Auth-Key ${apiKey}`,
                    'Content-Type': 'application/json'
                };
                
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    text: [textToTranslate], //* text must be an array of strings
                    target_lang: targetLang
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Translation request failed:', {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                    isProduction: isProduction
                });
                throw new Error(`Translation failed with status: ${response.status}`);
            }

            const data = await response.json();
            const translatedText = data.translations[0].text; //*according to the example response, the translation is in the translations[0].text
            
            if (onTranslationComplete) {
                onTranslationComplete(translatedText);
            }
            
            return translatedText;
        } catch (error) {
            console.error('Translation error:', error);
            // Add retry logic
            if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                console.log('Retrying translation...');
                // Wait 1 second before retry
                await new Promise(function(resolve) {
                    setTimeout(resolve, 1000);
                });
                return translate();
            }
            return '';
        }
    };

    return { translate };
}
</file>

<file path="src/components/AudioPlayerComponent.jsx">
import {
  Box,
  Slider,
  IconButton,
  Typography,
  Stack,
  Popper,
  ClickAwayListener,
  Button,
} from "@mui/material";
import {
  PlayArrow,
  Pause,
  VolumeUp,
  VolumeOff,
  Forward10,
  Replay10,
} from "@mui/icons-material";
import {
  forwardRef,
  useRef,
  useState,
  useEffect,
  useImperativeHandle,
} from "react";
import { useTheme } from "@mui/material/styles";
import WaveSurfer from "wavesurfer.js";

const formatTime = (time) => {
  const minutes = Math.floor(time / 60)
    .toString()
    .padStart(2, "0");
  const seconds = Math.floor(time % 60)
    .toString()
    .padStart(2, "0");
  return `${minutes}:${seconds}`;
};

const AudioPlayerComponent = forwardRef(({ audioSrc, onTimeUpdate }, ref) => {
  const theme = useTheme();
  const audioRef = useRef(null);
  const waveformRef = useRef(null);
  const wavesurfer = useRef(null);

  const [playing, setPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [volumeAnchorEl, setVolumeAnchorEl] = useState(null);
  const [speedAnchorEl, setSpeedAnchorEl] = useState(null);
  const [waveformLoading, setWaveformLoading] = useState(true);
  const [showSpeedMenu, setShowSpeedMenu] = useState(false);

  // 初始化 wavesurfer
  useEffect(() => {
    if (!waveformRef.current) return;
    if (wavesurfer.current) {
      wavesurfer.current.destroy();
    }
    setWaveformLoading(true);
    wavesurfer.current = WaveSurfer.create({
      container: waveformRef.current,
      waveColor: "#b3c7f9",
      progressColor: "#1976d2",
      height: 50,
      responsive: true,
      barWidth: 2,
      barRadius: 2,
      cursorColor: "#1976d2",
    });
    wavesurfer.current.load(audioSrc);

    wavesurfer.current.on("ready", () => {
      setDuration(wavesurfer.current.getDuration());
      setWaveformLoading(false);
    });

    wavesurfer.current.on("audioprocess", () => {
      const t = wavesurfer.current.getCurrentTime();
      setCurrentTime(t);
      if (onTimeUpdate) {
        onTimeUpdate(t * 1000);
      }
    });

    wavesurfer.current.on("seek", () => {
      const t = wavesurfer.current.getCurrentTime();
      setCurrentTime(t);
      if (onTimeUpdate) {
        onTimeUpdate(t * 1000);
      }
    });

    wavesurfer.current.on("play", () => setPlaying(true));
    wavesurfer.current.on("pause", () => setPlaying(false));

    // 保持音量和倍速同步
    wavesurfer.current.setVolume(volume);
    wavesurfer.current.setPlaybackRate(playbackRate);

    return () => {
      wavesurfer.current && wavesurfer.current.destroy();
    };
    // eslint-disable-next-line
  }, [audioSrc]);

  // 音量和倍速变化时同步到 wavesurfer
  useEffect(() => {
    if (wavesurfer.current) {
      wavesurfer.current.setVolume(volume);
    }
  }, [volume]);
  useEffect(() => {
    if (wavesurfer.current) {
      wavesurfer.current.setPlaybackRate(playbackRate);
    }
  }, [playbackRate]);

  useImperativeHandle(ref, () => ({
    pause: () => {
      wavesurfer.current && wavesurfer.current.pause();
      setPlaying(false);
    },
  }));

  // 控制
  const togglePlay = () => {
    if (wavesurfer.current) {
      wavesurfer.current.playPause();
    }
  };

  const handleSliderChange = (_, value) => {
    if (wavesurfer.current) {
      wavesurfer.current.seekTo(value / duration);
      setCurrentTime(value);
    }
  };

  const handleVolumeChange = (_, value) => {
    setVolume(value);
  };

  const handleSpeedChange = (rate) => {
    setPlaybackRate(rate);
    setSpeedAnchorEl(null);
  };

  const handleForward = () => {
    if (wavesurfer.current) {
      const t = Math.min(currentTime + 10, duration);
      wavesurfer.current.seekTo(t / duration);
      setCurrentTime(t);
    }
  };
  const handleReplay = () => {
    if (wavesurfer.current) {
      const t = Math.max(currentTime - 10, 0);
      wavesurfer.current.seekTo(t / duration);
      setCurrentTime(t);
    }
  };

  return (
    <Box
      sx={{
        borderRadius: 10,
        px: 6,
        py: 2,
        bgcolor: "#fff",
        boxShadow: 1,
        width: "100%",
        gap: 2,
      }}
    >
      {/* 时间 + 波形图 */}
      <Box sx={{ display: "flex", alignItems: "center", width: "100%", mb: 1 }}>
        <Typography variant="caption" sx={{ minWidth: 40 }}>
          {formatTime(0)}
        </Typography>
        <Box sx={{ flexGrow: 1, position: "relative" }}>
          <div ref={waveformRef} style={{ width: "100%" }} />
          {waveformLoading && (
            <Box
              sx={{
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                bgcolor: "rgba(255,255,255,0.7)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 1,
              }}
            >
              <Typography variant="caption" color="text.secondary">
                Loading...
              </Typography>
            </Box>
          )}
        </Box>
        <Typography variant="caption" sx={{ minWidth: 40, textAlign: "right" }}>
          {formatTime(duration)}
        </Typography>
      </Box>

      {/* 控制条 */}
      <Stack
        direction="row"
        spacing={2}
        alignItems="center"
        justifyContent="center"
      >
        <IconButton onClick={handleReplay} sx={{ color: "#485D92" }}>
          <Replay10 />
        </IconButton>

        <IconButton onClick={togglePlay} color="primary">
          {playing ? <Pause /> : <PlayArrow />}
        </IconButton>

        <IconButton onClick={handleForward} sx={{ color: "#485D92" }}>
          <Forward10 />
        </IconButton>

        <Box
          sx={{
            position: "relative",
            display: "flex",
            alignItems: "center",
            gap: 1,
          }}
        >
          <Button
            variant="text"
            size="small"
            onClick={function() {
              setShowSpeedMenu(!showSpeedMenu);
            }}
            sx={{
              minWidth: "auto",
              px: 1,
              color: "text.secondary",
              "&:hover": {
                backgroundColor: "action.hover",
              },
            }}
          >
            {playbackRate}x
          </Button>
          {showSpeedMenu && (
            <Box
              sx={{
                position: "absolute",
                bottom: "100%",
                left: "50%",
                transform: "translateX(-50%)",
                backgroundColor: "background.paper",
                borderRadius: 1,
                boxShadow: 3,
                p: 1,
                zIndex: 1400,
                mb: 1,
                minWidth: 100,
              }}
            >
              {[0.5, 0.75, 1, 1.25, 1.5, 2].map(function(speed) {
                return (
                  <Button
                    key={speed}
                    fullWidth
                    size="small"
                    onClick={function() {
                      handleSpeedChange(speed);
                      setShowSpeedMenu(false);
                    }}
                    sx={{
                      justifyContent: "flex-start",
                      color: speed === playbackRate ? "primary.main" : "text.primary",
                      "&:hover": {
                        backgroundColor: "action.hover",
                      },
                    }}
                  >
                    {speed}x
                  </Button>
                );
              })}
            </Box>
          )}
        </Box>

        <Box
          sx={{
            position: "relative",
            display: "flex",
            alignItems: "center",
          }}
        >
          <IconButton
            onClick={function(e) {
              setVolumeAnchorEl(volumeAnchorEl ? null : e.currentTarget);
            }}
            sx={{ color: "#485D92" }}
          >
            {volume > 0 ? <VolumeUp /> : <VolumeOff />}
          </IconButton>
          {Boolean(volumeAnchorEl) && (
            <Box
              sx={{
                position: "absolute",
                bottom: "100%",
                left: "50%",
                transform: "translateX(-50%)",
                backgroundColor: "background.paper",
                borderRadius: 1,
                boxShadow: 3,
                p: 2,
                zIndex: 1400,
                mb: 1,
                minWidth: 120,
              }}
            >
              <Slider
                value={volume}
                onChange={handleVolumeChange}
                min={0}
                max={1}
                step={0.01}
                orientation="vertical"
                sx={{
                  height: 100,
                  '& .MuiSlider-thumb': {
                    width: 12,
                    height: 12,
                  },
                  '& .MuiSlider-track': {
                    width: 4,
                  },
                  '& .MuiSlider-rail': {
                    width: 4,
                  }
                }}
              />
            </Box>
          )}
        </Box>
      </Stack>
    </Box>
  );
});

export default AudioPlayerComponent;
</file>

<file path="src/components/CollapseBox.jsx">
import React from "react";
import "../styles/CollapseBox.css";

class CollapseBox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { open: false };
    this.toggleBox = this.toggleBox.bind(this);
  }

  toggleBox() {
    this.setState(function (prevState) {
      return { open: !prevState.open };
    });
  }

  render() {
    return (
      <div className="collapse-box">
        <button className="collapse-toggle-btn" onClick={this.toggleBox}>
          <span className={"collapse-arrow" + (this.state.open ? " open" : "")}></span>
          {this.props.title}
        </button>
        <div
          className="collapse-content"
          style={{ display: this.state.open ? "block" : "none" }}
        >
          {this.props.children}
        </div>
      </div>
    );
  }
}

export { CollapseBox };
</file>

<file path="src/components/TopNav.jsx">
import '../styles/TopNav.css';
import { observer } from "mobx-react-lite";
import loginModel from "../loginModel";
import { useNavigate } from "react-router-dom";
import { useState } from "react";

// TopNav component - View layer in MVP architecture
export const TopNav = observer(function TopNav({ hideLogo }) {
  const user = loginModel.user;
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();

  function handleLoginMenuClick(e) {
    e.preventDefault();
    navigate("/login");
  }

  return (
    <nav className="top-nav">
      <div className="nav-container">
        {!hideLogo ? (
          <a href="/#/" className="brand-link">Listenary</a>
        ) : (
          <span className="slogan-text">Learn English with Podcasts</span>
        )}

        <div className="nav-links">
          <a href="/#/wordlist" className="nav-link">Wordlist</a>
          {user ? (
            <span className="nav-link" onClick={handleLoginMenuClick} style={{ cursor: 'pointer' }}>
              {user.displayName || user.email}
            </span>
          ) : (
            <span className="nav-link" onClick={handleLoginMenuClick} style={{ cursor: 'pointer' }}>
              {isLoading ? 'Logging in...' : 'Login'}
            </span>
          )}
        </div>
      </div>
    </nav>
  );
});
</file>

<file path="src/hooks/useAudioPlayback.js">
import { useEffect, useState } from "react";

/**
 * 监听 audio 元素播放时间变化，返回当前播放时间（以毫秒为单位）
 * @param {React.RefObject<HTMLAudioElement>} audioRef - 指向 AudioPlayer 组件的 ref
 * @returns {number} currentTime 当前播放时间（ms）
 */
export function useAudioPlayback(audioRef) {
  const [currentTime, setCurrentTime] = useState(0);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const updateTime = () => setCurrentTime(audio.currentTime * 1000);

    audio.addEventListener("timeupdate", updateTime);

    return () => {
      audio.removeEventListener("timeupdate", updateTime);
    };
  }, [audioRef]);

  return currentTime;
}

  // // Monitor audio playback time for text highlighting
  // useEffect(function setupAudioTimeListener() {
  //   const audio = audioRef.current;
  //   if (!audio) return;

  //   function updateTime() {
  //     setCurrentTime(audio.currentTime * 1000);
  //   }
  //   audio.addEventListener("timeupdate", updateTime);
  //   return function cleanup() {
  //     audio.removeEventListener("timeupdate", updateTime);
  //   };
  // }, []);

  // useEffect(() => {}, [currentTime]);
  // function handleTimeUpdate(time) {
  //   setCurrentTime(time);
  // }
</file>

<file path="src/hooks/useRSSInput.js">
import { useNavigate } from "react-router-dom";

export function useRSSInput() {
  const navigate = useNavigate();

  const handleRSSSubmit = (rssUrl) => {
    // Later we'll add RSS parsing logic here
    // For now, just navigate to podcast channel page
    navigate('/podcast-channel');
  };

  return handleRSSSubmit;
}
</file>

<file path="src/hooks/useTranscriptionManager">
import { useCallback } from "react";
import { AUDIO_DOWNLOAD_URL } from "../../listenary-backend/config/apiConfig.js";
import { speechToText } from "../speechToText.js"; // API HERE
import { resolvePromise } from "../resolvePromise";
// import { PROXY_URL, AUDIO_DOWNLOAD_URL } from "../apiConfig"; // Proxy URL
export function useTranscriptionManager({
  model,
  episode,
  setIsTranscribing,
  setIsLoading,
}) {
  //     //download audio file from url
  //   function downloadAndStoreAudioFile(audioUrl) {
  //     const proxyUrl = `${AUDIO_DOWNLOAD_URL}?url=${encodeURIComponent(
  //       audioUrl
  //     )}`;
  //     console.log("Proxy URL:", proxyUrl);
  //     return fetch(proxyUrl)
  //       .then(function (response) {
  //         if (response.status !== 200) throw new Error(response.status);
  //         return response.blob();
  //       })
  //       .then(function (blob) {
  //         console.log("Blob type:", blob.type);
  //         console.log("Blob size:", blob.size);

  //         const audioFile = new File([blob], "audio.wav", {
  //           type: blob.type || "audio/wav",
  //         });

  //         console.log("Downloaded audio file:", audioFile);
  //         return audioFile;
  //       });
  //   }
  const downloadAndStoreAudioFile = useCallback(async (audioUrl) => {
    const proxyUrl = `${AUDIO_DOWNLOAD_URL}?url=${encodeURIComponent(
      audioUrl
    )}`;
    const response = await fetch(proxyUrl);
    if (response.status !== 200)
      throw new Error(`HTTP error: ${response.status}`);

    const blob = await response.blob();
    return new File([blob], "audio.wav", {
      type: blob.type || "audio/wav",
    });
  }, []);

  // //request transcription api
  // function transcribeAudio(audioFile) {
  //   console.log("Transcribing audio file:", audioFile);
  //   console.log("audio file type:", audioFile.type);
  //   if (!audioFile) {
  //     console.error("No audio file provided to transcribeAudio");
  //     alert("Invalid audio file, please try another!");
  //     setIsTranscribing(false);
  //     return;
  //   }

  //   const params = {
  //     audio: audioFile,
  //     definition: JSON.stringify({ locales: ["en-US"] }),
  //   };

  //   console.log("Calling speechToText with params:", params);

  //   props.model.transcripResultsPromiseState.error = null;
  //   props.model.transcripResultsPromiseState.data = null;

  //   const prms = speechToText(params)
  //     .then((data) => {
  //       // add guid
  //       return { ...data, guid: props.model.currentEpisode.guid };
  //     })
  //     .catch((error) => {
  //       setIsTranscribing(false);
  //       setIsLoading(false);
  //       throw error;
  //     });

  //   resolvePromise(prms, props.model.transcripResultsPromiseState);
  // }

  const transcribeAudio = useCallback(
    (audioFile) => {
      const params = {
        audio: audioFile,
        definition: JSON.stringify({ locales: ["en-US"] }),
      };

      model.transcripResultsPromiseState.error = null;
      model.transcripResultsPromiseState.data = null;

      const prms = speechToText(params)
        .then((data) => ({ ...data, guid: model.currentEpisode.guid }))
        .catch((error) => {
          setIsTranscribing(false);
          setIsLoading(false);
          throw error;
        });

      resolvePromise(prms, model.transcripResultsPromiseState);
    },
    [model, setIsTranscribing, setIsLoading]
  );

  // function handleTranscribe() {
  // console.log("Transcribe button clicked");
  // if (!episode || !props.model.audioUrl) {
  //   alert("Invalid episode data");
  //   return;
  // }

  // if (isTranscribing) {
  //   console.log("Transcription is already in progress.");
  //   return;
  // }

  // setIsTranscribing(true);
  // setIsLoading(true);

  // if (
  //   props.model.transcripResults &&
  //   props.model.transcripResults.length > 0
  // ) {
  //   console.log("Transcription already exists, skipping API request.");
  //   alert("This episode has already been transcribed.");
  //   setIsTranscribing(false);
  //   return;
  // }

  //   // 提取转录文本
  //   function getSentence(phrase) {
  //     return phrase.text || "No text available";
  //   }

  //     const audio = new Audio(props.model.audioUrl);
  //     audio.addEventListener("loadedmetadata", function () {
  //       const duration = audio.duration;
  //       if (duration > 1800) {
  //         alert(
  //           "please select a shorter espisode less than 30 minutes to save usage for us :)"
  //         );
  //         setIsLoading(false);
  //         setIsTranscribing(false);
  //         return;
  //       }

  //       props.model.setAudioDuration(duration);

  //       if (props.model.audioFile) {
  //         console.log("Using existing audio file:", props.model.audioFile);
  //         transcribeAudio(props.model.audioFile);
  //       } else {
  //         console.log("Downloading audio file...");
  //         console.log("Audio URL:", props.model.audioUrl);

  //         downloadAndStoreAudioFile(props.model.audioUrl)
  //           .then(function (audioFile) {
  //             props.model.setAudioFile(audioFile);
  //             transcribeAudio(audioFile);
  //           })
  //           .catch(function (error) {
  //             console.error("Failed to download audio file:", error.message);
  //             alert("Audio download failed, please try again later!");
  //             setIsTranscribing(false);
  //           })
  //           .finally(function () {
  //             setIsLoading(false);
  //           });
  //       }
  //     });
  //   },
  //   // Remove the old saveTranscripDataACB function since we're handling it in the useEffect
  //   function saveTranscripDataACB(data) {
  //     if (data) {
  //       const newResults = data.phrases;
  //       const updatedResults = props.model.transcripResults.concat(newResults);
  //       props.model.setResults(updatedResults);
  //     } else {
  //       console.log("API returned empty data");
  //     }
  //     setIsTranscribing(false);
  //   }
  const handleTranscribe = useCallback(() => {
    if (!episode || !model.audioUrl) {
      alert("Invalid episode data");
      return;
    }

    if (setIsTranscribing) setIsTranscribing(true);
    if (setIsLoading) setIsLoading(true);

    if (model.transcripResults?.length > 0) {
      alert("This episode has already been transcribed.");
      if (setIsTranscribing) setIsTranscribing(false);
      return;
    }

    const audio = new Audio(model.audioUrl);
    audio.addEventListener("loadedmetadata", () => {
      const duration = audio.duration;
      if (duration > 1800) {
        alert("Please select a shorter episode (less than 30 minutes).");
        if (setIsLoading) setIsLoading(false);
        if (setIsTranscribing) setIsTranscribing(false);
        return;
      }

      model.setAudioDuration(duration);

      if (model.audioFile) {
        transcribeAudio(model.audioFile);
      } else {
        downloadAndStoreAudioFile(model.audioUrl)
          .then((audioFile) => {
            model.setAudioFile(audioFile);
            transcribeAudio(audioFile);
          })
          .catch((error) => {
            console.error("Failed to download audio file:", error.message);
            alert("Audio download failed, please try again later!");
            if (setIsTranscribing) setIsTranscribing(false);
          })
          .finally(() => {
            if (setIsLoading) setIsLoading(false);
          });
      }
    });
  }, [
    episode,
    model,
    transcribeAudio,
    downloadAndStoreAudioFile,
    setIsTranscribing,
    setIsLoading,
  ]);

  return { handleTranscribe };
}
</file>

<file path="src/hooks/useTranscriptionSync">
import { useEffect } from "react";
import { saveTranscriptionData } from "../firestoreModel";
import loginModel from "../loginModel";

/**
 * Hook to handle transcription state change and sync with Firestore
 */
export function useTranscriptionSync({
  model,
  episode,
  data,
  error,
  setIsTranscribing,
  setIsLoading,
}) {
  useEffect(() => {
    if (data && data.guid === episode?.guid) {
      console.log("Setting transcription results:", data.phrases);
      model.setResults(data.phrases);
      setIsTranscribing(false);
      setIsLoading(false);

      const user = loginModel.getUser();
      if (user && episode?.guid) {
        saveTranscriptionData(
          user.uid,
          episode.guid,
          episode.title,
          data.phrases
        ).then(() => {
          const event = new CustomEvent("transcriptionComplete", {
            detail: { guid: episode.guid },
          });
          window.dispatchEvent(event);
        });
      }
    }
  }, [data, error, episode]);
}

//   //address race condition
//   const guid = episode?.guid;
//   const data = props.model.transcripResultsPromiseState.data;
//   const error = props.model.transcripResultsPromiseState.error;

//   useEffect(() => {
//     console.log("useEffect triggered", { data, guid, episode });
//     if (data && data.guid === guid) {
//       console.log("Setting results:", data.phrases);
//       props.model.setResults(data.phrases);
//       setIsTranscribing(false);
//       setIsLoading(false);

//       // Save transcription data and dispatch event
//       const user = loginModel.getUser();
//       if (user && episode?.guid) {
//         saveTranscriptionData(
//           user.uid,
//           episode.guid,
//           episode.title,
//           data.phrases
//         ).then(function () {
//           console.log("Transcription saved, dispatching event...");
//           const event = new CustomEvent("transcriptionComplete", {
//             detail: { guid: episode.guid },
//           });
//           window.dispatchEvent(event);
//         });
//       }
//     }
//   }, [data, error, guid]);
</file>

<file path="src/hooks/useTranslationHandler">
import TranslationAPI from "../api/TranslationAPI.jsx";
export function useTranslationHandler({
  transcriptionData,
  setTargetLanguage,
  setTranslations,
  setTranslatingItems
}) {
  const handleLanguageChange = async (event) => {
    const newTargetLang = event.target.value;
    setTargetLanguage(newTargetLang);
    if (!newTargetLang) {
      setTranslations({});
      setTranslatingItems(new Set());
      return;
    }

    let wordCount = 0;
    const MAX_WORDS = 100;
    const newTranslations = {};
    const translatingSet = new Set();

    for (const item of transcriptionData) {
      const words = item.text.split(/\s+/).length;
      if (wordCount + words > MAX_WORDS) {
        newTranslations[item.text] =
          "Due to API usage limits, only part of the text is translated for reference.";
        continue;
      }
      wordCount += words;
      translatingSet.add(item.text);
    }

    setTranslations(newTranslations);
    setTranslatingItems(translatingSet);

    for (const item of transcriptionData) {
      if (!translatingSet.has(item.text)) continue;
      const translator = TranslationAPI({
        textToTranslate: item.text,
        targetLang: newTargetLang,
        onTranslationComplete: (translatedText) => {
          setTranslations((prev) => ({ ...prev, [item.text]: translatedText }));
          setTranslatingItems((prev) => {
            const newSet = new Set(prev);
            newSet.delete(item.text);
            return newSet;
          });
        },
      });
      translator.translate();
    }
  };

  return { handleLanguageChange };
}
</file>

<file path="src/hooks/useWordLookup">
import { useState } from "react";
import { saveWordToUserWordlist } from "../firestoreModel";
import loginModel from "../loginModel";

export function useWordLookup(model) {
  const [wordCard, setWordCard] = useState({
    word: "",
    phonetics: { uk: null, us: null },
    definition: null,
    examples: null,
    relatedTerms: null,
  });

  function handleWordSelect(word) {
    const cleanWord = word.replace(/[^\w'-]/g, "");
    console.log("Looking up word:", cleanWord);

    model
      .lookupWord(cleanWord)
      .then((result) => {
        console.log("Dictionary API result:", result);
        if (result && result[0]) {
          setWordCard(result[0]);
        } else {
        setWordCard({
        word: cleanWord,
        phonetics: { uk: null, us: null },
        definition: null,
        examples: null,
        relatedTerms: null,
        });
        }
      })
      .catch((error) => {
        console.error("Error looking up word:", error);
        setWordCard({
        word: cleanWord,
        phonetics: { uk: null, us: null },
        definition: null,
        examples: null,
        relatedTerms: null,
        });
      });
  }

  async function handleAddToWordlist(wordData) {
    const user = loginModel.getUser();
    if (!user) {
      return { success: false, message: "Please Login First", type: "warning" };
    }

    try {
      await saveWordToUserWordlist(user.uid, wordData);
      return {
        success: true,
        message: "Added to the default wordlist",
        type: "success",
      };
    } catch (error) {
      console.error("Error saving word to wordlist:", error);
      return { success: false, message: "Failed to save word", type: "error" };
    }
  }

  return { wordCard, handleWordSelect, handleAddToWordlist };
}

//   const [wordCard, setWordCard] = useState({
//     word: "",
//     phonetics: { uk: null, us: null },
//     definition: null,
//     examples: null,
//     relatedTerms: null,
//   });

//   /**
//    * Handle word selection and lookup
//    * @param {string} word - The selected word to look up
//    */
//   function handleWordSelect(word) {
//     const cleanWord = word.replace(/[^\w'-]/g, "");
//     console.log("Looking up word:", cleanWord);
//     props.model
//       .lookupWord(cleanWord)

//       .then((result) => {
//         console.log("Dictionary API result:", result);
//         if (result && result[0]) {
//           setWordCard(result[0]);
//         } else {
//           console.log("No dictionary data found for word:", cleanWord);
//           setWordCard({
//             word: cleanWord,
//             phonetic: null,
//             phonetics: [],
//             meanings: [],
//           });
//         }
//       })
//       .catch((error) => {
//         console.error("Error looking up word:", error);
//         setWordCard({
//           word: cleanWord,
//           phonetic: null,
//           phonetics: [],
//           meanings: [],
//         });
//       });
//   }

//   /**
//    * Handle adding word to user's wordlist
//    * First checks if user is logged in, then saves the word to Firestore
//    * @param {Object} wordData - The word data to save
//    * @returns {Object} - Result with success status and message
//    */
//   async function handleAddToWordlist(wordData) {
//     // Check if user is logged in
//     const user = loginModel.getUser();

//     if (!user) {
//       // User is not logged in, show message
//       return { success: false, message: "Please Login First", type: "warning" };
//     }

//     try {
//       // Save word to Firestore
//       await saveWordToUserWordlist(user.uid, wordData);
//       return {
//         success: true,
//         message: "Added to the default wordlist",
//         type: "success",
//       };
//     } catch (error) {
//       console.error("Error saving word to wordlist:", error);
//       return { success: false, message: "Failed to save word", type: "error" };
//     }
//   }
</file>

<file path="src/presenter/HomePagePresenter.jsx">
import { HomePageView } from "../views/HomePageView";
import { observer } from "mobx-react-lite";
import { useNavigate } from "react-router-dom";
import { useState } from "react";

// HomePagePresenter: Handles all business logic for the home page
// - Manages navigation
// - Handles RSS URL input and parsing
// - Manages saved podcasts display
const HomePagePresenter = observer(function HomePagePresenter(props) {
  const navigate = useNavigate();
  const savedPodcasts = props.model.savedPodcasts;
  const [errorMsg, setErrorMsg] = useState("");
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  // Verify RSS link format
  function isValidRssUrl(url) {
    try {
      new URL(url);
    } catch (e) {
      return false;
    }

    // verification of RSS links
    const rssPatterns = [
      /\.xml$/i, // .xml end
      /\/feed/i, // include /feed
      /\/rss/i, // include /rss
      /\/podcast/i, // include /podcast
      /\/itunes/i, // include /itunes
      /\/feedburner/i, // include /feedburner
    ];

    return rssPatterns.some(function (pattern) {
      return pattern.test(url);
    });
  }

  // Handle RSS URL input changes
  function inputHandlerACB(event) {
    props.model.setRssUrl(event.target.value);
    setErrorMsg("");
  }

  // Handle RSS feed parsing
  function handleParseClick() {
    const url = props.model.rssUrl;

    if (!url || url.trim() === "") {
      setErrorMsg("Please enter the rss link!");
      return;
    }

    if (!isValidRssUrl(url)) {
      setErrorMsg("Please enter a valid RSS link!");
      return;
    }

    setErrorMsg("");
    props.model
      .loadRssData()
      .then(function () {
        navigate("/podcast-channel");
      })
      .catch(function (error) {
        navigate("/");
        setErrorMsg("Parsing failed, please check the RSS link!");
        setSnackbarOpen(true);
        console.error("Error in handleParseClick:", error);
      });
  }

  // Handle saved podcast click - navigate to podcast channel
  function handleSavedPodcastClick(podcast) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.rssUrl } });
  }

  console.log("HomePagePresenter render", props.model.savedPodcasts.length);

  return (
    <HomePageView
      url={props.model.rssUrl}
      onInputChange={inputHandlerACB}
      onParseClick={handleParseClick}
      savedPodcasts={savedPodcasts}
      onSavedPodcastClick={handleSavedPodcastClick}
      errorMsg={errorMsg}
      snackbarOpen={snackbarOpen}
      onSnackbarClose={() => setSnackbarOpen(false)}
    />
  );
});

export { HomePagePresenter };
</file>

<file path="src/presenter/loginPagePresenter.jsx">
import { useState, useEffect } from "react"
import loginModel from "../loginModel.js"
import LoginView from "../views/loginPageView.jsx"
import { loadUserData } from "../firestoreModel"
import { model } from "../Model"
import { useNavigate } from "react-router-dom";

function LoginPresenter() {
  // Local state to manage view updates
  const [modelState, setModelState] = useState({
    isLoading: loginModel.getIsLoading(),
    user: loginModel.getUser()
  })

  const navigate = useNavigate();

  // Set up auth state listener without automatically triggering login popup
  useEffect(function effectCallback() {
    // Only responsible for synchronizing user status
    function onAuthChange() {
      updateViewState();
    }
    const unsubscribe = loginModel.setupAuthStateListener(onAuthChange);
    return function cleanup() {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Helper function to update view state from model
  function updateViewState() {
    setModelState({
      isLoading: loginModel.getIsLoading(),
      user: loginModel.getUser()
    });
  }

  function handleGoogleLogin(e) {
    e.preventDefault();
    setModelState(function(prev) { return {...prev, isLoading: true}; });

    loginModel.googleLogin()
      .then(function(result) {
        const user = result.user;
        // Load user data from Firestore
        return loadUserData(user.uid).then(function(userData) {
          if (userData && userData.savedPodcasts) {
            model.savedPodcasts = userData.savedPodcasts;
          }
          // Navigate after successful login
          navigate("/");
        });
      })
      .catch(function(error) {
        alert("Login failed: " + error.message);
      })
      .finally(function() {
        setModelState(function(prev) {
          return {...prev, isLoading: false};
        });
      });
  }

  function handleLogout() {
    loginModel.logout()
      .then(function() {
        console.log("Logout successful");
        updateViewState();
        // Stay on the current page after logout
      })
      .catch(function(error) {
        console.error("Logout failed:", error.message);
        alert("Logout failed: " + error.message);
      });
  }

  // Pass data and event handlers to the view
  return (
    <LoginView
      isLoading={modelState.isLoading}
      user={modelState.user}
      onGoogleLogin={handleGoogleLogin}
      onLogout={handleLogout}
    />
  )
}
export default LoginPresenter
</file>

<file path="src/presenter/PodcastChannelPresenter.jsx">
import { observer } from "mobx-react-lite";
import { PodcastChannelView } from "../views/PodcastChannelView";
import { useState, useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { getDocs, collection } from "firebase/firestore";
import { db } from "../firestoreModel";
import loginModel from "../loginModel"; // Import login model to check user status

// Presenter component for podcast channel page
// Handles all business logic and state management
const PodcastChannelPresenter = observer(function PodcastChannelPresenter(props) {
  const navigate = useNavigate();
  const location = useLocation();
  const rssUrl = location.state?.rssUrl || props.model.rssUrl;
  const model = props.model;
  const channelInfo = props.model.podcastChannelInfo;
  const episodes = props.model.podcastEpisodes;

  // State management
  const [user, setUser] = useState(null);
  const [isSaved, setIsSaved] = useState(false);
  const [transcribedGuids, setTranscribedGuids] = useState([]);
  const [savedEpisodes, setSavedEpisodes] = useState([]);
  const [filterType, setFilterType] = useState("all");
  const [visibleCount, setVisibleCount] = useState(10);
  const [snackbarState, setSnackbarState] = useState({
    open: false,
    message: "",
    severity: "success"
  });

  // Initialize user state
  useEffect(function initUser() {
    const currentUser = loginModel.getUser();
    setUser(currentUser);
  }, []);

  // Add auth state listener
  useEffect(function setupAuthListener() {
    const unsubscribe = loginModel.setupAuthStateListener(function(user) {
      setUser(user);
    });
    return function cleanup() {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Load RSS data and transcription data
  useEffect(function loadData() {
    if (rssUrl) {
      model.setRssUrl(rssUrl);
      model.loadRssData();
    }

    loadTranscriptionData();
  }, [rssUrl, user]);

  // Function to load transcription data
  function loadTranscriptionData() {
    if (user) {
      const transRef = collection(db, "users", user.uid, "transcriptions");
      getDocs(transRef).then(function handleTranscriptions(snapshot) {
        const guids = snapshot.docs.map(function getDocId(doc) {
          return doc.id.trim();
        });
        setTranscribedGuids(guids);
      }).catch(function(error) {
        console.error("Error loading transcription data:", error);
      });
    }
  }

  // Check if podcast is saved
  useEffect(function checkSavedStatus() {
    if (channelInfo) {
      function isPodcastSaved(podcast) {
        return podcast.title === channelInfo.title;
      }
      const saved = model.savedPodcasts.find(isPodcastSaved);
      setIsSaved(!!saved);
    }
  }, [model.savedPodcasts, channelInfo]);

  // Mark transcribed episodes
  useEffect(function markTranscribedEpisodes() {
    if (episodes.length > 0) {
      function markIfTranscribed(episode) {
        const hasTranscript = transcribedGuids.includes(episode.guid.trim());
        return { ...episode, isTranscribed: hasTranscript };
      }
      const markedEpisodes = episodes.map(markIfTranscribed);
      setSavedEpisodes(markedEpisodes);
    }
  }, [episodes, transcribedGuids]);

  // Handle scroll loading
  useEffect(function handleScrollLoading() {
    function handleScroll() {
      if (
        window.innerHeight + window.scrollY >= document.body.offsetHeight - 100 &&
        visibleCount < episodes.length
      ) {
        setVisibleCount(function incrementCount(prev) {
          return prev + 5;
        });
      }
    }
    window.addEventListener("scroll", handleScroll);
    return function cleanup() {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [visibleCount, episodes.length]);

  // Show snackbar notification
  function showSnackbar(message, severity = "success") {
    setSnackbarState({
      open: true,
      message: message,
      severity: severity
    });
  }

  // Handle snackbar close
  function handleSnackbarClose(event, reason) {
    if (reason === "clickaway") return;
    setSnackbarState(function updateState(prev) {
      return { ...prev, open: false };
    });
  }

  // Handle episode play
  function handlePlay(episode) {
    if (!episode) {
      alert("Episode not found");
      return;
    }

    if (episode.enclosure.url) {
      model.setAudioUrl(episode.enclosure.url);
    } else {
      console.error("Episode does not have a valid audio URL:", episode);
    }

    model.setCurrentEpisode(episode);
    model.setAudioUrl(episode.enclosure.url);
    navigate("/podcast-play");
  }

  // Add event listener for transcription completion
  useEffect(function setupTranscriptionListener() {
    function handleTranscriptionComplete(event) {
      loadTranscriptionData();
    }
    
    window.addEventListener("transcriptionComplete", handleTranscriptionComplete);
    
    return function cleanup() {
      window.removeEventListener("transcriptionComplete", handleTranscriptionComplete);
    };
  }, [user]);

  // Handle podcast save
  function savePodcastHandler(podcast) {
    const currentUser = loginModel.getUser();
    if (!currentUser) {
      return { success: false, message: "Please Login First", type: "warning" };
    }
    if (!podcast.rssUrl) {
      podcast.rssUrl = rssUrl;
    }
    model.addToSaved(podcast);
    setIsSaved(true);
    return { success: true, message: "Podcast saved successfully", type: "success" };
  }

  // Handle podcast remove
  function removePodcastHandler(podcast) {
    const currentUser = loginModel.getUser();
    if (!currentUser) {
      return { success: false, message: "Please Login First", type: "warning" };
    }
    model.removeFromSaved(podcast);
    setIsSaved(false);
    return { success: true, message: "Podcast removed from saved list", type: "success" };
  }

  // Handle filter change
  function handleFilterChange(event, newFilter) {
    if (newFilter !== null) {
      setFilterType(newFilter);
    }
  }

  // Filter episodes based on type
  function filterEpisodes(ep) {
    if (filterType === "transcribed") return ep.isTranscribed;
    if (filterType === "untranscribed") return !ep.isTranscribed;
    return true;
  }

  const filteredEpisodes = savedEpisodes.filter(filterEpisodes);

  if (!channelInfo || episodes.length === 0) {
    return <div style={{ padding: "2rem" }}>Loading podcast...</div>;
  }

  return (
    <PodcastChannelView
      channelInfo={channelInfo}
      episodes={filteredEpisodes.slice(0, visibleCount)}
      isSaved={isSaved}
      onSavePodcast={savePodcastHandler}
      onRemovePodcast={removePodcastHandler}
      onPlay={handlePlay}
      filterType={filterType}
      onFilterChange={handleFilterChange}
      snackbarState={snackbarState}
      onSnackbarClose={handleSnackbarClose}
    />
  );
});

export default PodcastChannelPresenter;
</file>

<file path="src/presenter/PodcastPlayPresenter.jsx">
import { observer } from "mobx-react-lite";
import { PodcastPlayView } from "../views/PodcastView/PodcastPlayView";
import AudioPlayer from "../components/AudioPlayerComponent";
import { useAudioPlayback } from "../hooks/useAudioPlayback";
import { useTranscriptionSync } from "../hooks/useTranscriptionSync";
import { useWordLookup } from "../hooks/useWordLookup";
import { useLocation, useNavigate } from "react-router-dom";
import { useEffect, useState, useRef } from "react";
import {getTranscriptionData} from "../firestoreModel"; // Import the Firestore function
import loginModel from "../loginModel"; // Import login model to check user status
import { useTranscriptionManager } from "../hooks/useTranscriptionManager";

const PodcastPlayPresenter = observer(function PodcastPlayPresenter(props) {
  const location = useLocation();
  const navigate = useNavigate();
  const episode =
    props.model.currentEpisode ||
    JSON.parse(localStorage.getItem("currentEpisode"));
  const [isLoading, setIsLoading] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const audioRef = useRef(null);
  const currentTime = useAudioPlayback(audioRef);
  const { handleTranscribe } = useTranscriptionManager({
    model: props.model,
    episode,
    setIsTranscribing,
    setIsLoading,
  });
  const processedTranscriptionData = processTranscriptionData();
  const data = props.model.transcripResultsPromiseState.data;
  const error = props.model.transcripResultsPromiseState.error;
  const { wordCard, handleWordSelect, handleAddToWordlist } = useWordLookup(props.model);

  // set current episode from localStorage
  useEffect(() => {
    if (!props.model.currentEpisode) {
      const localEpisode = JSON.parse(localStorage.getItem("currentEpisode"));
      if (localEpisode) {
        props.model.setCurrentEpisode(localEpisode);
      }
    }
  }, []);


  // Save current episode to localStorage
  useEffect(
    function saveCurrentEpisode() {
      if (episode) {
        localStorage.setItem("currentEpisode", JSON.stringify(episode));
      }
    },
    [episode]
  );

  useEffect(() => {
    // clear transcription results
    props.model.transcripResultsPromiseState.error = null;
    props.model.transcripResultsPromiseState.data = null;

    if (!episode) return;
    console.log("Episode changed to:", episode.title);
    props.model.setResults([]);
    props.model.setAudioDuration(0);
    props.model.setAudioFile(null);

    async function fetchTranscriptFromFirestore() {
      const user = loginModel.getUser();
      if (user && episode?.guid) {
        const phrases = await getTranscriptionData(user.uid, episode.guid);
        if (phrases.length > 0) {
          props.model.setResults(phrases);
        }
      }
    }
    fetchTranscriptFromFirestore();
  }, [props.model.currentEpisode]);

  function getTimestamp(phrase) {
    const totalMilliseconds = phrase.offsetMilliseconds || 0;
    const totalSeconds = Math.floor(totalMilliseconds / 1000);
    const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
    const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(
      2,
      "0"
    );
    const seconds = String(totalSeconds % 60).padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  }

  // Extract the transcribed text
  function getSentence(phrase) {
    return phrase.text || "No text available";
  }

  function processTranscriptionData() {
    const results = [];
    for (let i = 0; i < props.model.transcripResults.length; i++) {
      const phrase = props.model.transcripResults[i];
      results.push({
        timestamp: getTimestamp(phrase),
        text: getSentence(phrase),
        offsetMilliseconds: phrase.offsetMilliseconds || 0,
      });
    }
    return results;
  }

  useTranscriptionSync({
    model: props.model,
    episode,
    data,
    error,
    setIsTranscribing,
    setIsLoading,
  });

  //back to channel page
  function handleBack() {
    navigate("/podcast-channel");
  }
  if (!episode) {
    return (
      <div style={{ padding: "2rem" }}>
        {" "}
        <p>No episode data</p> <button onClick={handleBack}>← Back</button>{" "}
      </div>
    );
  }

  function getPodcastData() {
    return {
      title: episode.title,
      description: episode.description,
      audioUrl: props.model.audioUrl,
      duration: episode.duration,
      source: props.model?.podcastChannelInfo?.title || "Podcast",
      coverImage: episode.image,
    };
  }

  return (
    <PodcastPlayView
      podcastData={getPodcastData()}
      audioDuration={props.model.audioDuration}
      transcriptionData={processedTranscriptionData}
      wordCard={wordCard}
      AudioPlayerComponent={AudioPlayer}
      audioSrc={props.model.audioUrl}
      audioRef={audioRef}
      onWordSelect={handleWordSelect}
      onTranscribe={handleTranscribe}
      isLoading={isLoading}
      isTranscribing={isTranscribing}
      currentTime={currentTime}
      // onTimeUpdate={handleTimeUpdate}
      onAddToWordlist={handleAddToWordlist} // Pass wordlist handler to View
    />
  );
});

export default PodcastPlayPresenter;
</file>

<file path="src/presenter/rssPresenter.jsx">
import { useEffect } from 'react';
import { RssModel } from '../rssModel';

//测试组件
export const RssPresenter = () => {
  useEffect(() => {
    function extractRssData() {
      const rssModel = new RssModel();
      
      rssModel.loadFeed('https://feeds.bbci.co.uk/news/rss.xml', (error, data) => {
        if (error) {
          console.error('RSS data extraction failed:', error);
          return;
        }
        
        // URLs仅在后台使用
        console.log('Backend URLs:', data.urls);
        
        // 文章信息将用于前端展示
        console.log('Frontend Articles Data:', data.articles);
        
        // 这里可以存储articles数据，供后续页面展示使用
      });
    }
    
    extractRssData();
  }, []);

  // 暂时返回空组件，稍后添加展示逻辑
  return <div>RSS Data Extractor</div>;
}
</file>

<file path="src/presenter/SavedPodcastsPresenter.jsx">
import { observer } from "mobx-react-lite";
import { SavedPodcastsView } from "../views/SavedPodcastsView";

var SavedPodcastsPresenter = observer(function SavedPodcastsPresenter(props) {
  return (
    <SavedPodcastsView savedPodcasts={props.model.savedPodcasts} />
  );
});

export default SavedPodcastsPresenter;
</file>

<file path="src/presenter/WordlistPresenter.jsx">
import { observer } from "mobx-react-lite";
import { WordlistView } from "../views/WordlistView";
import { useState, useEffect } from "react";
import { getUserWordlist } from "../firestoreModel";
import loginModel from "../loginModel";

/**
 * Wordlist Presenter Component - Part of the Presenter layer in MVP
 * Manages the retrieval and display of user's saved words
 */
export const WordlistPresenter = observer(function WordlistPresenter(props) {
  // State for handling wordlist display and selection
  const [userWords, setUserWords] = useState([]);
  const [selectedWordIndex, setSelectedWordIndex] = useState(-1);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Fetch user words when component mounts or login state changes
  useEffect(() => {
    async function fetchUserWords() {
      setIsLoading(true);
      setError(null);
      
      const user = loginModel.getUser();
      if (user) {
        try {
          const words = await getUserWordlist(user.uid);
          setUserWords(words);
          // Select first word if available
          if (words.length > 0) {
            setSelectedWordIndex(0);
          }
        } catch (err) {
          console.error("Error fetching wordlist:", err);
          setError("Failed to load wordlist. Please try again later.");
        }
      } else {
        setUserWords([]);
        setSelectedWordIndex(-1);
      }
      
      setIsLoading(false);
    }
    
    fetchUserWords();
  }, [loginModel.user]); // Re-fetch when user login state changes
  
  /**
   * Handle selection of a word from the wordlist
   * @param {number} index - The index of the selected word
   */
  const handleWordSelect = (index) => {
    setSelectedWordIndex(index);
  };
  
  // Get the currently selected word for display in the details panel
  const selectedWord = selectedWordIndex >= 0 && selectedWordIndex < userWords.length 
    ? userWords[selectedWordIndex] 
    : null;

  return (
    <WordlistView 
      words={userWords}
      selectedWordIndex={selectedWordIndex}
      selectedWord={selectedWord}
      onWordSelect={handleWordSelect}
      isLoading={isLoading}
      error={error}
      isLoggedIn={!!loginModel.user}
    />
  );
});
</file>

<file path="src/styles/AudioPlayer.css">
.audio-player-container {
  width: 100%;
  padding: 10px;
}

.audio-player {
  width: 100%;
}
</file>

<file path="src/styles/CollapseBox.css">
.collapse-box {
  background: transparent;
  border: none;
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.collapse-toggle-btn {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background: transparent;
  border: none;
  color: #4285f4;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 500;
  cursor: pointer;
  padding: 0 0 0 0;
  outline: none;
  transition: color 0.2s;
}
.collapse-toggle-btn:hover {
  color: #2a65c4;
}
.collapse-arrow {
  display: inline-block;
  margin-right: 8px;
  border: solid #4285f4;
  border-width: 0 2px 2px 0;
  padding: 4px;
  transform: rotate(45deg);
  transition: transform 0.2s;
}
.collapse-arrow.open {
  transform: rotate(225deg);
}
.collapse-content {
  background: transparent;
  border: none;
  padding: 16px 0 0 0;
  width: 100%;
}
.rss-guide-list {
  text-align: left;
  font-size: 16px;
  line-height: 1.7;
  margin: 0 0 0 18px;
  padding: 0;
}
.rss-guide-list li {
  margin-bottom: 8px;
}
.rss-guide-bottom {
  font-size: 14px;
  color: #666;
  margin-top: 10px;
  text-align: left;
}
@media (max-width: 700px) {
  .collapse-box {
    max-width: 98vw;
  }
}
</file>

<file path="src/styles/HomePage.css">
.homepage-container {
  display: flex;
  flex-direction: column;
  padding: 20px 20px 40px;
  min-height: 100vh;
  align-items: center;
  background-color: #fff;
  position: relative;
}

.center-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 100px 20px 40px;
  justify-content: center; 
}

.logo-container {
  margin: 0 auto;
}

.top-nav {
  position: absolute;
  top: 10px;
  right: 20px;
  z-index: 100;
  background: none;
  border: none;
}

.nav-links {
  display: flex;
  gap: 20px;
}

.nav-link {
  color: #333;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.nav-link:hover {
  background-color: #f5f5f5;
  color: #4285f4;
}

.logo-container {
  margin-top: 40px;
  margin-bottom: 40px;
}

.logo {
  height: 50px;
}

.search-container {
  width: 100%;
  max-width: 600px;
  margin-bottom: 30px;
  position: relative;
  display: flex;
  gap: 8px;
  margin: 0 auto;
  max-width: 600px;
}

/* .search-input {
  flex: 1;
  padding: 15px 20px;
  border-radius: 25px;
  border: 1px solid #e0e0e0;
  background-color: #f5f5f5;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  outline: none;
  transition: all 0.3s ease;
} */

.search-input:focus {
  border-color: #4285f4;
  box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.1);
}

.search-button {
  background: #4285f4;
  border: none;
  border-radius: 25px;
  padding: 0 28px;
  height: 48px;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 2px rgba(60, 60, 60, 0.03);
  transition: all 0.2s;
  margin-left: 8px;
}

.search-button:hover {
  background: #2a65c4;
  color: #fff;
  transform: scale(1.05);
  border: none;
}

/* .search-icon {
  font-size: 20px;
  color: #D8E3FF;
} */

.help-link {
  color: #4285f4;
  text-decoration: none;
  margin-bottom: 40px;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

.example-rss-link {
  color: #006BFE;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

.help-link-wrapper {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  padding: 0;
  height: auto;
  margin-top: 20px;
}

.collapse-box {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.collapse-toggle-btn {
  justify-content: center;
}

.collapse-content {
  width: 100%;
}

.rss-guide-list,
.rss-guide-bottom {
  text-align: left;
}

.saved-section {
  width: 100%;
  max-width: 1200px;
}

.saved-header {
  display: flex;
  align-items: center;
  margin-bottom: 24px;
  margin-top: 24px;
}

.saved-title {
  font-family: 'Candal', sans-serif;
  font-weight: 400;
  font-size: 20px;
  line-height: 32px;
  letter-spacing: 0px;
  text-align: center;
  color: #106EFF;
}

.saved-icon {
  color: #106EFF;
  margin-right: 10px;
  vertical-align: middle;
}

.saved-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  width: 100%;
}

.saved-item {
  background-color: #f5f5f5;
  border-radius: 40px;
  padding: 20px;
  min-height: 150px;
  display: flex;
  flex-direction: column;
  justify-content: left;
  align-items: center;
  position: relative;
}

.saved-item-image-wrapper {
  width: 100%;
  aspect-ratio: 8/5;
  background: #eee;
  border-radius: 20px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 15px;
  margin-top: 2px;
}

.saved-item-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  border-radius: 20px;
}

.saved-item-title {
  font-size: 20px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  margin: 0.5rem 0;
}

.saved-item-description {
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #6b7280;
  margin-bottom: 0.5rem;
  max-height: 2.8em;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
}

.no-saved-container {
  grid-column: 1 / -1;
  background-color: #f7f7f749;
  border-radius: 12px;
  border: 2px solid #e0e0e0;
  padding: 24px;
  width: 100%;
  box-sizing: border-box;
  text-align: center;
}

.no-saved-podcasts {
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #4472ce;
  text-align: center;
  width: 100%;
  margin-bottom: 20px;
}

.no-saved-image {
  width: 160px;
  height: 150px;
  margin-bottom: 0px;
}

.item-number {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.1);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: #666;
}

.show-more {
  color: #4285f4;
  text-decoration: none;
  font-size: 16px;
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  margin-top: 20px;
  text-align: right;
  display: block;
  padding: 0px 30px;
}

.show-more:hover {
  text-decoration: underline;
}

.top-nav .logo {
  display: none;
}
</file>

<file path="src/styles/LoginPage.css">
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Inter", sans-serif;
  background-color: #ffffff;
  min-height: 100vh;
}

.login-wrapper {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #ffffff;
}

.login-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 400px;
  padding: 20px;
  text-align: center;
}

.login-title {
  color: #0066ff;
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 48px;
}

.google-sign-in-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: #ffffff;
  border: 1px solid #dadce0;
  border-radius: 4px;
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.25px;
  height: 40px;
  transition: all 0.2s ease;
  padding: 0;
  margin: 0 auto;
  color: #3c4043;
  min-width: 220px;
}

.google-sign-in-button:hover {
  background-color: #f8f9fa;
  border-color: #dadce0;
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.google-sign-in-button:active {
  background-color: #f1f3f4;
  border-color: #dadce0;
  box-shadow: 0 1px 1px rgba(0,0,0,0.1);
}

.google-sign-in-content {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 0 24px;
  height: 100%;
}

.google-icon {
  width: 18px;
  height: 18px;
}

.terms-text {
  margin-top: 24px;
  font-size: 12px;
  color: #5f6368;
}

.terms-link {
  color: #0066ff;
  text-decoration: none;
}

.terms-link:hover {
  text-decoration: underline;
}

.welcome-container {
  background-color: #f1f3f4;
  padding: 24px;
  border-radius: 8px;
  width: 100%;
  border: 1px solid #dadce0;
}

.welcome-text {
  color: #202124;
  margin-bottom: 16px;
  font-size: 14px;
}

.min-h-screen {
  min-height: 100vh;
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.bg-white {
  background-color: #ffffff;
}

.p-4 {
  padding: 1rem;
}

.mb-8 {
  margin-bottom: 2rem;
}

.w-10 {
  width: 2.5rem;
}

.h-10 {
  height: 2.5rem;
}

.bg-\[\#0066ff\] {
  background-color: #0066ff;
}

.mr-3 {
  margin-right: 0.75rem;
}

.text-4xl {
  font-size: 2.25rem;
}

.font-bold {
  font-weight: 700;
}

.text-\[\#0066ff\] {
  color: #0066ff;
}

.w-full {
  width: 100%;
}

.max-w-md {
  max-width: 28rem;
}

.space-y-4 > * + * {
  margin-top: 1rem;
}

.space-y-1 > * + * {
  margin-top: 0.25rem;
}

.text-sm {
  font-size: 0.875rem;
}

.text-gray-600 {
  color: #4b5563;
}

.relative {
  position: relative;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}

.border {
  border: 1px solid #e5e7eb;
}

.rounded-md {
  border-radius: 0.375rem;
}

.focus\:outline-none:focus {
  outline: none;
}

.focus\:ring-2:focus {
  box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);
}

.focus\:ring-\[\#0066ff\]:focus {
  box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);
}

.absolute {
  position: absolute;
}

.right-3 {
  right: 0.75rem;
}

.top-1\/2 {
  top: 50%;
}

.-translate-y-1\/2 {
  transform: translateY(-50%);
}

.text-gray-400 {
  color: #9ca3af;
}

.hover\:text-gray-600:hover {
  color: #4b5563;
}

.bg-\[\#4d8bff\] {
  background-color: #4d8bff;
}

.text-white {
  color: #ffffff;
}

.rounded-full {
  border-radius: 9999px;
}

.font-medium {
  font-weight: 500;
}

.hover\:bg-\[\#0055dd\]:hover {
  background-color: #0055dd;
}

.transition-colors {
  transition-property: color, background-color, border-color;
  transition-duration: 150ms;
}

.hover\:bg-\[\#3d7bff\]:hover {
  background-color: #3d7bff;
}

.space-y-3 > * + * {
  margin-top: 0.75rem;
}

.pt-2 {
  padding-top: 0.5rem;
}

.bg-\[\#f1f3f4\] {
  background-color: #f1f3f4;
}

.text-black {
  color: #000000;
}

.hover\:bg-\[\#e8eaed\]:hover {
  background-color: #e8eaed;
}

.mr-2 {
  margin-right: 0.5rem;
}

.login-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background-color: #fff;
}

.login-logo {
  margin-bottom: 4rem;
}

.login-logo-text {
  font-size: 2.5rem;
  font-weight: 700;
  color: #0066ff;
}

.login-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  background-color: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  transition: all 0.2s ease;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.login-button:hover {
  background-color: #f9fafb;
}

.login-button-icon {
  width: 1.25rem;
  height: 1.25rem;
  margin-right: 0.75rem;
}

.login-button-text {
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}

.login-terms {
  margin-top: 2rem;
  font-size: 0.75rem;
  color: #9ca3af;
  text-align: center;
  max-width: 16rem;
}

.login-terms-link {
  color: #6b7280;
  text-decoration: none;
}

.login-terms-link:hover {
  text-decoration: underline;
}
</file>

<file path="src/styles/PodcastChannel.css">
.podcast-channel-page {
  min-height: 100vh;
  background-color: #fff;
}

/* Navigation Bar */
/* .top-nav {
  width: 100%;
  padding: 1rem 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #fff;
  position: sticky;
  top: 0;
  z-index: 100;
} */

/* .nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1400px;
  margin: 0 auto;
}

.brand-link {
  font-size: 1.5rem;
  font-weight: 700;
  color: #111827;
  text-decoration: none;
  transition: color 0.2s ease;
} */

/* .brand-link:hover {
  color: #1a56db;
} */

/* .nav-links {
  display: flex;
  justify-content: flex-end;
  gap: 1.5rem;
}

.nav-link {
  color: #4b5563;
  text-decoration: none;
  font-size: 0.875rem;
  font-weight: 500;
  transition: color 0.2s ease;
} */

/* .nav-link:hover {
  color: #1a56db;
} */

/* Main Content */
.podcast-channel {
  max-width: 1200px;
  margin: 2rem auto 0;
  padding: 0 2rem;
}

/* Channel Header */
.channel-header {
  display: flex;
  gap: 2rem;
  margin-bottom: 3rem;
}

.channel-cover {
  flex-shrink: 0;
  width: 200px;
  height: 200px;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.channel-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.channel-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
}

.channel-title {
  font-size: 2rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
}

.channel-description {
  font-size: 1rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
}

.save-button {
  align-self: flex-start;
  padding: 0.5rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  color: #fff;
  background-color: #0066ff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.save-button:hover {
  background-color: #0052cc;
}

.save-button.saved {
  background-color: #059669;
}

.save-button.saved:hover {
  background-color: #047857;
}

/* Episodes Section */
.episodes-container {
  margin-top: 2rem;
}

.episodes-title {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 2rem;
}

.episodes-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.episode-card {
  display: flex;
  gap: 1.5rem;
  padding: 1.5rem;
  background-color: #fff;
  transition: background-color 0.2s ease;
}

.episode-card:hover {
  background-color: #f9fafb;
}

.episode-cover {
  flex-shrink: 0;
  width: 100px;
  height: 100px;
  border-radius: 20px;
  overflow: hidden;
}

.episode-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.episode-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.episode-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1rem;
}

.episode-title {
  font-size: 1rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.play-button {
  flex-shrink: 0;
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  color: #fff;
  background-color: #0066ff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.play-button:hover {
  background-color: #0052cc;
}

.play-button.saved {
  background-color: #059669;
}

.play-button.saved:hover {
  background-color: #047857;
}

.episode-description {
  font-size: 0.95rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
}

.episode-meta {
  display: flex;
  gap: 1rem;
  font-size: 0.875rem;
  color: #6b7280;
}

.episode-duration::before {
  content: "🎧";
  margin-right: 0.25rem;
}

.episode-date::before {
  content: "📅";
  margin-right: 0.25rem;
}
</file>

<file path="src/styles/PodcastPlay.css">
.podcast-play-page {
  min-height: 100vh;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

/* PodcastPlay.css */
.typography-scrollable::-webkit-scrollbar {
  width: 6px;
}
.typography-scrollable::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}
.typography-scrollable {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
}



/* Podcast Info Header */
/* .podcast-info-header {
  padding: 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #f9fafb;
  display: flex;
  align-items: flex-start;
  gap: 2rem;
} */

/* .episode-cover-image {
  width: 160px;
  height: 160px;
  border-radius: 8px;
  object-fit: cover;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
} */

/* .episode-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1rem;
} */

/* .channel-info {
  margin-bottom: 0.5rem;
} */

/* .channel-title {
  font-size: 1rem;
  color: #6b7280;
  font-weight: 500;
} */

/* .episode-title {
  font-size: 2.5rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 1rem;
  line-height: 1.2;
} */

/* .episode-description {
  font-size: 1rem;
  line-height: 1.6;
  color: #4b5563;
  margin: 0;
} */
/* 
.episode-meta {
  display: flex;
  gap: 1rem;
  color: #6b7280;
  font-size: 0.875rem;
} */

/* Main Content */
/* .podcast-play-content {
  padding: 2rem;
  flex: 1;
  transition: opacity 0.2s ease;
  position: relative;
} */

/* .podcast-play-content.dimmed {
  opacity: 0.7;
  pointer-events: none;
} */

/* Transcript Container */
/* .transcript-container {
  background-color: #fff;
  border-radius: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  width: 60%;
} */

/* Transcript Header */
/* .transcript-header {
  display: flex;
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 16px;
} */

/* .transcript-header {
  display: flex;
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 16px;
} */


/* .language-select-container {
  display: flex;
  align-items: center;
} */

/* .language-select {
  padding: 10px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: white;
  font-size: 16px;
  color: #333;
  cursor: pointer;
  outline: none;
  min-width: 120px;
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 8px center;
  background-size: 16px;
} */

/* .language-select:hover {
  border-color: #666;
} */

/* .language-select:focus {
  border-color: #1976d2;
  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
} */

/* Transcript Content */
.transcript-content {
  /* max-height: 1000px; */
  height: 100%;
  width: 100%;
  padding: 0rem 0.5rem;
  overflow-y: auto;
  scroll-behavior: smooth;
  position: relative; 
}

.transcript-row {
  display: flex;
  align-items: flex-start;
  margin-bottom: 8px;
  grid-template-columns: 0.8fr 2fr 1.2fr;
  gap: 1rem;
  padding: 0.5rem 0rem;
  border-bottom: 1px solid #f3f4f6;
  transition: background-color 0.2s ease;
}

.transcript-row:hover {
  background-color: #f9fafb;
}

.transcript-row:last-child {
  border-bottom: none;
}

.timestamp-column {
  width: 80px;
  font-size: 0.8rem;
  color: #888;
  flex-shrink: 0;
}

.transcription-cell {
  word-break: break-word; 
  overflow-wrap: break-word;
  white-space: pre-wrap; 
}

.translation-cell {
  line-height: 1.5;
  display: flex;
  align-items: center;
}

.timestamp-cell {
  color: #6b7280;
}

.timestamp-inline {
  font-size: 0.8rem;
  color: #888;
  /* margin-right: 8px; */
}

.translation-cell {
  color: #111827;
}

.translation-text {
  font-size: 0.95rem;
  color: #555;
  margin-top: 4px;
}

/* Dictionary Overlay */
.dictionary-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  z-index: 150;
  display: flex;
  justify-content: center;
  align-items: flex-start;
}

/* Dictionary Mask */
.dictionary-mask {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.1);
  z-index: 1000;
}

/* Dictionary Card */
.dictionary-card {
  position: fixed;
  width: 400px;
  min-width: 400px;
  max-width: 400px;
  height: auto;
  max-height: 400px;
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1001;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  bottom: 32px;
}

/* 词典卡片内容区域，滚动 */
.dictionary-card-content {
  flex: 1 1 auto;
  overflow-y: auto;
  margin-bottom: 1rem;
}

/* 固定底部按钮 */
.add-to-wordlist-btn {
  width: 100%;
  padding: 0.75rem;
  margin-top: 1.5rem;
  background-color: #2563eb;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: absolute;
  left: 0;
  bottom: 0;
  border-radius: 0 0 8px 8px;
  margin: 0;
}

.add-to-wordlist-btn:hover {
  background-color: #1d4ed8;
}

.add-to-wordlist-btn:active {
  background-color: #1e40af;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.word-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #e5e7eb;
}

.word-text {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.word-level {
  padding: 0.25rem 0.5rem;
  background-color: #e0f2fe;
  color: #0369a1;
  font-weight: 500;
  border-radius: 9999px;
  font-size: 0.75rem;
}

.word-phonetics {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.phonetic {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.phonetic-label {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  min-width: 30px;
}

.phonetic-text {
  color: #111827;
  font-family: monospace;
}

.phonetic-audio {
  height: 24px;
  margin-left: auto;
}

.meaning-section {
  margin-bottom: 1.5rem;
}

.part-of-speech {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
  font-style: italic;
}

.definition-item {
  margin-bottom: 1rem;
}

.definition-text {
  color: #374151;
  font-size: 0.875rem;
  line-height: 1.5;
  margin-bottom: 0.5rem;
}

.example-text {
  color: #4b5563;
  font-size: 0.875rem;
  line-height: 1.5;
  font-style: italic;
  padding-left: 1rem;
  border-left: 2px solid #e5e7eb;
}

.word-synonyms,
.word-antonyms {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #e5e7eb;
}

.word-synonyms h4,
.word-antonyms h4 {
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
}

.synonyms-list,
.antonyms-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.synonym-tag,
.antonym-tag {
  padding: 0.25rem 0.75rem;
  background-color: #f3f4f6;
  color: #4b5563;
  border-radius: 9999px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.synonym-tag:hover,
.antonym-tag:hover {
  background-color: #e5e7eb;
}

/* Transcribe Button */
.transcribe-button {
  padding: 0.5rem 1.5rem;
  background-color: #006BFE;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.transcribe-button:hover {
  background-color: #4338CA;
  transform: translateY(-1px);
}

.transcribe-button:active {
  background-color: #3730A3;
  transform: translateY(0);
}

.transcript-row.active-row {
  background-color: #f1f5ff00;
  transition: background-color 0.3s ease;
}

.word-hover {
  cursor: pointer;
  padding: 0 0.2px; 
  transition: background-color 0.2s ease, color 0.2s ease;
}

.word-hover:hover {
  background-color: rgba(0, 26, 255, 0.753); 
  /* box-shadow: 0 0 0 4px rgba(0, 47, 255, 0.822); */
  color: white;
  padding: 2 0px; 
  /* border-radius: 6px;  */
}

.active-word {
  background-color: transparent; 
  color: #0400ff; 
  /* font-weight: bold;  */
}

.podcast-main-layout {
  display: flex;
  margin: 0 auto;
  gap: 2rem;
  padding-bottom: 90px; /* Adjust if player height changes */
}

.left-panel {
  flex: 0 0 45%; 
  display: flex;
  flex-direction: column;
}

.right-panel {
  width: 60%;
}

/* Notification Toast */
.notification-toast {
  position: fixed;
  bottom: 110px; /* 90px for player + 20px margin */
  left: 50%;
  transform: translateX(-50%);
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  color: white;
  z-index: 2000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  animation: fadeInUp 0.3s ease, fadeOutDown 0.3s ease 2.7s;
}

.notification-toast.info {
  background-color: #3498db;
}

.notification-toast.success {
  background-color: #2ecc71;
}

.notification-toast.warning {
  background-color: #f39c12;
}

.notification-toast.error {
  background-color: #e74c3c;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

@keyframes fadeOutDown {
  from {
    opacity: 1;
    transform: translate(-50%, 0);
  }
  to {
    opacity: 0;
    transform: translate(-50%, 20px);
  }
}

/* Fixed bottom audio player */
.bottom-audio-player {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100vw;
  background: #fff;
  z-index: 2001;
  box-shadow: 0 -2px 8px rgba(0,0,0,0.08);
  padding: 0.5rem 0;
}
</file>

<file path="src/styles/theme.js">
// theme.js
import { createTheme } from "@mui/material/styles";

// Material Design 3 示例主色调：蓝色
const theme = createTheme({
  palette: {
    mode: "light", // 可切换为 "dark" 实现暗色模式
    primary: {
      main: "#0066ff",       // 主按钮、链接、操作颜色
      contrastText: "#ffffff",
    },
    secondary: {
      main: "#e0e0e0",       // 用于中性背景、分隔线等
    },
    background: {
      default: "#f9f9f9",    // 页面背景
      paper: "#ffffff",      // 卡片背景（Surface）
    },
    text: {
      primary: "#111827",    // 主文本
      secondary: "#4b5563",  // 副文本
    },
  },
  shape: {
    borderRadius: 12,        // 更圆的外观，符合 M3
  },
  typography: {
    fontFamily: "Roboto, sans-serif",
    button: {
      textTransform: "none", // 按钮不全大写，M3 推荐
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      defaultProps: {
        disableElevation: true, // M3 风格通常不使用阴影
      },
      styleOverrides: {
        root: {
          borderRadius: "999px", // Pill-style 按钮，视觉上圆润
          padding: "8px 20px",
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          boxShadow: "0px 2px 4px rgba(0, 0, 0, 0.08)",
        },
      },
    },
    MuiTypography: {
      styleOverrides: {
        h1: { fontSize: "2.5rem", fontWeight: 700 },
        h2: { fontSize: "2rem", fontWeight: 700 },
        h3: { fontSize: "1.75rem", fontWeight: 600 },
        body1: { fontSize: "1rem" },
        body2: { fontSize: "0.95rem" },
      },
    },
  },
});


export default theme;
</file>

<file path="src/styles/TopNav.css">
.top-nav {
  width: 100%;
  padding: 1rem 2rem;
  border-bottom: 1px solid #e5e7eb;
  background-color: #fff;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1400px;
  margin: 0 auto;
}

.brand-link {
  font-size: 1.5rem;
  font-family: 'Candal', sans-serif;
  font-weight: 700;
  color: #2f71ff !important;
  text-decoration: none;
  transition: color 0.2s ease;
}

.brand-link:hover {
  color: #0e42b1 !important;
}

.nav-links {
  display: flex;
  justify-content: flex-end;
  gap: 1.5rem;
  margin-left: auto; 
}

.nav-link {
  color: #4b5563;
  text-decoration: none;
  font-size: 0.875rem;
  font-weight: 500;
  transition: color 0.2s ease;
}

.nav-link:hover {
  color: #1a56db;
} 

.slogan-text {
  font-size: 18px;
  font-weight: 700;
  color: #106EFF;
  margin-left: 12px;
}
</file>

<file path="src/styles/Wordlist.css">
.page-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: #f9fafb;
}

.wordlist-container {
  flex: 1;
  display: flex;
  padding: 2rem;
  gap: 2rem;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
}

/* Sidebar Navigation */
.wordlist-sidebar {
  width: 300px;
  background-color: #fff;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  height: fit-content;
  max-height: 80vh;
  overflow-y: auto;
}

.sidebar-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
}

.wordlist-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  max-height: 60vh;
  overflow-y: auto;
}

.wordlist-item {
  padding: 0.75rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f9fafb;
}

.wordlist-item:hover {
  background-color: #f3f4f6;
}

.wordlist-item.selected {
  background-color: #eff6ff;
  border-left: 3px solid #3b82f6;
  color: #1d4ed8;
}

.wordlist-name {
  font-size: 0.95rem;
  font-weight: 500;
}

.wordlist-count {
  font-size: 0.75rem;
  color: #6b7280;
  background-color: #f3f4f6;
  padding: 0.25rem 0.5rem;
  border-radius: 999px;
  font-style: italic;
}

/* Main Content Area */
.wordlist-content {
  flex: 1;
  background-color: #fff;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  max-height: 80vh;
  overflow-y: auto;
}

.content-title {
  font-size: 2rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
}

/* Status Messages */
.login-prompt, 
.loading-state, 
.error-state, 
.empty-state,
.no-selection {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f9fafb;
  text-align: center;
  color: #4b5563;
  margin-top: 1rem;
}

.login-prompt {
  background-color: #eff6ff;
  border: 1px dashed #93c5fd;
}

.error-state {
  background-color: #fee2e2;
  border: 1px dashed #fca5a5;
  color: #b91c1c;
}

.loading-state {
  background-color: #f3f4f6;
  border: 1px dashed #d1d5db;
}

.empty-state {
  background-color: #f3f4f6;
  border: 1px dashed #d1d5db;
}

.no-selection {
  background-color: #f3f4f6;
  font-style: italic;
  padding: 3rem;
  text-align: center;
}

/* Word Details Styling */
.word-details {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.phonetics-section {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.phonetic-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.5rem;
  background-color: #f9fafb;
  border-radius: 6px;
}

.phonetic-text {
  font-family: monospace;
  font-size: 0.95rem;
  color: #4b5563;
}

.phonetic-audio-btn {
  background-color: #e0f2fe;
  border: none;
  color: #0369a1;
  padding: 0.35rem 0.75rem;
  border-radius: 4px;
  font-size: 0.875rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  transition: all 0.2s ease;
}

.phonetic-audio-btn:hover {
  background-color: #bae6fd;
}

.meaning-section {
  margin-bottom: 2rem;
  padding: 1rem;
  background-color: #f9fafb;
  border-radius: 8px;
  border-left: 4px solid #e5e7eb;
}

.part-of-speech {
  font-size: 1.1rem;
  font-weight: 500;
  color: #4b5563;
  font-style: italic;
  margin-bottom: 1rem;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 0.5rem;
}

.definition-item {
  margin-bottom: 1.25rem;
  padding-left: 0.5rem;
  border-left: 2px solid #e5e7eb;
}

.definition-text {
  font-size: 1rem;
  line-height: 1.6;
  color: #111827;
  margin-bottom: 0.5rem;
}

.example-text {
  font-size: 0.95rem;
  line-height: 1.5;
  color: #6b7280;
  font-style: italic;
  padding-left: 1rem;
  margin-top: 0.5rem;
}

/* Synonyms and Antonyms */
.word-synonyms, .word-antonyms {
  margin-top: 1rem;
  padding-top: 0.75rem;
  border-top: 1px dashed #e5e7eb;
}

.word-synonyms h4, .word-antonyms h4 {
  font-size: 0.95rem;
  color: #4b5563;
  margin-bottom: 0.75rem;
}

.synonyms-list, .antonyms-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.synonym-tag, .antonym-tag {
  background-color: #f3f4f6;
  color: #4b5563;
  font-size: 0.875rem;
  padding: 0.35rem 0.75rem;
  border-radius: 999px;
  transition: all 0.2s ease;
}

.synonym-tag:hover, .antonym-tag:hover {
  background-color: #e5e7eb;
}

.word-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1rem;
}

.word-item {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f9fafb;
  border: 1px solid #e5e7eb;
  transition: all 0.2s ease;
}

.word-item:hover {
  background-color: #fff;
  border-color: #bfdbfe;
}

.word-text {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin-bottom: 0.75rem;
}

.word-phonetics {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid #e5e7eb;
}

.phonetic {
  font-size: 0.875rem;
  color: #6b7280;
  font-family: monospace;
  background-color: #fff;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  border: 1px solid #e5e7eb;
}
</file>

<file path="src/test/asrTest.jsx">
import { useEffect } from "react";
import { speechToText } from "../speechToText.js";
import { PROXY_URL } from "../../listenary-backend/config/apiConfig.js";

/**
 * ASR Test Component
 * Used for testing speech-to-text functionality
 */
export function AsrTest() {
  useEffect(function testAsrFunction() {
    console.log("AsrTest Component Mounted");
    const audioUrl = "https://crbn.us/whatstheweatherlike.wav";
    const proxyUrl = `${PROXY_URL}/proxy?url=${encodeURIComponent(audioUrl)}`;

    // Download audio and transcribe
    fetch(proxyUrl)
      .then(function handleResponse(response) {
        if (response.status !== 200) throw new Error(response.status);
        return response.blob();
      })
      .then(function processAudio(blob) {
        var audioFile = new File([blob], "audio.wav", { type: blob.type });
        var params = {
          audio: audioFile,
          definition: JSON.stringify({ locales: ["en-US"] }),
        };
        // Request speech-to-text API
        speechToText(params);
      })
      .catch(function handleError(error) {
        console.error("Fail", error.message);
      });
  }, []);

  return <div>ASR Test Running...</div>;
}
</file>

<file path="src/test/TestPresenter.jsx">
import { useState } from "react";
import { DictionaryAPI } from "../api/dictionaryAPI";

function TestPresenter() {
    const [word, setWord] = useState(""); 

    function testDictionaryAPI() {
        DictionaryAPI.getWord('Test')
            .then(data => {
                setWord(data);
            })
            .catch(error => {
                console.error('Query Failed:', error);
            });
    }

    testDictionaryAPI();

    return (
        <div>
            <h1>{JSON.stringify(word)}</h1>
        </div>
    )
}

export default TestPresenter;
</file>

<file path="src/views/PodcastView/DictionaryCard.jsx">
import { useRef } from "react";

export function DictionaryCard({ wordCard, onClose, onAddToWordlist }) {
  const phoneticAudioRef = useRef(null);

  const playPhoneticAudio = (url) => {
    if (!url) return;
    if (phoneticAudioRef.current) {
      phoneticAudioRef.current.src = url;
      phoneticAudioRef.current.play();
    }
  };

  return (
    <>
      <div className="dictionary-mask" onClick={onClose} />
      <div
        className="dictionary-card"
        style={{
          top: `${wordCard.position?.top || 0}px`,
          left: `${wordCard.position?.left || 0}px`,
          zIndex: 1300,
        }}
      >
        <div className="dictionary-card-content">
          <div className="word-header">
            <h3 className="word-text">{wordCard?.word || "..."}</h3>
            <span className="word-level">
              {wordCard?.meanings?.[0]?.partOfSpeech || "N/A"}
            </span>
          </div>
          <div className="word-phonetics">
            <div className="phonetic">
              <span className="phonetic-label">Phonetic</span>
              <span className="phonetic-text">
                {wordCard?.phonetic || "N/A"}
              </span>
              {wordCard?.phonetics?.[0]?.audio && (
                <>
                  <button
                    className="phonetic-audio-btn"
                    onClick={() =>
                      playPhoneticAudio(wordCard.phonetics[0].audio)
                    }
                    title="Play pronunciation"
                  >
                    🔊
                  </button>
                  <audio ref={phoneticAudioRef} style={{ display: "none" }} />
                </>
              )}
            </div>
          </div>
          <div className="word-definition">
            {wordCard?.meanings?.map((meaning, index) => (
              <div key={index} className="meaning-section">
                <p className="part-of-speech">{meaning.partOfSpeech}</p>
                {meaning.definitions?.map((def, defIndex) => (
                  <div key={defIndex} className="definition-item">
                    <p className="definition-text">{def.definition}</p>
                    {def.example && (
                      <p className="example-text">"{def.example}"</p>
                    )}
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>
        <button className="add-to-wordlist-btn" onClick={onAddToWordlist}>
          Add to Wordlist
        </button>
      </div>
    </>
  );
}
</file>

<file path="src/views/PodcastView/PodcastInfoCard.jsx">
import {
  Box,
  Card,
  CardContent,
  CardMedia,
  Typography,
  Button,
  Tooltip,
} from "@mui/material";
import GraphicEqIcon from "@mui/icons-material/GraphicEq";

export function PodcastInfoCard({ podcastData, isTranscribing, onTranscribe }) {
  return (
    <Box
      className="left-panel"
      sx={{
        flexShrink: 0,
        width: { xs: "100%", md: 400 },
        height: "95%",
        display: "flex",
        flexDirection: "column"
      }}
    >
      <Card
        elevation={1}
        sx={{
          width: "100%",
          borderRadius: 6,
          display: "flex",
          flexDirection: "column",
          height: "100%"
        }}
      >
        <CardContent
          sx={{
            display: "flex",
            alignItems: "center",
            gap: 1,
            flexShrink: 0,
            px: 3,
            py: 1.5
          }}
        >
          <Tooltip title={podcastData.source || "Name of Podcast"} arrow>
            <Typography
              variant="subtitle1"
              fontWeight={600}
              fontSize={20}
              lineHeight={1.3}
              sx={{
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
                maxWidth: "100%",
                cursor: "default"
              }}
            >
              {podcastData.source || "Name of Podcast"}
            </Typography>
          </Tooltip>
          <Box sx={{ flexGrow: 1 }}></Box>
        </CardContent>

        <CardMedia
          component="img"
          sx={{
            width: "100%",
            height: "auto",
            objectFit: "cover",
            maxHeight: { xs: 120, sm: 140, md: 160, lg: 220 },
            flexShrink: 1,
          }}
          image={podcastData.coverImage}
          alt="Podcast Cover"
        />

        <CardContent 
          sx={{ 
            display: "flex",
            flexDirection: "column",
            justifyContent: "space-between",  // 保证内容和按钮分开
            flexGrow: 1,
            minHeight: 0, // 避免无限撑高
            overflow: "hidden",
            p: 2
          }}
        >
          <Tooltip title={podcastData.title || "Episode Name"} arrow>
            <Typography
              variant="subtitle1"
              fontWeight={600}
              fontSize={22}
              gutterBottom
              noWrap
              sx={{
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
                cursor: "default",
                flexShrink: 0,
                maxWidth: "100%",
              }}
            >
              {podcastData.title || "Episode Name"}
            </Typography>
          </Tooltip>

          <Typography
            variant="body2"
            color="text.secondary"
            mt={1}
            className="typography-scrollable"
            sx={{
              lineHeight: 1.5,
              overflowY: "auto",
              pr: 1,
              flex: "1 1 auto",
              maxHeight: "none"
            }}
          >
            {podcastData.description || "Description..."}
          </Typography>
          <Box mt={2}>
            <Tooltip title="Only English podcasts are supported for now" arrow>
              <Button
                variant="contained"
                startIcon={<GraphicEqIcon />}
                size="small"
                onClick={onTranscribe}
                disabled={isTranscribing}
                sx={{
                  borderRadius: "100px",
                  textTransform: "none",
                  fontWeight: 600,
                  px: 2,
                  py: 0.5,
                  backgroundColor: "#006BFE",
                  color: "#fff",
                  boxShadow: 1,
                  width: "100%", // 宽度适配小屏
                  "&:hover": {
                    backgroundColor: "primary.dark",
                    boxShadow: 4
                  },
                  "&:disabled": {
                    backgroundColor: "grey.400",
                    color: "white"
                  }
                }}
              >
                {isTranscribing ? "Transcribing..." : "Transcribe"}
              </Button>
            </Tooltip>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
}
</file>

<file path="src/views/PodcastView/PodcastPlayView.jsx">
// import "../styles/PodcastPlay.css";
import { useNavigate } from "react-router-dom";
import { useState, useCallback, useRef, useEffect } from "react";
import { AUDIO_DOWNLOAD_URL } from "../../../listenary-backend/config/apiConfig.js";
import { TopNav } from "../../components/TopNav.jsx";
import AudioPlayerComponent from "../../components/AudioPlayerComponent.jsx";
import { useTranslationHandler } from "../../hooks/useTranslationHandler";
import { Box, ThemeProvider, createTheme, Typography } from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import GraphicEqIcon from "@mui/icons-material/GraphicEq";
import { PodcastInfoCard } from "./PodcastInfoCard.jsx";
import { TranscriptList } from "./TranscriptList";
import { DictionaryCard } from "./DictionaryCard";

const theme = createTheme();

export function PodcastPlayView({
  podcastData,
  onTimeUpdate,
  transcriptionData = [],
  onWordSelect,
  onTranscribe,
  isTranscribing,
  currentTime,
  wordCard,
  onAddToWordlist,
}) {
  const [showDictionary, setShowDictionary] = useState(false);
  const [dictionaryPosition, setDictionaryPosition] = useState(null);
  const [targetLanguage, setTargetLanguage] = useState("");
  const [translations, setTranslations] = useState({});
  const [translatingItems, setTranslatingItems] = useState(new Set());
  const [notification, setNotification] = useState({
    show: false,
    message: "",
    type: "info",
  });

  const rowRefs = useRef([]);
  const phoneticAudioRef = useRef(null);
  const internalAudioRef = useRef();

  useEffect(() => {
    return () => {
      if (internalAudioRef.current && internalAudioRef.current.pause) {
        internalAudioRef.current.pause();
        internalAudioRef.current.currentTime = 0;
      }
    };
  }, []);

  useEffect(
    function setupAutoScroll() {
      if (!transcriptionData.length) return;

      function findCurrentIndex() {
        return transcriptionData
          .map(function (item, i) {
            return { ...item, i };
          })
          .filter(function (item) {
            return item.offsetMilliseconds <= currentTime;
          })
          .pop()?.i;
      }

      const index = findCurrentIndex();
      if (index !== undefined && rowRefs.current[index]) {
        rowRefs.current[index].scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest",
        });
      }
    },
    [currentTime, transcriptionData]
  );

  const languages = [
    { code: "", name: "Translation Language" },
    { code: "ZH-HANS", name: "中文" },
    { code: "DE", name: "Deutsch" },
    { code: "SV", name: "Svenska" },
    { code: "FR", name: "Français" },
    { code: "NL", name: "Nederlands" },
  ];

  const { handleLanguageChange } = useTranslationHandler({
    transcriptionData,
    setTargetLanguage,
    setTranslations,
    setTranslatingItems,
  });

  const handleWordClick = (word, event) => {
    const CARD_WIDTH = 400;
    const CARD_HEIGHT = 320;
    const CARD_MARGIN = 10;
    const PLAYER_HEIGHT = 90;
    const CARD_BOTTOM_SAFE = PLAYER_HEIGHT + 48;
    const rect = event.target.getBoundingClientRect();
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let left = rect.right + CARD_MARGIN;
    if (left + CARD_WIDTH > windowWidth) {
      left = rect.left - CARD_WIDTH - CARD_MARGIN;
      if (left < 10) left = 10;
    }

    let top;
    const spaceBelow = windowHeight - rect.bottom - CARD_BOTTOM_SAFE;
    if (spaceBelow >= CARD_HEIGHT) {
      top = rect.bottom + CARD_MARGIN;
    } else {
      top = rect.top - CARD_HEIGHT - CARD_MARGIN;
      if (top < 10) top = 10;
    }

    setDictionaryPosition({ top, left });
    setShowDictionary(true);
    onWordSelect(word);
  };

  const handleAddToWordlist = useCallback(async () => {
    const result = await onAddToWordlist(wordCard);
    // Show specific notification based on login and save status
    if (result.type === "warning") {
      showNotification("Please login first to save your wordlist", "warning");
    } else if (result.type === "success") {
      showNotification("saved to the default wordlist", "success");
    } else {
      showNotification(result.message, result.type || "info");
    }
    setShowDictionary(false);
  }, [wordCard, onAddToWordlist]);

  const showNotification = (message, type = "info") => {
    setNotification({ show: true, message, type });
    setTimeout(
      () => setNotification({ show: false, message: "", type: "info" }),
      3000
    );
  };

  const playPhoneticAudio = (url) => {
    if (!url) return;
    if (phoneticAudioRef.current) {
      phoneticAudioRef.current.src = url;
      phoneticAudioRef.current.play();
    }
  };

  return (
    <ThemeProvider theme={theme}>
      <div
        className="podcast-page"
        style={{ display: "flex", flexDirection: "column", height: "100vh" }}
      >
        <TopNav />
        <Box
          sx={{
            flex: "1 1 auto",
            display: "flex",
            flexDirection: { xs: "column", md: "row" },
            maxWidth: 1400,
            mx: "auto",
            px: 1,
            pt: 0,
            pb: 0,
            gap: 2.5,
            width: "85%",
            overflow: "hidden",
            // height: "calc(100vh - 64px - 75px)",
            mt: "24px",
            mb: "90px",
          }}
        >
          {/* Left panel with podcast info */}
          <PodcastInfoCard
            podcastData={podcastData}
            isTranscribing={isTranscribing}
            onTranscribe={onTranscribe}
          />

          {/* Right panel with transcription */}
          <Box
            className="right-panel"
            sx={{
              flexGrow: 1,
              minWidth: 0,
              height: "95%",
              width: "100%",
              display: "flex",
              flexDirection: "column",
            }}
          >
            {/* Fixed header */}
            <Box
              sx={{
                display: "flex",
                width: "100%",
                justifyContent: "space-between",
                alignItems: "center",
                minWidth: "500px",
                position: "sticky",
                top: 0,
                zIndex: 1,
                px: 1,
                py: 1,
              }}
            >
              <Typography variant="h6" fontWeight="bold">
                Transcription
              </Typography>

              {/* Translation language selector, only shown when transcription exists */}
              {transcriptionData.length > 0 && (
                <Box sx={{ minWidth: 200 }}>
                  <select
                    value={targetLanguage}
                    onChange={handleLanguageChange}
                    style={{
                      width: "100%",
                      padding: "8px 12px",
                      borderRadius: "8px",
                      border: "1px solid #ccc",
                      fontSize: "14px",
                      backgroundColor: "#fff",
                      cursor: "pointer",
                      outline: "none",
                      transition: "border-color 0.2s",
                    }}
                  >
                    {languages.map(function (lang) {
                      return (
                        <option key={lang.code} value={lang.code}>
                          {lang.name}
                        </option>
                      );
                    })}
                  </select>
                </Box>
              )}
            </Box>

            {/* Scrollable transcript content */}
            <TranscriptList
              transcriptionData={transcriptionData}
              currentTime={currentTime}
              targetLanguage={targetLanguage}
              translations={translations}
              translatingItems={translatingItems}
              onWordClick={handleWordClick}
            />
            {/* Fixed bottom player area */}
            <Box
              sx={{
                position: "fixed",
                left: 0,
                bottom: 0,
                width: "100%",
                height: "aoto",
                zIndex: 1200,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <Box
                sx={{
                  width: "100%",
                  maxWidth: 1400,
                  px: 2,
                }}
              >
                <AudioPlayerComponent
                  ref={internalAudioRef}
                  audioSrc={`${AUDIO_DOWNLOAD_URL}?url=${encodeURIComponent(
                    podcastData.audioUrl
                  )}`}
                  onTimeUpdate={onTimeUpdate}
                />
              </Box>
            </Box>

            {/* Dictionary card */}
            {showDictionary && (
              <DictionaryCard
                wordCard={{ ...wordCard, position: dictionaryPosition }}
                onClose={() => setShowDictionary(false)}
                onAddToWordlist={handleAddToWordlist}
              />
            )}

            {notification.show && (
              <div className={`notification-toast ${notification.type}`}>
                {notification.message}
              </div>
            )}
          </Box>
        </Box>
      </div>
    </ThemeProvider>
  );
}
</file>

<file path="src/views/PodcastView/TranscriptList.jsx">
import { useEffect, useRef } from "react";
import { Box, Typography } from "@mui/material";
import "../../styles/PodcastPlay.css";


export function TranscriptList({
  transcriptionData,
  currentTime,
  targetLanguage,
  translations,
  translatingItems,
  onWordClick
}) {
  const rowRefs = useRef([]);

  // 自动滚动到当前时间点对应的行
  useEffect(() => {
    if (!transcriptionData.length) return;

    const index = transcriptionData
      .map((item, i) => ({ ...item, i }))
      .filter(item => item.offsetMilliseconds <= currentTime)
      .pop()?.i;

    if (index !== undefined && rowRefs.current[index]) {
      rowRefs.current[index].scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest"
      });
    }
  }, [currentTime, transcriptionData]);

  if (!transcriptionData.length) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Click "Transcribe" to get the transcription of this podcast
      </Typography>
    );
  }

  return (
    <Box className="transcript-content" sx={{ flex: "1 1 auto", overflowY: "auto", pr: 1 }}>
      <div className="transcription-container">
        {transcriptionData.map((item, index) => {
          const start = item.offsetMilliseconds;
          const end =
            index + 1 < transcriptionData.length
              ? transcriptionData[index + 1].offsetMilliseconds
              : Infinity;
          const isActive = currentTime >= start && currentTime < end;

          return (
            <div
              key={"row-" + index}
              ref={el => rowRefs.current[index] = el}
              className={"transcript-row " + (isActive ? "active-row" : "")}
            >
              <div className="timestamp-column">{item.timestamp}</div>
              <div className="content-column">
                <div className="transcription-text">
                  {item.text.split(/(\s+)/).map((part, wordIndex) => {
                    if (/\s+/.test(part)) return part;
                    return (
                      <span
                        key={"word-" + wordIndex}
                        className={"word-hover " + (isActive ? "active-word" : "")}
                        onClick={e => onWordClick(part, e)}
                      >
                        {part}
                      </span>
                    );
                  })}
                </div>
                {targetLanguage && (
                  <div className="translation-text">
                    {translatingItems.has(item.text)
                      ? "Loading..."
                      : translations[item.text]}
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </Box>
  );
}
</file>

<file path="src/views/HomePageView.jsx">
import "../styles/HomePage.css";
// import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { TopNav } from "../components/TopNav";
import TextField from "@mui/material/TextField";
import FavoriteIcon from "@mui/icons-material/Favorite";
import InputAdornment from "@mui/material/InputAdornment";
import PodcastsIcon from "@mui/icons-material/Podcasts";
import { CollapseBox } from "../components/CollapseBox";
import Snackbar from "@mui/material/Snackbar";
import {
  Grid,
  Box,
  Card,
  CardMedia,
  CardContent,
  Typography,
} from "@mui/material";

export function HomePageView({
  podcast,
  url,
  onInputChange,
  onParseClick,
  savedPodcasts,
  onSavedPodcastClick,
  errorMsg,
  snackbarOpen,
  onSnackbarClose,
}) {
  const navigate = useNavigate();

  function handleRssLinkClick(e, rssUrl) {
    e.preventDefault();
    onInputChange({ target: { value: rssUrl } });
  }

  return (
    <div className="homepage-container">
      <TopNav hideLogo />

      <div className="center-content">
        <div className="logo-container">
          <img
            src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/LOGO.svg?alt=media&token=a57cbd8b-9976-4ad4-8416-e42c08bf628f"
            alt="Listenary"
            className="logo"
          />
        </div>

        <div
          className="search-container"
          style={{ width: "600px", display: "flex" }}
        >
          <TextField
            variant="outlined"
            placeholder="Input RSS link to get podcast transcription"
            value={url}
            onChange={onInputChange}
            sx={{
              width: "486px",
              minWidth: "486px",
              maxWidth: "486px",
              "& .MuiOutlinedInput-root": {
                borderRadius: "30px",
                backgroundColor: "F5F9FF",
                paddingLeft: "16px",
              },
              "& .MuiOutlinedInput-notchedOutline": {
                borderColor: "#E0E0E0",
              },
              "&:hover .MuiOutlinedInput-notchedOutline": {
                borderColor: "#C0C0C0",
              },
              "& .MuiOutlinedInput-input": {
                paddingLeft: "4px",
                fontSize: "0.9rem",
              },
              "& .MuiInputAdornment-root": {
                marginRight: "8px",
              },
              "& .MuiOutlinedInput-input::placeholder": {
                opacity: 1,
                color: "#757575",
              },
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <PodcastsIcon color="action" />
                </InputAdornment>
              ),
            }}
          />
          <button
            type="button"
            className="search-button"
            style={{
              width: "90px",
              minWidth: "90px",
              maxWidth: "90px",
              height: "52px",
              marginLeft: "8px",
            }}
            onClick={onParseClick}
          >
            Parse
          </button>
        </div>
        {errorMsg && (
          <div
            style={{
              color: "red",
              marginTop: "0px",
              marginLeft: "8px",
              fontSize: "14px",
              textAlign: "left",
              width: "100%",
              maxWidth: "600px",
            }}
          >
            {errorMsg}
          </div>
        )}

        <div className="help-link-wrapper">
          <CollapseBox title="How to use Listenary">
            <ol className="rss-guide-list">
              <li>
                Use <a
                  href="https://castos.com/tools/find-podcast-rss-feed/"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Castos RSS Finder 
                </a> to search for a podcast, copy the RSS link, and paste it into
                the Parse box.
              </li>
              <li>Click Parse, then select the episode you want. </li>
              <li>
                Or try this link now! <a href="#"
                  className="example-rss-link"
                  onClick={function(event) {
                    handleRssLinkClick(
                      event,
                      "https://feeds.captivate.fm/one-minute-podcast-tips/"
                    );
                  }}
                >
                  One Minute Podcast Tips.
                </a> Enjoy it!
              </li>
            </ol>
          </CollapseBox>
        </div>
      </div>

      <div className="saved-section">
        <div className="saved-header">
          <h2 className="saved-title">
            <FavoriteIcon className="saved-icon" />
            Saved Podcasts
          </h2>
        </div>

        {savedPodcasts && savedPodcasts.length > 0 ? (
          <Box
            display="flex"
            flexWrap="nowrap"
            gap={1}
            justifyContent="flex-start"
            sx={{
              maxWidth: "1200px",
              margin: "0 auto",
            }}
          >
            {savedPodcasts.slice(0, 4).map((podcast, index) => (
              <Card
                key={index}
                onClick={() => onSavedPodcastClick(podcast)}
                sx={{
                  width: "290px",
                  flexShrink: 0,
                  borderRadius: 3,
                  boxShadow: 1,
                  cursor: "pointer",
                  transition: "all 0.2s ease-in-out",
                  "&:hover": {
                    boxShadow: 4,
                  },
                }}
              >
                <CardMedia
                  component="img"
                  height="140"
                  image={podcast.coverImage}
                  alt={podcast.title}
                  sx={{ objectFit: "cover" }}
                />
                <CardContent>
                  <Typography variant="subtitle1" fontWeight={600} noWrap>
                    {podcast.title}
                  </Typography>
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      display: "-webkit-box",
                      WebkitLineClamp: 2,
                      WebkitBoxOrient: "vertical",
                      lineHeight: 1.4,
                      minHeight: "2.8em",
                    }}
                  >
                    {podcast.description}
                  </Typography>
                </CardContent>
              </Card>
            ))}
          </Box>
        ) : (
          <Box
            display="flex"
            flexDirection="column"
            alignItems="center"
            justifyContent="center"
            sx={{ mt: 4 }}
          >
            <img
              src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea"
              alt="No saved podcasts"
              style={{ width: "160px", marginBottom: "16px" }}
            />
            <Typography variant="body1" color="text.secondary">
              No saved podcasts yet.
            </Typography>
          </Box>
        )}

        {savedPodcasts && savedPodcasts.length > 4 && (
          <a
            href="#"
            className="show-more"
            onClick={function (e) {
              e.preventDefault();
              navigate("/saved-podcasts");
            }}
          >
            Show more
          </a>
        )}

        <Snackbar
          open={snackbarOpen}
          autoHideDuration={4000}
          onClose={onSnackbarClose}
          message={errorMsg}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/views/loginPageView.jsx">
import '../styles/LoginPage.css';
import { TopNav } from '../components/TopNav';

function LoginView({
    isLoading,
    user,
    onGoogleLogin,
    onLogout
}) {
    return (
        <div className="page-container">
            <TopNav />
            <div className="login-wrapper">
                <div className="login-content">
                <div className="logo-container">
          <img
            src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/LOGO.svg?alt=media&token=a57cbd8b-9976-4ad4-8416-e42c08bf628f"
            alt="Listenary"
            className="logo"
          />
        </div>

                    {!user ? (
                        // Login form for unauthenticated users
                        <>
                            <button 
                                id="authButton"
                                   onClick={onGoogleLogin} 
                                disabled={isLoading}
                                className="google-sign-in-button"
                            >
                                <div className="google-sign-in-content">
                                    <img 
                                        src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" 
                                        alt="Google" 
                                        className="google-icon"
                                    />
                                    <span>{isLoading ? 'Signing in...' : 'Sign in with Google'}</span>
                                </div>
                            </button>

                            <p className="terms-text">
                                By continuing, you agree to our{' '}
                                <a href="#" className="terms-link">Terms</a> and{' '}
                                <a href="#" className="terms-link">Privacy</a>
                            </p>
                        </>
                    ) : (
                        // Welcome screen for authenticated users
                        <div className="welcome-container">
                            <p className="welcome-text">Welcome, {user.displayName || user.email}</p>
                            <button 
                                onClick={onLogout}
                                className="google-sign-in-button"
                            >
                                Logout
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

export default LoginView;
</file>

<file path="src/views/PodcastChannelView.jsx">
import {
  Box,
  Typography,
  Button,
  Card,
  CardMedia,
  CardContent,
  Tooltip,
  Link,
  ToggleButton,
  ToggleButtonGroup,
  Snackbar,
  Alert
} from "@mui/material";
import { TopNav } from "../components/TopNav";
import React, { useState } from "react";
import FavoriteIcon from "@mui/icons-material/Favorite";
import CheckIcon from "@mui/icons-material/Check";

// Episode card component for displaying individual podcast episodes
function EpisodeCard({ episode, onPlay, showSnackbar }) {
  const [expanded, setExpanded] = useState(false);
  const isClamped = episode.description?.length > 180;

  function handlePlay() {
    if (!episode?.enclosure?.url) {
      showSnackbar?.("This episode has no playable audio file", "warning");
      return;
    }
    onPlay(episode);
  }

  return (
    <Card
      sx={{
        p: 2,
        width: "100%",
        borderRadius: 3,
        transition: "background-color 0.3s",
        "&:hover": {
          backgroundColor: "#f5f5f5",
        },
        maxWidth: "100%",
      }}
      elevation={1}
    >
      <Box
        sx={{
          display: "flex",
          flexDirection: { xs: "column", sm: "row" },
          justifyContent: "space-between", 
          width: "100%",
          gap: 2,
        }}
      >
        <Box sx={{ display: "flex", gap: 2, flex: 1, minWidth: 0 }}>
          <CardMedia
            component="img"
            image={
              episode.coverImage ||
              "https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Episode%20Cover.svg?alt=media&token=5e5257bc-23e1-4db9-8342-a89502538bd0"
            }
            alt={episode.title}
            sx={{ width: 100, height: 100, borderRadius: 2 }}
          />

          <CardContent sx={{ p: 0 }}>
            <Typography
              variant="h6"
              sx={{
                display: "-webkit-box",
                WebkitBoxOrient: "vertical",
                WebkitLineClamp: 2,
                overflow: "hidden",
                textOverflow: "ellipsis",
                wordBreak: "break-word",
                lineHeight: 1.4,
              }}
            >
              {episode.title}
            </Typography>

            <Typography
              variant="body2"
              color="text.secondary"
              mt={1}
              sx={{
                ...(expanded
                  ? {}
                  : {
                      display: "-webkit-box",
                      overflow: "hidden",
                      WebkitBoxOrient: "vertical",
                      WebkitLineClamp: 2,
                    }),
                overflowWrap: "break-word",
                wordBreak: "break-word",
                lineHeight: 1.4,
              }}
            >
              {episode.description}
            </Typography>

            {isClamped && (
              <Link
                component="button"
                variant="body2"
                onClick={function() {
                  setExpanded(!expanded);
                }}
                sx={{ mt: 0.5, pl: 0, textTransform: "none" }}
              >
                {expanded ? "Show less" : "Show more"}
              </Link>
            )}

            <Typography
              variant="caption"
              color="text.secondary"
              mt={1}
              display="block"
            >
              🎧 {episode.duration}
            </Typography>
          </CardContent>
        </Box>

        <Box
          sx={{
            minWidth: 100,
            flexShrink: 0,
            display: "flex",
            justifyContent: "flex-end",
            alignItems: "flex-start",
          }}
        >
        <Button
          variant="contained"
          size="small"
          onClick={handlePlay}
          color={episode.isTranscribed ? "success" : "primary"}
        >
          {episode.isTranscribed ? "Continue" : "Learn"}
        </Button>
        </Box>
      </Box>
    </Card>
  );
}

// Main podcast channel view component
export function PodcastChannelView({
  channelInfo,
  episodes,
  isSaved,
  onSavePodcast,
  onRemovePodcast,
  onPlay,
  filterType,
  onFilterChange,
  snackbarState,
  onSnackbarClose
}) {
  const [visibleCount, setVisibleCount] = useState(10);
  const [descExpanded, setDescExpanded] = useState(false);
  const [open, setOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState("success");

  function showSnackbar(message, severity = "success") {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setOpen(true);
  }

  const descClamped = channelInfo.description?.length > 180;

  function handleClose(event, reason) {
    if (reason === "clickaway") return;
    setOpen(false);
  }

  function handleSubscribe() {
    const result = isSaved ? onRemovePodcast(channelInfo) : onSavePodcast(channelInfo);
    if (result && result.type === "warning") {
      showSnackbar(result.message, result.type);
    } else {
      showSnackbar(
        isSaved ? "Podcast removed from saved list" : "Podcast saved successfully",
        "success"
      );
    }
  }

  function handleFilterChange(event, newFilterType) {
    if (newFilterType !== null) {
      onFilterChange(event, newFilterType);
    }
  }

  return (
    <Box sx={{ bgcolor: "background.default", minHeight: "100vh" }}>
      <TopNav />

      <Box sx={{ maxWidth: 1200, mx: "auto", px: 4, pt: 4 }}>
        {/* Channel info card */}
        <Box
          display="flex"
          gap={5}
          flexWrap="wrap"
          alignItems="flex-start"
          width="100%"
        >
          <Card sx={{ width: 200, height: 200, borderRadius: 4, boxShadow: 3 }}>
            <CardMedia
              component="img"
              image={channelInfo.coverImage}
              alt={channelInfo.title}
              sx={{ width: "100%", height: "100%", objectFit: "cover" }}
            />
          </Card>

          <Box
            flex={1}
            display="flex"
            flexDirection="column"
            gap={2}
            justifyContent="flex-start"
            maxWidth={{ xs: "100%", md: "calc(100% - 240px)" }}
          >
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              width="100%"
            >
              <Typography variant="h4" fontWeight={700} color="text.primary">
                {channelInfo.title}
              </Typography>
              <Box ml={2}>
                <Button
                  variant="contained"
                  size="small"
                  color={isSaved ? "success" : "primary"}
                  onClick={handleSubscribe}
                  startIcon={<FavoriteIcon />}
                  sx={{ borderRadius: 2 }}
                >
                  {isSaved ? "Saved" : "Save"}
                </Button>
              </Box>
            </Box>
            <Typography
              variant="body1"
              color="text.secondary"
              sx={
                descExpanded
                  ? {}
                  : {
                      display: "-webkit-box",
                      overflow: "hidden",
                      WebkitBoxOrient: "vertical",
                      WebkitLineClamp: 3,
                    }
              }
            >
              <span
                dangerouslySetInnerHTML={{ __html: channelInfo.description }}
              />
            </Typography>
            {descClamped && (
              <Link
                component="button"
                variant="body2"
                onClick={function() {
                  setDescExpanded(!descExpanded);
                }}
                sx={{ textTransform: "none", alignSelf: "flex-start" }}
              >
                {descExpanded ? "Show less" : "Show more"}
              </Link>
            )}
          </Box>
        </Box>

        {/* Episode list */}
        <Box mt={6}>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
            mb={3}
          >
            <ToggleButtonGroup
              value={filterType}
              exclusive
              onChange={handleFilterChange}
              aria-label="Episode Filter"
              size="small"
            >
              <ToggleButton value="all" aria-label="All">
                All Episodes
              </ToggleButton>
              <ToggleButton value="untranscribed" aria-label="Untranscribed">
                New Episodes
              </ToggleButton>
              <ToggleButton value="transcribed" aria-label="Transcribed">
                Learned Episodes
              </ToggleButton>
            </ToggleButtonGroup>
          </Box>

          <Box display="flex" flexDirection="column" gap={2}>
            {episodes.slice(0, visibleCount).map((episode, index) => (
              <EpisodeCard key={episode.guid || index} episode={episode} onPlay={onPlay} showSnackbar={showSnackbar} />
            ))}
          </Box>
        </Box>
      </Box>

      {/* Snackbar notification */}
      <Snackbar 
        open={open}
        autoHideDuration={3000}
        onClose={handleClose}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert
          onClose={handleClose}
          severity={snackbarSeverity}
          sx={{ width: "100%" }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
}
</file>

<file path="src/views/SavedPodcastsView.jsx">
import "../styles/HomePage.css";
import { useNavigate } from "react-router-dom";
import { TopNav } from "../components/TopNav";
import {
  Grid,
  Box,
  Card,
  CardMedia,
  CardContent,
  Typography
} from "@mui/material";

/**
 * View component for displaying saved podcasts
 * @param {Object} props - Component props
 * @param {Array} props.savedPodcasts - Array of saved podcast objects
 */
function SavedPodcastsView(props) {
  const savedPodcasts = props.savedPodcasts;
  const navigate = useNavigate();

  function handleViewPodcast(podcast) {
    navigate("/podcast-channel", { state: { rssUrl: podcast.rssUrl } });
  }

  return (
    <div className="homepage-container">
      <TopNav />
<div className="saved-section">
  <div className="saved-header">
    <h2 className="saved-title">
      <img src="/saved-icon.png" alt="" className="saved-icon" />
      All Saved Podcasts
    </h2>
  </div>

  {savedPodcasts && savedPodcasts.length > 0 ? (
    <div className="saved-grid">
      {savedPodcasts.map(function (podcast, index) {
        return (
          <div
            key={index}
            className="saved-item"
            onClick={function () {
              handleViewPodcast(podcast);
            }}
          >
            <div className="saved-item-image-wrapper">
              <img
                src={podcast.coverImage}
                alt={podcast.title}
                className="saved-item-image"
              />
            </div>
            <h3 className="saved-item-title">{podcast.title}</h3>
            <p className="saved-item-description">{podcast.description}</p>
          </div>
        );
      })}
      </div>
      ) : (
        <Box
          width="100%"
          display="flex"
          justifyContent="center"
          alignItems="center"
          sx={{ mt: 4 }}
        >
          <Box
            display="flex"
            flexDirection="column"
            alignItems="center"
          >
            <img
              src="https://firebasestorage.googleapis.com/v0/b/dh2642-29c50.firebasestorage.app/o/Podcast.svg?alt=media&token=9ad09cc3-2199-436a-b1d5-4eb1a866b3ea"
              alt="No saved podcasts"
              style={{ width: "160px", marginBottom: "16px" }}
            />
            <Typography variant="body1" color="text.secondary">
              No saved podcasts yet.
            </Typography>
          </Box>
        </Box>
      )}
    </div>
  </div>
  );
}

export { SavedPodcastsView };
</file>

<file path="src/views/suspenseView.jsx">
export function SuspenseView(props) {
  if (!props.promise) {
    return <span>no data</span>;
  }
  if (props.error) {
    return <span>{props.error.toString()}</span>;
  } else return <img src="https://brfenergi.se/iprog/loading.gif" />;
}
</file>

<file path="src/views/WordlistView.jsx">
import '../styles/Wordlist.css';
import { TopNav } from '../components/TopNav';

/**
 * WordlistView Component - Part of the View layer in MVP
 * Displays the user's wordlist and selected word details
 */
export function WordlistView({ 
  words, 
  selectedWordIndex, 
  selectedWord, 
  onWordSelect,
  isLoading,
  error,
  isLoggedIn
}) {
  return (
    <div className="page-container">
      <TopNav />
      <div className="wordlist-container">
        {/* Left sidebar - Word list */}
        <div className="wordlist-sidebar">
          <h2 className="sidebar-title">My Wordlist</h2>

          {!isLoggedIn && (
            <div className="login-prompt">
              <p>Please log in to view your saved words.</p>
            </div>
          )}

          {isLoggedIn && isLoading && (
            <div className="loading-state">
              <p>Loading your wordlist...</p>
            </div>
          )}

          {isLoggedIn && error && (
            <div className="error-state">
              <p>{error}</p>
            </div>
          )}

          {isLoggedIn && !isLoading && !error && words.length === 0 && (
            <div className="empty-state">
              <p>You haven't saved any words yet.</p>
              <p>Look up words in podcast transcripts and add them to your wordlist.</p>
            </div>
          )}

          {isLoggedIn && !isLoading && words.length > 0 && (
            <div className="wordlist-list">
              {words.map((word, index) => (
                <div
                  key={index}
                  className={`wordlist-item ${selectedWordIndex === index ? 'selected' : ''}`}
                  onClick={() => onWordSelect(index)}
                >
                  <span className="wordlist-name">{word.word}</span>
                  <span className="wordlist-count">
                    {word.meanings && word.meanings.length > 0 ? word.meanings[0].partOfSpeech : ''}
                  </span>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Right content - Word details */}
        <div className="wordlist-content">
          {selectedWord ? (
            <div className="word-details">
              <h2 className="content-title">{selectedWord.word}</h2>
              
              {/* Phonetics section - Simplified to show only one phonetic */}
              {selectedWord.phonetics && selectedWord.phonetics.length > 0 && (
                <div className="phonetics-section">
                  {(() => {
                    // Find the first phonetic with audio, or just use the first one
                    const phoneticWithAudio = selectedWord.phonetics.find(p => p.audio) || selectedWord.phonetics[0];
                    
                    return (
                      <div className="phonetic-item">
                        <span className="phonetic-text">
                          {phoneticWithAudio.text || selectedWord.phonetic || ''}
                        </span>
                        {phoneticWithAudio.audio && (
                          <button 
                            className="phonetic-audio-btn"
                            onClick={() => {
                              const audio = new Audio(phoneticWithAudio.audio);
                              audio.play();
                            }}
                          >
                            🔊 Play
                          </button>
                        )}
                      </div>
                    );
                  })()}
                </div>
              )}
              
              {/* Meanings section */}
              {selectedWord.meanings && selectedWord.meanings.map((meaning, meaningIndex) => (
                <div key={meaningIndex} className="meaning-section">
                  <h3 className="part-of-speech">{meaning.partOfSpeech}</h3>
                  
                  {meaning.definitions && meaning.definitions.map((def, defIndex) => (
                    <div key={defIndex} className="definition-item">
                      <p className="definition-text">{def.definition}</p>
                      {def.example && (
                        <p className="example-text">Example: "{def.example}"</p>
                      )}
                    </div>
                  ))}
                  
                  {/* Synonyms */}
                  {meaning.synonyms && meaning.synonyms.length > 0 && (
                    <div className="word-synonyms">
                      <h4>Synonyms:</h4>
                      <div className="synonyms-list">
                        {meaning.synonyms.map((synonym, synIndex) => (
                          <span key={synIndex} className="synonym-tag">{synonym}</span>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Antonyms */}
                  {meaning.antonyms && meaning.antonyms.length > 0 && (
                    <div className="word-antonyms">
                      <h4>Antonyms:</h4>
                      <div className="antonyms-list">
                        {meaning.antonyms.map((antonym, antIndex) => (
                          <span key={antIndex} className="antonym-tag">{antonym}</span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="no-selection">
              <p>Select a word from your wordlist to view details.</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/firestoreModel.js">
// initialize Firebase app
import { initializeApp } from "firebase/app";
import { firebaseConfig } from "../listenary-backend/config/firebaseConfig.js";
import {
  getFirestore,
  doc,
  setDoc,
  getDoc,
  arrayUnion,
  updateDoc,
} from "firebase/firestore";
import loginModel from "./loginModel";
import { model } from "./Model";

export const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);

// make doc and setDoc available at the Console for testing
window.doc = doc;
window.setDoc = setDoc;
window.db = db;

export function saveUserData(uid, data) {
  const userDoc = doc(db, "users", uid);
  return setDoc(userDoc, data, { merge: true });
}

export function loadUserData(uid) {
  const userDoc = doc(db, "users", uid);
  return getDoc(userDoc).then(function (docSnap) {
    if (docSnap.exists()) {
      return docSnap.data();
    } else {
      return null;
    }
  });
}

export async function getUserWordlist(uid) {
  try {
    const userDoc = doc(db, "users", uid);
    const docSnap = await getDoc(userDoc);

    if (docSnap.exists() && docSnap.data().wordlist) {
      return docSnap.data().wordlist;
    } else {
      return [];
    }
  } catch (error) {
    console.error("Error getting user wordlist:", error);
    return [];
  }
}

export async function saveWordToUserWordlist(uid, wordData) {
  try {
    const userDoc = doc(db, "users", uid);

    // First check if user document exists
    const docSnap = await getDoc(userDoc);

    if (docSnap.exists()) {
      // User exists, update wordlist
      await updateDoc(userDoc, {
        wordlist: arrayUnion(wordData),
      });
    } else {
      // Create new user document with wordlist
      await setDoc(userDoc, {
        username: loginModel.user?.displayName || "User",
        wordlist: [wordData],
      });
    }
    return true;
  } catch (error) {
    console.error("Error saving word to wordlist:", error);
    return false;
  }
}

export function connectToPersistence(model) {
  // You can call saveUserData/loadUserData here if you want auto sync
}
// save transcription data to firestore
export async function saveTranscriptionData(uid, guid, title, phrases) {
  const docRef = doc(db, "users", uid, "transcriptions", guid);
  try {
    await setDoc(docRef, {
      title: title,
      phrases: phrases,
      updatedAt: new Date(),
    });
    console.log(`Transcription saved for episode ${title}`);
  } catch (err) {
    console.error(err);
  }
}

export async function getTranscriptionData(uid, guid) {
  const docRef = doc(db, "users", uid, "transcriptions", guid);
  try {
    const snap = await getDoc(docRef);
    if (snap.exists()) {
      return snap.data().phrases || [];
    } else {
      return [];
    }
  } catch (err) {
    console.error(err);
    return [];
  }
}

// Save podcast channel info to localStorage
export function savePodcastChannelInfo(channelInfo) {
  localStorage.setItem("podcastChannelInfo", JSON.stringify(channelInfo));
}

// Load podcast channel info from localStorage
export function loadPodcastChannelInfo() {
  const savedInfo = localStorage.getItem("podcastChannelInfo");
  return savedInfo ? JSON.parse(savedInfo) : null;
}

// Save podcast episodes to localStorage
export function savePodcastEpisodes(episodes) {
  localStorage.setItem("podcastEpisodes", JSON.stringify(episodes));
}

// Load podcast episodes from localStorage
export function loadPodcastEpisodes() {
  const savedEpisodes = localStorage.getItem("podcastEpisodes");
  return savedEpisodes ? JSON.parse(savedEpisodes) : [];
}

// Save RSS URL to localStorage
export function saveRssUrl(url) {
  localStorage.setItem("rssUrl", url);
}

// Load RSS URL from localStorage
export function loadRssUrl() {
  return localStorage.getItem("rssUrl") || "";
}

// Save audio URL to localStorage
export function saveAudioUrl(url) {
  localStorage.setItem("audioUrl", url);
}

// Load audio URL from localStorage
export function loadAudioUrl() {
  return localStorage.getItem("audioUrl") || "";
}
</file>

<file path="src/index.jsx">
import { observable, runInAction } from "mobx";
import React, { useState } from "react";
import { createRoot } from "react-dom/client";
import { ReactRoot } from "./ReactRoot";
import { model } from "./Model";
import { AsrTest } from "./test/asrTest";
import "./styles/LoginPage.css";
import { db, connectToPersistence } from "./firestoreModel";
import loginModel from "./loginModel";
import { loadUserData } from "./firestoreModel";
// 新增：引入 MUI 
import { ThemeProvider, CssBaseline } from "@mui/material";
import theme from "./styles/theme.js"; 

const myModel = observable(model);
connectToPersistence();

// Global auth state listener: sync login state and savedPodcasts
loginModel.setupAuthStateListener(function(user) {
  if (user) {
    // User just logged in or refreshed
    loadUserData(user.uid)
      .then(function(userData) {
        if (userData && userData.savedPodcasts) {
          runInAction(function() {
            myModel.savedPodcasts.replace(userData.savedPodcasts);
          });
        }
      });
  } else {
    // User logged out
    runInAction(function() {
      myModel.savedPodcasts.replace([]);
    });
  }
});

// 包裹 ThemeProvider 和 CssBaseline
createRoot(document.getElementById("root")).render(
  <ThemeProvider theme={theme}>
    <CssBaseline />
    <ReactRoot model={myModel} />
  </ThemeProvider>
);

window.myModel = myModel;

import { doc, setDoc } from "firebase/firestore";
const firestoreDoc = doc(db, "test collection", "test document");
setDoc(firestoreDoc, { dummyField: "dummyValue" }, { merge: true }).catch(
  console.error
);
</file>

<file path="src/loginModel.js">
import {
  getAuth,
  GoogleAuthProvider,
  signInWithPopup,
  onAuthStateChanged,
  signOut,
} from "firebase/auth";
import { app } from "./firestoreModel.js";
import { makeAutoObservable, runInAction } from "mobx";

// Pure data model for login
class LoginModel {
  constructor() {
    // Initialize Firebase Auth
    this.auth = getAuth(app);
    this.googleProvider = new GoogleAuthProvider();
    this.isLoading = false;
    this.user = null;
    this.viewUpdateCallbacks = [];
    makeAutoObservable(this);

    // Set up initial auth state
    const self = this;
    onAuthStateChanged(this.auth, function(user) {
      runInAction(function() {
        self.user = user;
      });
    });
  }

  getIsLoading() {
    return this.isLoading;
  }
  getUser() {
    return this.user;
  }

  // Firebase auth state monitoring
  setupAuthStateListener(callback) {
    if (callback) {
      this.viewUpdateCallbacks.push(callback);
    }
    const self = this;
    return onAuthStateChanged(this.auth, function(user) {
      runInAction(function() {
        self.user = user;
      });
      if (callback) callback(user);
    });
  }

  notifyViewUpdate() {
    const self = this;
    this.viewUpdateCallbacks.forEach(function(callback) {
      callback();
    });
  }

  // Authentication methods
  googleLogin() {
    const self = this;
    return new Promise(function(resolve, reject) {
      runInAction(function() {
        self.isLoading = true;
      });

      if (self.auth.currentUser) {
        signOut(self.auth)
          .then(function() {
            runInAction(function() {
              self.user = null;
              self.isLoading = false;
            });
            resolve({ success: true });
          })
          .catch(function(error) {
            runInAction(function() {
              self.isLoading = false;
            });
            reject({ success: false, error: error.message });
          });
      } else {
        signInWithPopup(self.auth, self.googleProvider)
          .then(function(result) {
            runInAction(function() {
              self.user = result.user;
              self.isLoading = false;
            });
            resolve(result);
          })
          .catch(function(error) {
            runInAction(function() {
              self.isLoading = false;
            });
            reject({ success: false, error: error.message });
          });
      }
    });
  }

  logout() {
    const self = this;
    return signOut(self.auth)
      .then(function() {
        runInAction(function() {
          self.user = null;
        });
        return { success: true };
      })
      .catch(function(error) {
        return { success: false, error: error.message };
      });
  }

  setUser(user) {
    const self = this;
    runInAction(function() {
      self.user = user;
    });
  }
}
// Create and export a singleton instance
const loginModel = new LoginModel();
export default loginModel;
</file>

<file path="src/Model.js">
import { resolvePromise } from "./resolvePromise.js";
import { speechToText } from "./speechToText.js";
import { PARSE_RSS_FEED_URL } from "../listenary-backend/config/apiConfig.js";
import { RssModel } from "./rssModel.js";
import { DictionaryAPI } from "./api/DictionaryAPI";
import {
  saveUserData,
  savePodcastChannelInfo,
  loadPodcastChannelInfo,
  savePodcastEpisodes,
  loadPodcastEpisodes,
  saveRssUrl,
  loadRssUrl,
  saveAudioUrl,
  loadAudioUrl,
} from "./firestoreModel";
import loginModel from "./loginModel";
import { observable, runInAction } from "mobx";

export const model = {
  // RSS related states
  rssUrl: loadRssUrl(),
  // Podcast channel information
  podcastChannelInfo: loadPodcastChannelInfo(),
  podcastEpisodes: loadPodcastEpisodes(),
  podcastLoadError: null,
  errorMsg: "", // Error message state

  rssModel: new RssModel(), // RssModel instance
  // Saved podcasts
  savedPodcasts: observable([]),

  //podcast player states
  audioUrl: loadAudioUrl(),
  // Single episode information
  currentEpisode: null,
  audioFile: null, // Store audio file
  transcripResults: [],
  transcripResultsPromiseState: {},

  // Dictionary lookup state
  dictionaryResult: null,
  dictionaryLookupPromiseState: {},

  setResults(results) {
    this.transcripResults.replace(results);
  },

  setAudioUrl(url) {
    this.audioUrl = url;
    saveAudioUrl(url);
  },

  setAudioFile(file) {
    this.audioFile = file;
  },

  setAudioDuration(duration) {
    this.audioDuration = duration;
  },

  setRssUrl(url) {
    this.rssUrl = url;
    saveRssUrl(url);
  },

  setCurrentEpisode(episode) {
    this.currentEpisode = episode;
  },

  async loadRssData() {
    this.podcastLoadError = null;
    this.podcastChannelInfo = null;
    this.podcastEpisodes = [];

    try {
      const { feed, items } = await this.rssModel.loadFeed(this.rssUrl);
      this.podcastChannelInfo = {
        title: feed.title,
        description: feed.description,
        coverImage: feed.image,
        rssUrl: this.rssUrl,
      };
      savePodcastChannelInfo(this.podcastChannelInfo);

      this.podcastEpisodes = items;
      savePodcastEpisodes(this.podcastEpisodes);
    } catch (err) {
      console.error("RSS fetch failed", err);
      this.podcastLoadError = err.message;
      throw err;
    }
  },

  // Store ASR API result in transcription result promise state
  getTranscription(params) {
    resolvePromise(speechToText(params), transcripResultsPromiseState);
  },

  // Save selected podcast
  addToSaved(podcastToAdd) {
    function isPodcastAlreadySaved(savedPodcast) {
      return savedPodcast.title === podcastToAdd.title;
    }

    if (!this.savedPodcasts.find(isPodcastAlreadySaved)) {
      if (!podcastToAdd.rssUrl) {
        podcastToAdd.rssUrl = this.rssUrl;
      }

      runInAction(() => {
        this.savedPodcasts.push(podcastToAdd);
      });
      console.log("Added to savedPodcasts: " + podcastToAdd.title);
      this.persistUserData();
    }
  },

  // Unsave selected podcast
  removeFromSaved(podcastToRemove) {
    function shouldWeKeepPodcastCB(podcast) {
      return podcast.title !== podcastToRemove.title;
    }
    runInAction(() => {
      this.savedPodcasts = this.savedPodcasts.filter(shouldWeKeepPodcastCB);
    });
    console.log("Removed from savedPodcasts: " + podcastToRemove.title);
    this.persistUserData();
  },

  /**
   * Persist user data to Firestore (username, savedPodcasts)
   */
  persistUserData() {
    const user = loginModel.getUser();
    if (user) {
      saveUserData(user.uid, {
        username: user.displayName,
        savedPodcasts: this.savedPodcasts.slice(),
      });
    }
  },

  // Dictionary lookup method
  async lookupWord(word) {
    try {
      const result = await DictionaryAPI.getWord(word);
      this.dictionaryResult = result;
      return result;
    } catch (error) {
      console.error("Dictionary lookup failed:", error);
      this.dictionaryResult = null;
      return null;
    }
  },

  // Set error message
  setErrorMsg(message) {
    this.errorMsg = message;
  },
};
</file>

<file path="src/ReactRoot.jsx">
import { observer } from "mobx-react-lite";
import { createHashRouter, RouterProvider } from "react-router-dom";
import { HomePagePresenter } from "./presenter/HomePagePresenter";
// import { Transcription } from "./presenter/TranscrptionPresenter";
import { WordlistPresenter } from "./presenter/WordlistPresenter";
import PodcastChannelPresenter from "./presenter/PodcastChannelPresenter";
import PodcastPlayPresenter from "./presenter/PodcastPlayPresenter";
import LoginPresenter from "./presenter/loginPagePresenter.jsx";
import { RssPresenter } from "./presenter/rssPresenter";
import TestPresenter from "./test/TestPresenter";
import SavedPodcastsPresenter from "./presenter/SavedPodcastsPresenter";

const ReactRoot = observer(function ReactRoot(props) {
  return (
    <RouterProvider router={makeRouter(props.model)} />
    /*RouterProvider comes from react-router-dom*/
  );
});

export { ReactRoot };

export function makeRouter(ReactiveModel) {
  return createHashRouter([
    {
      path: "/",
      element: <HomePagePresenter model={ReactiveModel} />,
    },
    {
      path: "/wordlist",
      element: <WordlistPresenter model={ReactiveModel} />,
    },
    // {
    //   path: "/Transcription",
    //   element: <Transcription model={ReactiveModel} />,
    // },
    {
      path: "/login",
      element: <LoginPresenter model={ReactiveModel} />,
    },
    {
      path: "/podcast-channel",
      element: <PodcastChannelPresenter model={ReactiveModel} />,
    },
    {
      path: "/podcast-play",
      element: <PodcastPlayPresenter model={ReactiveModel} />,
    },
    {
      path: "/rss-test",
      element: <RssPresenter />,
    },
    {
      path: "/test",
      element: <TestPresenter />,
    },
    {
      path: "/saved-podcasts",
      element: <SavedPodcastsPresenter model={ReactiveModel} />,
    },
  ]);
}
</file>

<file path="src/resolvePromise.js">
//TW2.2.1:

export function resolvePromise(prms, promiseState){
  promiseState.promise = prms; //record prms
  promiseState.data = null; // clear the previous data
  promiseState.error = null; // clear the previous error

  if (!prms) return; // in case of empty promise

  function successACB(result){
    if(promiseState.promise === prms)
      promiseState.data = result;
  }
  function failureACB(result){
    if(promiseState.promise === prms)
      promiseState.error = result;
  }

  prms.then(successACB).catch(failureACB);
  
}
</file>

<file path="src/rssModel.js">
import { PARSE_RSS_FEED_URL } from "../listenary-backend/config/apiConfig.js";
// Change to frontend RSS processing
import Parser from "rss-parser";

// function formatDuration(duration) {
//   if (!duration) return "Unknown";

//   if (typeof duration === "number") {
//     const m = Math.floor(duration / 60);
//     const s = duration % 60;
//     return `${m}:${s.toString().padStart(2, "0")}`;
//   }

//   if (typeof duration === "string") {
//     if (/^\d+$/.test(duration)) {
//       // Pure number of seconds
//       return formatDuration(Number(duration));
//     }
//     if (
//       /^\d{1,2}:\d{2}$/.test(duration) ||
//       /^\d{1,2}:\d{2}:\d{2}$/.test(duration)
//     ) {
//       // Already in standard format
//       return duration;
//     }
//   }

//   return "Unknown";
// }

export class RssModel {
  constructor() {
    this.feed = null;
    this.items = [];
    this.subscribers = [];
    // this.parser = new Parser({
    //   customFields: {
    //     feed: ["image", "language", "copyright"],
    //     item: [
    //       "itunes:duration",
    //       "itunes:image",
    //       "itunes:episode",
    //       "itunes:season",
    //       "itunes:summary",
    //       "enclosure",
    //     ],
    //   },
    // });
  }

  async loadFeed(url) {
    try {
      // Use fetch to get RSS data
      // const response = await fetch(url);
      // Call Firebase Function
      const response = await fetch(
        `${PARSE_RSS_FEED_URL}?url=${encodeURIComponent(url)}`
        // Add header that allows CORS [debug]
      );
      if (!response.ok) {
        throw new Error(`Failed to fetch RSS feed: ${response.status}`);
      }
      const data = await response.json();

      this.feed = data.feed;
      this.items = data.items;

      // this.feed = {
      //   title: data.title,
      //   description: data.description,
      //   image: data.image,
      //   link: data.link,
      // };

      // this.items = data.items.map(function(item) {
      //   return {
      //     title: item.title,
      //     description: item.contentSnippet || item.description,
      //     pubDate: item.pubDate || item.isoDate,
      //     // duration: item.itunes?.duration, // Duration cannot be displayed
      //     duration: formatDuration(item.itunes?.duration),
      //     episode: item.itunes?.episode,
      //     season: item.itunes?.season,
      //     image: item.itunes?.image || data.image,
      //     guid: item.guid,
      //     link: item.link,
      //     enclosure: item.enclosure,
      //   };
      // });

      this.notifySubscribers();

      return { feed: this.feed, items: this.items };
    } catch (error) {
      console.error("Error loading RSS feed:", error);
      throw error;
    }
  }

  getFeedInfo() {
    return this.feed;
  }

  getEpisodes() {
    return this.items;
  }

  subscribe(callback) {
    this.subscribers.push(callback);
    return function () {
      this.subscribers = this.subscribers.filter(function (cb) {
        return cb !== callback;
      });
    };
  }

  notifySubscribers() {
    this.subscribers.forEach(function (callback) {
      callback(this);
    });
  }
}
</file>

<file path="src/speechToText.js">
// import { model } from "./Model.js";
import { model } from "./Model.js";
import {
  AZURE_API_URL,
  AZURE_API_KEY,
  PROXY_URL,
} from "../listenary-backend/config/apiConfig.js";

// export function speechToText(params) {
// Rewrite original method: Replace FormData with JSON request body, use audio URL
export function speechToText(params) {
  const { audio, definition } = params;
  // Create FormData object to store audio file and definition parameters
  const formData = new FormData();
  if (params.audio) {
    formData.append("audio", audio); // Appends "audio" as a new parameter.
  }
  if (params.definition) {
    formData.append("definition", definition); // Appends "definition" as a new parameter.
  } // Send request
  return fetch(
    `${PROXY_URL}?url=${encodeURIComponent(
      AZURE_API_URL +
        "/speechtotext/transcriptions:transcribe?api-version=2024-11-15"
    )}`, // New URL
    {
      method: "POST",
      body: formData,
    }
  )
    .then(gotResponseACB) // Convert response data to JSON
    .catch(function (error) {
      console.error("Fail to upload or transcribe", error.message);
    });

  function gotResponseACB(response) {
    // Change 7: Check status, provide more user-friendly error messages
    if (!response.ok)
      throw new Error(`Transcription API failed: ${response.status}`);
    return response.json();
  }
}
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "dh2642-29c50"
  }
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Firebase local runtime & logs
functions/.runtimeconfig.json
firebase-debug.log
</file>

<file path="firebase.json">
{
  "hosting": {
    "public": "dist",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "/deepl/**",
        "function": "translate"
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "runtime": "nodejs20"
    },
    {
      "source": "listenary-backend",
      "codebase": "listenary-backend",
      "runtime": "nodejs20",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    }
  ]
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" href="/asset/SingleLOGO.svg" type="image/svg+xml">
    <title>Listenary - Turn every podcast into knowledge.</title>
    <meta charset="UTF-8" />
     <!-- 引入 Google Fonts 的 Candal 字体 -->
     <link href="https://fonts.googleapis.com/css2?family=Candal&display=swap" rel="stylesheet">
    </head>
  <body>
    <div id="root"></div> <!--*entry page for the app; provide the root element*-->
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "jigao-liyuans-ruopeng-yuezhe-vt25-project",
  "version": "1.0.0",
  "private": true,
  "description": "Listenary is an English language learning platform for English learners, where you can listen to podcasts, transcribe them, translate them, and build your wordlist.",
  "repository": {
    "type": "git",
    "url": "https://gits-15.sys.kth.se/iprog-students/jigao-liyuans-ruopeng-yuezhe-vt25-Project.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@emotion/react": "^11.9.3",
    "@emotion/styled": "^11.9.3",
    "@material/web": "^2.3.0",
    "@mui/icons-material": "^7.1.0",
    "@mui/material": "^7.1.0",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "dotenv": "^17.2.2",
    "express": "^5.1.0",
    "firebase": "^11.6.0",
    "mobx": "^6.13.5",
    "mobx-react-lite": "^4.0.7",
    "mongoose": "^8.18.2",
    "newskit": "^7.7.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-h5-audio-player": "^3.10.0-rc.1",
    "react-router-dom": "^6.22.1",
    "react-toastify": "^11.0.5",
    "rss-parser": "^3.13.0",
    "wavesurfer.js": "^7.9.5",
    "web-vitals": "^2.1.4"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.4",
    "vite": "^6.2.6",
    "vitest": "^3.1.1"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "main": "vite.config.js"
}
</file>

<file path="README.md">
# Listenary – Podcast-Based Language Learning Platform

Listenary is an English language learning platform for English learners, where you can listen to podcasts, transcribe them, translate them, and build your wordlist.

You only need 3 simple steps to start your learning journey:

**Step 1**: Open the third-party tool Castos RSS Finder, search the podcast title you want to learn, and copy paste the rss link of the podcast into the Parse box above.

**Step 2**: Click on Parse, then on the podcast channel page click on the episode you want to learn.

**Step 3**: On the episode page, click on Transcibe to see the transcription result in English. You can also click Translate to get translation in your own language.

## Features

1. Load and parse podcast episodes from any public RSS feed

2. Display podcast metadata (title, publish date, description, episodes)

3. Integrated audio streaming and waveform visualization

4. Time-aligned transcription results of the podcast alongside the audio for easy navigation

5. One-click full podcast translation and vocabulary look-up
   
6. Personal vocabulary list management

## Tech Stack

1. **Frontend Framework**: React
2. **State Management**: MobX
3. **Speech to Text**: Microsoft Azure Speech-to-Text API
4. **Translation**: DeepL API
5. **Dictionary**: Dictionary API (https://dictionaryapi.dev/)
6. **Authentication**: Google OAuth 2.0 API
7. **RSS Parsing**: rss-parser (Node.js library)
8. **Languages**: JavaScript / CSS / HTML
9. **Build Tool**: Vite

## Running deployed application

https://dh2642-29c50.web.app

## Setup and Running Instructions locally

### Install Dependences

```bash
npm install
```

### Start the development server:

```bash
npm run dev
```

## Used Third-party components

1. [Audio Waveform Player](https://wavesurfer.xyz/): We use this open-source audio visualization library to build an audio player that visually represents the playing progress. With this third-party component, users can efficiently locate the sentence they are listening to, click on the waveform, and seamlessly synchronize the audio with the transcription.

2. [Material UI](https://m3.material.io/develop/web): We use this popular React component library to build modern and responsive user interfaces. With this third-party component, users can enjoy a consistent and intuitive design while interacting with various features, enhancing the overall user experience.

## Sample RSS Feeds

Feel free to use the following sample links to test podcast loading and transcription:

- https://feeds.captivate.fm/one-minute-podcast-tips/
- https://feed.podcastmachine.com/podcasts/1288/mp3.rss
- http://img.webmd.com/video_itunes/feed.xml
- https://feeds.buzzsprout.com/2295449.rss

You can also get rss links by searching podcast name from this website: https://castos.com/tools/find-podcast-rss-feed/

### Due to limitation of API usage, we recommend you to choose podcast episodes that are no longer than 30 minutes.
</file>

<file path="vite.config.js">
import { defineConfig } from "vite";
import reactJsxPlugin from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [reactJsxPlugin()],
  server: { 
    port: 8080,
    proxy:{
      '/deepl': {
        target: 'https://api-free.deepl.com',
        changeOrigin: true, //*makes the proxy set the request's Origin and Host headers *
        // *to match the target server, so it looks like the request is coming from the same origin.*
        rewrite: (path) => path.replace(/^\/deepl/, ''),
        configure: (proxy, options) => {
          proxy.on('error', (err, req, res) => {
            console.error('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq, req, res) => {
            console.log('Proxying:', req.method, req.url);
          });
        }
      }
    }
   },
  build: { sourcemap: true, minify: false, rollupOptions: {
    output: {
      manualChunks: {
        vendor: ['react', 'react-dom']
      }
    }
  } },
});
</file>

</files>
</file>

<file path="tsconfig.base.json">
{
  "compilerOptions": {
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "files": []   // 防止被误当成编译入口时报 "No inputs were found"
}
</file>

<file path="tsconfig.json">
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",

    "allowJs": true,
    "checkJs": false,
    "resolveJsonModule": true,

    "strict": false,
    "noImplicitAny": false,
    "skipLibCheck": true,
    "noUncheckedIndexedAccess": false,
    "exactOptionalPropertyTypes": false,

    "noEmit": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "verbatimModuleSyntax": true,

    "baseUrl": "src",
    "paths": {
      "@/*": ["*"],
      "@app/*": ["app/*"],
      "@features/*": ["features/*"],
      "@shared/*": ["shared/*"],
      "@services/*": ["services/*"]
    },

    "types": ["vite/client", "node"]
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="vite.config.ts">
// vite.config.js

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'node:path';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 8080,
    proxy: {
      // This rule handles translation API requests
      '/deepl': {
        target: 'https://api-free.deepl.com',
        changeOrigin: true,
        rewrite: (p) => p.replace(/^\/deepl/, ''),
      },
      // This rule forwards all other API requests to your backend
      '/api': {
        target: 'http://localhost:3000', // Your backend server address
        changeOrigin: true,
        // This part adds logging to help with debugging
        configure: (proxy, options) => {
          proxy.on('proxyReq', (proxyReq, req, res) => {
            console.log(`[Vite Proxy] Forwarding request to backend: ${req.method} ${req.url}`);
          });
          proxy.on('error', (err, req, res) => {
            console.error('[Vite Proxy] Error:', err);
          });
        }
      },
      '/ws': {
        target: 'ws://localhost:3000',
        changeOrigin: true,
        ws: true,
      },
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@app': path.resolve(__dirname, 'src/app'),
      '@features': path.resolve(__dirname, 'src/features'),
      '@shared': path.resolve(__dirname, 'src/shared'),
      '@services': path.resolve(__dirname, 'src/services'),
    },
  },
});
</file>

</files>
